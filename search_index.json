[["index.html", "R for Data Science Book Club Welcome", " R for Data Science Book Club The R4DS Online Learning Community 2022-10-21 Welcome This is a companion for the book R for Data Science by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. This companion is available at r4ds.io/r4ds. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction The Introduction gives an overview of what the book covers. Learning objectives: Describe a typical data science project. Explain the reasoning behind the order of content in this book. Recognize topics that are explicitly not covered by this book. Set up an environment in which you can learn the topics in this book. Describe how code in the book differs from code in your console. Recall ways to get help with R code. Produce a minimal reproducible example or reprex. "],["a-typical-data-science-project.html", "1.1 A typical data science project", " 1.1 A typical data science project The data science process Import: Get a data from a file, database, or web app into R. Tidy: Make sure each column in your data is a variable and each row in your data is an observeration. Transform: Filter your data to specific observations, mutate existing columns into new columns, and summarize data. Visualize: Visualization is an important component of data exploration, but usually isn’t very useful for automated processes. Model: Once you know what you’re asking, you can use a model to answer those questions. Models tend to scale well. Communicate: Communication is a critical part of data science! It doesn’t matter how good your models are if nobody knows about them. Program: Programming can aid the entire process, and unlock things that wouldn’t be possible to determine by hand. "],["the-order-of-content-in-this-book.html", "1.2 The order of content in this book", " 1.2 The order of content in this book Import &amp; Tidy are boring, so we jump to visualization &amp; transformation. After that we learn to wrangle (import &amp; tidy) data, because that is a necessary skill. Those baseline skills enables us to start programming. Learning to program helps us simplify the other steps. We might then get into modeling and communicating, or we might pick those up in books that are more specifically devoted to those skills. "],["not-covered-by-this-book.html", "1.3 Not covered by this book", " 1.3 Not covered by this book Big data: Working with big data is problem-specific. If you need to work with big data, other tools will be useful to learn. Python, Julia, etc: This book focuses on R. Master one tool at a time, but maybe go on to other tools later. Non-rectangular data: Honestly even a lot of things that aren’t naturally table-like can be coerced to be table-like, so it makes sense to start with tables. Hypothesis confirmation: This book focuses on exploratory data analysis. "],["setting-up-an-environment.html", "1.4 Setting up an environment", " 1.4 Setting up an environment We’ll need: R Rstudio The tidyverse (install.packages(\"tidyverse\")) Three additional packages (install.packages(c(\"nycflights13\", \"gapminder\", \"Lahman\"))) "],["running-r-code.html", "1.5 Running R code", " 1.5 Running R code Code in the book has some slight differences from code on your console. Don’t freak out. "],["getting-help.html", "1.6 Getting help", " 1.6 Getting help Pay attention to error messages. tidyverse error messages tend to actually be helpful. If you can’t figure out what an error is telling you, copy/paste it into Google. Stackoverflow.com can be helpful, but beware. r4ds.io/join is a friendly Slack community with volunteer R tutors. When you ask for help, make a reprex if possible. State up front what packages you use (we’ll learn about loading packages very soon). Provide (a subset of) any data you use with dput(). Make sure your code is easy to read. Use clean spacing, clear variable names, and comments. #rstats twitter is super active and surprisingly friendly. "],["meeting-videos.html", "1.7 Meeting Videos", " 1.7 Meeting Videos 1.7.1 Cohort 5 Meeting chat log 00:18:00 Morgan Grovenburg: I have to leave early today. Also, I&#39;d normally have my video on, but my kid is currently using me as a jungle gym 00:21:19 Susie Neilson: Link to our team’s work :) https://www.sfchronicle.com/data/ 00:22:40 Morgan Grovenburg: I know what talk you&#39;re talking about 00:23:10 Wai-Yin: Data journalism’s wikipedia article https://en.wikipedia.org/wiki/Data_journalism 00:49:59 Ryan Metcalf: Great question Susie! I consider “Big Data” anything I can’t open in a conventional service. Using scripting languages helps with managing overhead (Cost [not monetary], time of process, processing capability, etc…). 01:00:14 Njoki Njuki Lucy: data.table has the similar syntax as the base R package. 01:17:46 Jon Harmon (jonthegeek): r4ds.io/r4ds 1.7.2 Cohort 6 Meeting chat log 00:09:03 Matthew Efoli: Good day everyone 00:09:16 Trisha Adamus(she/her): Hi 00:09:39 Shannon: Good morning, everyone :) 00:09:45 Adeyemi Olusola: hello. 00:09:56 Marielena Soilemezidi: Hi all! :) 00:10:18 Adeyemi Olusola: who is facilitating this cohort? 00:10:38 Nico Schmidt: I think it is Daniel, at least according to Slack 00:10:59 Shannon: I was just going to ask. Assuming we&#39;re waiting for the host? 00:11:41 Trisha Adamus(she/her): Has anyone participate in a cohort before? I am not sure what to expect. 00:12:20 Daniel Adereti: Hello all, reaching out to Jon. First classes are usually introductions 00:12:35 Adeyemi Olusola: i joined cohort 5 last week just to have a feel and it was pretty interesting 00:12:37 Matthew Efoli: @Trisha For me, No. This is my first. 00:12:45 Shannon: I haven&#39;t. Was wondering if today is just an intro, or if we&#39;re jumping into Ch.1 00:12:45 Nico Schmidt: Then maybe let’s start, Daniel? 00:13:23 Nico Schmidt: If we are jumping into Chapter 1, I have already missed my homework one time 00:14:40 Shannon: haha, me too... 00:16:41 Nico Schmidt: Do we do this with Cameras on or off? 00:18:14 Aalekhya Reddam: Hello everyone, unfortunately my microphone / camera aren&#39;t working right now, hope to have it figured out by next week! I&#39;m a postdoctoral researcher in the US. My research is in environmental epidemiology and data science is a huge part of my work 00:20:39 Jon Harmon (jonthegeek): Shared notes/slides: r4ds.io/r4ds 00:26:47 Aalekhya Reddam: Do we usually volunteer the week ahead for the next week? 00:28:53 Aalekhya Reddam: Thank you! 00:37:01 Matthew Efoli: bye Jon 00:37:19 Adeyemi Olusola: let me go 00:39:04 Nico Schmidt: Cool! 00:39:08 Nico Schmidt: Thanks Daniel 00:39:16 Marielena Soilemezidi: sounds good! 00:39:47 Aalekhya Reddam: That sounds great! 00:39:50 Shannon: Sounds good! Thank you Daniel and Adeyemi, for volunteering for next week! 00:40:12 Trisha Adamus(she/her): Thank you! 00:40:14 Matthew Efoli: Thank you 00:40:28 Marielena Soilemezidi: have a great day you all! :) In this section, we’ll learn the basics about: Data visualization Workflow basics Data transformation Workflows with pipes Data tidying Coding style Data import Script and projects Exploratory data analysis Getting help "],["data-visualisation.html", "Chapter 2 Data visualisation", " Chapter 2 Data visualisation Learning objectives: “The fundamental principles or rules of an art or science” OED Online 1989 Data visualisation: learning the basic structure of a ggplot2 plot Data transformation: select, filter, create, and summarize Exploratory data analysis: combination of visualisation and transformation In the next chapters we will see how modeling is an important part of the exploratory process and focus on R workflow. Learning objectives: Load the tidyverse family of packages Produce a simple plot with {ggplot2} Use aesthetic mappings to produce more complex plots Deal with common R programming problems. Produce small multiples with facet() Combine multiple geom_*() objects to produce more complex plots Recognize the interaction between stats and geoms Use the position argument to control data layout. Use alternative coordinate systems for plots in ggplot2 Describe the components of the layered grammar of graphics "],["loading-packages-in-r.html", "2.1 Loading Packages in R", " 2.1 Loading Packages in R Use install.packages(\"PACKAGE_NAME\") to install a package in R. You need to do this before you can use a package, but you only need to do it once. Depending where you’re learning R, the packages you need may already be installed. Use library(PACKAGE_NAME) to load a package in R. In general, you want to do this at the start of any session where you use a package. Alternatively, you can refer to a package every time you use it, such as ggplot2::ggplot(). “ggplot2” is the package, “ggplot()” is the function call, “::” tells R “look up this function in this package.” library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ── ## ✔ ggplot2 3.3.6 ✔ purrr 0.3.5 ## ✔ tibble 3.1.8 ✔ dplyr 1.0.10 ## ✔ tidyr 1.2.1 ✔ stringr 1.4.1 ## ✔ readr 2.1.3 ✔ forcats 0.5.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() "],["first-steps.html", "2.2 First Steps", " 2.2 First Steps 2.2.1 How to visualise your data using ggplot2 “ggplot2 is a plotting system for R, based on the grammar of graphics, which tries to take the good parts of base and lattice graphics and none of the bad parts. It takes care of many of the fiddly details that make plotting a hassle (like drawing legends) as well as providing a powerful model of graphics that makes it easy to produce complex multi-layered graphics.” © Hadley Wickham 2013 The {ggplot2} package is one of the {tidyverse} packages, it lets us build up plots layer by layer. Figure 2.1: ggplot2 package The layered grammar of graphics: to see the structure of a ggplot() ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot(data = &lt;DATA&gt;): Set up a base plot with data &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)): Add a geometry, such as a point (geom_point()) mapping: Map visual properties (x, y) to variables from data (displ, hwy) aes(): A function to do the mapping. The name is short for “aesthetics.” Spoiler alert: “aesthetics” is the word Hadley uses for “visual properties” Other little things brought out here: Type ?FUNCTION_NAME (`?) to load help for that function (or data object) All {tidyverse} help is also available at tidyverse.org Exercises solution are available at: jrnold.github.io/r4ds-exercise-solutions After having loaded the library you can start building your plot. Let’s start with making an empty plot: ggplot() + geom_blank() The ggplot() function can be used by adding data inside the function as its first argument, and adding a mapping as a second argument: ggplot( data = &lt; some data &gt; , mapping = aes( x = x , y = y )) + &lt;GEOM_FUNCTION&gt;() "],["geometry.html", "2.3 Geometry", " 2.3 Geometry There are several different types of of &lt;GEOM_FUNCTION&gt;: geom_ point (scatterplot) line smooth histogram / bar or (stat_count) / col boxplot map text … "],["aesthetic-mappings.html", "2.4 Aesthetic mappings", " 2.4 Aesthetic mappings Aesthetics are visual properties of objects in the plot. There are several different types of of aesthetic mapping: coordinates: x and y size shape color fill alpha (transparency) stroke linetype group show.legend others, sometimes specific to a geom Use the mapping argument and the aes function to map an aesthetic to a variable in data. Or assign the in the ggplot() function and the mapping in one of the : ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) As an example we load the data provided in {ggplot2}: ggplot2::mpg Display the data head of the first 3 rows: head(mpg,3) ## # A tibble: 3 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… Add a to ggplot(&lt;DATA&gt;) with: ggplot(data=mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) Here the color appears outside the mapping but what if it will be set inside of it? A super common error: Trying to set the color inside the aes call results in random effects because aes() automatically figures out the necessary scale for your data. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;)) "],["common-problems.html", "2.5 Common problems", " 2.5 Common problems What is very important when deciding on a visualization of your data? Before you create your visualization, you need to have your data ready. We’ll learn more about these steps in upcoming chapters:``` import your data tidy the data to have your variables ready to display transform the data as needed visualize the data with a plot model communicate One more suggestion would be to sketch down your visualization before hand and then set the data ready and plot it! More tips: The {tidyverse} (the packages described in this book) tend to have really good error messages. Pay attention to what they say! Read the help at ?function_name to see if maybe it doesn’t work how you thought it worked Googling error messages can often help Take a deep breath. You’ve got this! Get practice doing some TidyTuesdays "],["other-function-and-features.html", "2.6 Other function and features", " 2.6 Other function and features Facets Statistical transformations Position adjustments Coordinate systems Themes 2.6.1 Facets They never use this terminology, but… you can subgroup your visualization with a facet_ function: Small multiples: Multiple plots on the same axes comparing something across splits in a dataset There are 2 versions of this function in ggplot2: facet_wrap() the variable that you pass to facet_wrap() should be discrete facet_grid() the formula should contain two variable names separated by a ~ ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) You can either use ~ or vars() 2.6.2 Statistical transformations Lots of geoms use transformed data. For example, geom_bar(aes(x = cut)) calculates a count for each cut. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) stat_*() functions do this calculation. ?stat_count (etc) has a Computer variables section that tells you what that stat computes. You can use these computed variables to make fancier plots. 2.6.3 Position adjustments Geoms have a position argument to tell it how to deal with things that go on top of one another. Sample values include “stack”, “identity”, “fill”, “dodge”, and “jitter”. geom_jitter() is a shortcut for geom_point(position = \"jitter\") because it’s super useful. dat &lt;- tibble( x = rep(1:3, 3), y = rep(1:3, 3) ) ggplot(dat, aes(x, y)) + geom_point() ggplot(dat, aes(x, y)) + geom_jitter() Use width and height arguments of geom_jitter to more specifically specify range. ggplot(dat, aes(x, y)) + geom_jitter(width = 0.1, height = 0.5) 2.6.4 Coordinate systems Add Coordinate systems to your ggplot with: coord_flip() coord_quickmap() coord_polar() coord_fixed() By default, {ggplot} uses coord_cartesian() but you can add other functions: coord_flip() can be useful to quickly flip orientations (although this is less necessary in modern {ggplot} than when this book was written; now there’s an “orientation” argument that is usually guessed properly if you leave it blank) coord_quickmap() does proper transformations to work with lat/long data. coord_polar() for circular plots, which are almost always a bad idea but they tend to look cool coord_fixed() set the same limits to both axis 2.6.5 Theme Once your data are imported, tidied and transformed adeguately for obtaing desired visualization you can start setting up a plot with extra features: ?theme It is possible to add a theme() function to your ggplot, this is done to customize the non-data components of your plots: titles labels fonts background gridlines legends … For example if you would like to customize the background of your plot: ggplot() + geom_blank() + theme(plot.background = element_rect(color = &quot;red&quot;, size = 2, fill = &quot;gold&quot;), panel.background = element_rect(color = &quot;grey&quot;, size = 5, fill = &quot;darkblue&quot;)) Or you can customize a theme_, there are many different themes provided by defauld by ggplo2 such as: theme_classic() theme_minimal() theme_void() just to name a few, those function then can be further customize by adding the theme customization function. "],["to-summarize-the-gg-in-ggplot.html", "2.7 To summarize: The gg in {ggplot}", " 2.7 To summarize: The gg in {ggplot} {ggplot} implements the “layered grammar of graphics.” ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; + &lt;THEME_FUNCTION&gt; + theme() ggplot(data = &lt;DATA&gt;): Set up a base plot with data. &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)): Add a geometry, such as a point (geom_point()). mapping: Map aesthetics (x, y) to variables from data (displ, hwy). stat: How to transform the data. aes(): A function to do the mapping. The name is short for “aesthetics.” position: How to deal with things that overlap. &lt;COORDINATE_FUNCTION&gt;: Adjust the coordinate layout. &lt;FACET_FUNCTION&gt;: Break the plot up into small multiples. In addition it is possible to subset data inside the ggplot() function or inside the &lt;GEOM_FUNCTION&gt;(): ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE) R4DS book 2.7.1 Exercises: R for Data Science: Exercise Solutions 2.7.2 Resources: A Layered Grammar of Graphics {ggplot2} ggplot2 extensions - gallery R Graphics Cookbook "],["meeting-videos-1.html", "2.8 Meeting Videos", " 2.8 Meeting Videos 2.8.1 Cohort 5 Meeting chat log 00:11:14 Jon Harmon (jonthegeek): r4ds.io/r4ds 00:12:06 Saeed Shafiei Sabet: Hi everyone! 00:12:29 Sandra Muroy: Hi Saeed! 00:13:05 Becki R. (she/her): Hello! 00:13:30 Sandra Muroy: Hi Becki! 00:22:41 Saeed Shafiei Sabet: Can also by using ggplot2 do some 3D surface plots? 00:24:01 shamsuddeen: https://ggplot2.tidyverse.org/reference/geom_contour.html 00:24:12 shamsuddeen: 2D contours of a 3D surface 00:25:34 Saeed Shafiei Sabet: Thanks @shamsuddeen ;) 00:25:50 Jon Harmon (jonthegeek): ggplot2 is 2D. There are other packages for 3D visualization, I&#39;ll try to link some in your question on the Slack once we&#39;re done! 00:26:29 Saeed Shafiei Sabet: @Jon Thanks a lot! :) 00:26:34 shamsuddeen: I guess this package provides 3D plotting https://www.rayshader.com/index.html 00:27:24 Jon Harmon (jonthegeek): Yup, that&#39;s the one I was going to recommend: https://cran.r-project.org/web/packages/rayshader/index.html 00:28:28 Jon Harmon (jonthegeek): I found it super helpful to figure out how to read some of these things as words: %&gt;% = &quot;and then&quot; ~ = &quot;by&quot; (usually) 00:28:30 shamsuddeen: Looks at some practical examples of the package here: https://www.tylermw.com/3d-ggplots-with-rayshader/ 00:29:54 Saeed Shafiei Sabet: Thank you! 00:36:02 docksbox@pm.me: https://jrnold.github.io/r4ds-exercise-solutions/ 00:40:57 Jon Harmon (jonthegeek): ?ggplot2::mpg will show all the details of the dataset 00:41:50 Sandra Muroy: thanks Jon :) 00:42:40 Jon Harmon (jonthegeek): hwy = &quot;highway miles per gallon&quot;, cty = &quot;city miles per gallon&quot; in that set, so usually that&#39;s what you&#39;d want on y. 00:43:38 Becki R. (she/her): Did I hear correctly that the dependent variable goes on the y-axis? 00:44:04 Jon Harmon (jonthegeek): Generally, yes. But it&#39;s whatever you specify as &quot;y&quot; in the &quot;aes&quot; call. 00:44:16 Becki R. (she/her): ok thanks 00:49:24 Jon Harmon (jonthegeek): The &quot;labs&quot; function is for all of the labels for your plot. 00:51:26 Jon Harmon (jonthegeek): https://twitter.com/search?q=%23tidytuesday&amp;src=typed_query 00:51:48 Hector: Is there any specific use for the ggtitle() function in contrast with labs() ? 00:52:09 Njoki Njuki Lucy: what is there a difference between stat=&quot;count&quot; and stat=&quot;identity&quot;? I understand stat = &quot;count returns count per each level. 00:53:23 Jon Harmon (jonthegeek): @Hector: ggtitle is equivalent to labs() for just the title and subtitle parts. It&#39;s just to make it easier to focus on those specific bits. 00:53:56 Jon Harmon (jonthegeek): @Njoki: &quot;count&quot; means &quot;how many entries have this value?&quot;, vs &quot;identity&quot; means &quot;what value is in this cell?&quot; 00:54:59 Hector: Thank you! 00:55:04 Njoki Njuki Lucy: thank you. 00:56:26 Jon Harmon (jonthegeek): &quot;color&quot; = outside, &quot;fill&quot; = inside 00:58:53 docksbox@pm.me: labs() 01:04:36 Ryan Metcalf: Could it be stated that “labs” is a more eloquent way of labeling than explicitly calling each field directly? Less lines of code maybe? 01:05:47 Jon Harmon (jonthegeek): I&#39;m not sure I&#39;d say &quot;eloquent,&quot; but it&#39;s just another option. They provide the separate functions in case you&#39;re looking for them, basically. 01:07:23 Jon Harmon (jonthegeek): Sorry about that! 01:08:23 Susie Neilson: This was a great presentation - thank you so much Federica! 01:12:31 docksbox@pm.me: example would be the use of a map data 01:12:51 Saeed Shafiei Sabet: Thanks Federica :) 01:13:43 docksbox@pm.me: great thanks! 01:13:46 Fodil: thank you everyone was very interesting. 01:13:51 Becki R. (she/her): Thanks, Federica! 01:13:56 Njoki Njuki Lucy: Thank you. 01:13:56 Saeed Shafiei Sabet: Thank you 01:13:58 Saeed Shafiei Sabet: bye 2.8.2 Cohort 6 Meeting chat log 00:16:33 Daniel Adereti: do I have to run library(tidyverse) everytime I start my R? 00:17:15 Zaynaib Giwa, @zaynaib: You only need to call it once when you open R Studio 00:21:14 Shannon: To double check that you have it installed, you can click on the &#39;Packages&#39; tab in the lower right pane. If it&#39;s installed, you&#39;ll see it listed next to a checkbox. Once you load the package with the library() function, you will see a checkmark in the box. 00:28:20 Freya Watkins (she/her): displ &#39;s class is dbl (double) which is a floating point number for decimal precision. int (integer) is for full rounded values (I think) 00:28:49 Zaynaib Giwa, @zaynaib: cute cat 00:28:49 Vrinda Kalia: Yes, I was just typing that up @Freya I think you are right 00:30:26 Aalekhya Reddam: In Line 88 is it a - or = between data and mpg? 00:30:57 Matthew Efoli: I think it is an equal to sign 00:30:58 Aalekhya Reddam: Sorry that was my screen lagging! 00:38:43 Shannon: Another option for finding number of rows and number of columns, that I used, is nrow(mpg) and ncol(mpg). Not as much info as glimpse(), but more concise. 00:41:42 Freya Watkins (she/her): @Shannon, dim(mpg) also gives both dimensions in one command (number of rows, followed by number of columns) :) 00:42:35 Shannon: @Freya, perfect! thanks! 00:49:45 Zaynaib Giwa, @zaynaib: I have to leave a bit early. But it was nice meeting everyone. See you next week. 00:50:02 Shannon: See you next week! 00:50:30 Matthew Efoli: See you next week Zaynaib 00:50:34 Aalekhya Reddam: I have to head out too, see you all next week! :) 00:50:57 Shannon: 👋 00:51:06 Matthew Efoli: Have a nice weekend Aalekhya! 00:51:20 Freya Watkins (she/her): missing the closing bracket I think 00:53:58 Daniel Adereti: See you next week Aalekhya and Zaynaib! 00:54:27 Daniel Adereti: We have 10 more minutes, so we may have to carry over the chapter to next week, I think 00:55:10 Matthew Efoli: @Daniel okay 00:56:31 Shannon: That works for me. I&#39;d have more time to look over the second half of the chapter. :) 00:56:52 Marielena Soilemezidi: Yes, same for me! :) 00:56:52 Vrinda Kalia: Yes, this sounds good to me as well! 00:59:17 Shannon: Nice work presenting, Adeyemi! Thank you! 00:59:20 Marielena Soilemezidi: Daniel, could you share the link of the spreadsheet here? 00:59:40 Daniel Adereti: https://docs.google.com/spreadsheets/d/1zy2nXNkvcdqWuF8rQ5ApWRkVQG_UJt0azu3h_mEnY2E/edit#gid=0 00:59:43 Marielena Soilemezidi: Because I couldn&#39;t find it in Slack for some reason 00:59:47 Marielena Soilemezidi: thank you!! 01:00:35 Daniel Adereti: 👍 01:08:40 Vrinda Kalia: Maybe try “stroke = class” ? 01:10:01 Freya Watkins (she/her): try stroke = 5. it should modify the width of the border so I think needs a numeric argument 01:10:08 Daniel Adereti: maybe this? ggplot(data = mpg)+ geom_point(mapping = aes(x = displ, y = hwy), shape = 17, stroke = 3) 01:10:32 Vrinda Kalia: I see, it needs a numeric argument 01:11:37 Vrinda Kalia: Thank you so much for leading the discussion, Adeyemi! 01:11:55 Matthew Efoli: Thank you so much Adeyemi! 01:11:56 Freya Watkins (she/her): Thank you, Adeyemi! Great job :) 01:11:57 anacuric: thank you! 01:11:58 Marielena Soilemezidi: Thank you guys! And thanks Adeyemi for presenting!! :) 01:12:00 Shannon: Thank you everyone! 01:12:01 Adeyemi Olusola: thank you 01:12:02 Marielena Soilemezidi: See you next week! 01:12:16 Matthew Efoli: see you next week! Meeting chat log 00:06:29 Adeyemi Olusola: Good day Daniel 00:06:58 Daniel Adereti: Hello Olusola! 00:07:06 Daniel Adereti: Looking forward to today! 00:07:21 Adeyemi Olusola: Yeah yeah. 00:12:52 Amélie Gourdon-Kanhukamwe: Hi everyone, I am in my shared office at work, so cannot really speak (have been meaning to join from the start, but shared office = loads of distraction). (I am based in London UK). 00:14:12 Shannon: Hi Amelie, nice to &#39;meet&#39; you :) 00:20:49 Aalekhya Reddam: I may have missed it but what is the difference between adding a period and not adding one for facet_grid? 00:22:41 Shannon: I think I missed that too, I second that question. 00:26:04 Freya Watkins (she/her): The point should have removed one of the dimensions - either vertical or horizontal 00:29:57 Shannon: So, having a point or no point would have the same result? Ex: ( ~ drv) is the same as( . ~drv)? Or (drv ~) is the same as (drv ~ .) ? 00:32:11 Aalekhya Reddam: That’s what I understood too Shannon! The location of the ~ determines orientation and I guess the “.” is a placeholder 00:32:48 Shannon: I think that&#39;s how I&#39;m understanding it, too 00:39:09 Freya Watkins (she/her): Yes I believe that&#39;s right @Shannon, @Aalekhya - I think in the previous plot there was an extra dimension (drv ~ cyl) which had rows and columns, then replacing drv with a point (. ~ cyl) just returns a plot faceted with columns for cyl. Then (~ cyl) returns the same plot as (. ~ cyl) 00:39:44 Aalekhya Reddam: Ah okay, thank you Freya! 00:39:52 Shannon: Okay, thanks Freya! 00:58:00 Shannon: That last one drove me crazy, I couldn&#39;t figure it out! I tried position = jitter and tied to adjust stroke. Looks like the solution is two geom_point layers. Thanks for solving that one! 01:10:45 Aalekhya Reddam: I have another meeting and have to head out, thank you for a great lesson Adeyemi! See you all next week 01:10:57 Vrinda Kalia: Thank you so much, Adeyemi! I appreciate your thoroughness. I need to leave for a 1pm call. See you all next week! 01:11:06 Shannon: See you next week! 01:11:13 Daniel Adereti: Hello guys, will we like to conclude the chapter ourselves next time so we move to the next chapter with Matthew? 01:11:20 Shannon: Thank you Adeyemi! 01:11:30 Marielena Soilemezidi: See you guys! Thank you Adeyemi!! 01:11:32 Matthew Efoli: Thank you Adeyemi 01:11:35 Freya Watkins (she/her): Thanks Adeyemi! Really helpful, thanks for all the extra time and effort on the exercises 01:11:42 Amélie Gourdon-Kanhukamwe: Thank you! 01:11:58 Freya Watkins (she/her): I&#39;m happy to finish the rest myself and move on to next chapter next time :) 01:12:43 Matthew Efoli: I have to go. I will be taking the next chapter 01:12:47 Freya Watkins (she/her): Bye! Thanks Daniel 01:12:52 Matthew Efoli: bye "],["workflow-basics.html", "Chapter 3 Workflow: basics", " Chapter 3 Workflow: basics Learning objectives: Understand the RStudio interface Use the R command line boldly Follow good style conventions when writing code Confidently call functions in R "],["the-console-pane.html", "3.1 The Console Pane", " 3.1 The Console Pane "],["the-script-pane.html", "The Script Pane", " The Script Pane "],["the-environment-pane.html", "The Environment Pane", " The Environment Pane "],["the-other-pane.html", "The Other Pane", " The Other Pane "],["using-the-console.html", "Using the Console", " Using the Console Conceptually, everything we do in R is a series of commands. The console is where we can enter these commands. By default, entering &lt;thing&gt; means “print out &lt;thing&gt;.” 4 ## [1] 4 "],["using-the-console-1.html", "Using the Console", " Using the Console R has some pre-defined named objects: pi ## [1] 3.141593 This one is surprisingly useful: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; "],["using-the-console-2.html", "Using the Console", " Using the Console What it means to “print out” a thing depends on what kind of thing it is. ggplot2::diamonds ## # A tibble: 53,940 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows "],["using-the-console-3.html", "Using the Console", " Using the Console Actually, entering &lt;thing&gt; really means “evaluate and print &lt;thing&gt;.” cos(pi) ## [1] -1 I use R as a desktop calculator a lot. 60*60*24 ## [1] 86400 "],["assigning-names.html", "Assigning Names", " Assigning Names Sometimes you don’t just want to print out a thing, especially if it’s a complex evaluation. You want to save it to a named object so that you can do more stuff with it. Use the assignment arrow (&lt;-) for this. tau &lt;- 2*pi Most programming languages use the equals sign (=) for assignment, and this also works in R. But assignment is really a conceptually distinct thing from mathematical equality, so it makes sense to use a different symbol. It’s a bit more annoying to type, though, so get used to the keyboard shortcut Alt+minus. Objects that you have named will show up in the “Environment” panel. "],["assigning-and-printing.html", "Assigning and Printing", " Assigning and Printing By default, when you make an assignment, the result of the evaluation is not printed in the console. To assign and print in one command, surround the assignment with parentheses: (tau &lt;- 2*pi) ## [1] 6.283185 "],["pronouncing-code.html", "Pronouncing Code", " Pronouncing Code It’s easier to remember and understand a thing if you can say it (either out loud or in your head). A common pronunciation of &lt;- is “gets,” so tau &lt;- 2*pi would be read as “tau gets two times pi.” "],["naming-things.html", "3.2 Naming Things", " 3.2 Naming Things There are only two hard things in computer science: cache invalidation and naming things. And off-by-one errors. Picking good names for things is both harder and more important than you might guess. Having good guidelines for naming things can save you a lot of mental effort down the road. Names in R can only contain letters, numbers, _, and .. R is case-sensitive! And it can’t read your mind. Sticking with a good style convention will make your code more readable, both for others, and for yourself in the future. Some suggestions: Use descriptive names. Long names are ok! Use all lowercase by default, with _ as a separator. student_item_data num_students fall2020_math_courses_with_multiple_sections "],["functions.html", "3.3 Functions", " 3.3 Functions A function in R is like a function in math: it’s a box that takes in input and returns output.1 Functions can take zero, one, or more than one object as input. When you call a function, you specify values (arguments) for the inputs. Evaluating the function call gives the output of the function. length(letters) ## [1] 26 Or: nrow(ggplot2::diamonds) ## [1] 53940 Functions may also have side effects, which is something we can talk about later.↩︎ "],["functions-1.html", "Functions", " Functions The inputs (the function parameters) have names. When you pass in the function arguments, you can do so by name: seq(from = 1, to = 10) ## [1] 1 2 3 4 5 6 7 8 9 10 Specifying names is (usually) optional, but it can make your code more readable, so it’s a good habit to get into. If you name the arguments, it doesn’t matter what order you put them in: seq(to = 10, from = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 If you don’t specify names, the function matches the arguments to the parameters in the order they appear in the function definition. seq(10, 1) ## [1] 10 9 8 7 6 5 4 3 2 1 "],["other-rstudio-features.html", "Other RStudio Features", " Other RStudio Features Explore on your own: tab autocomplete up-arrow to see console history type, then command- (control-) up-arrow to search history alt-shift-k to see lots of shortcuts one of my recent favorites: alt-command-down-arrow (inside a script) "],["meeting-videos-2.html", "3.4 Meeting Videos", " 3.4 Meeting Videos 3.4.1 Cohort 5 Meeting chat log 00:14:44 Jon Harmon (jonthegeek): Ignore the URL on these, I should have made my coworker crop those out since it isn&#39;t relevant outside of our work environment 🙃 00:47:00 Jon Harmon (jonthegeek): ?variable.names 00:58:53 Becki R. (she/her): jon_doe is an object? 00:59:05 Wai-Yin: Yes. 01:10:33 Becki R. (she/her): Is there a list of verbal substitutions like &quot;&lt;- = get&quot;? 01:16:05 Jon Harmon (jonthegeek): Not yet! Some more will come up as we go through the book... and I plan on putting something together with them before too long! 01:16:56 Becki R. (she/her): Nice! 01:20:44 docksbox@pm.me: Thanks 01:22:41 Becki R. (she/her): Thanks everyone! I will not be here next week. "],["data-transformation.html", "Chapter 4 Data transformation", " Chapter 4 Data transformation Learning objectives: Pick out rows of a data frame with the dplyr::filter() function. Sort rows of a data frame with dplyr::arrange(). Pick out columns of a data frame with dplyr::select(). Modify columns of a data frame with dplyr::mutate(). Group rows of a data frame with dplyr::group(). Apply functions to columns of a (grouped) data frame with dplyr::summarize(). Streamline data transformations with the pipe operator (%&gt;%). "],["introduction-1.html", "4.1 Introduction", " 4.1 Introduction 4.1.1 Prerequisites dplyr is a package that provides functions to manipulate data frames. Data frame consists of columns (variables) and rows (observations). dplyr is part of the tidyverse. You can install and load the all the packages from tidyverse (ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats) install.packages(&quot;tidyverse&quot;) library(tidyverse) Or just install and load dplyr. install.packages(&quot;dplyr&quot;) library(dplyr) 4.1.2 nycflights13 The data set nycflights13 contains data about flights that departed New York City in 2013. install.packages(&quot;nycflights13&quot;) library(nycflights13) When you use data set for the first time, it’s good practice to quickly browse the data to check if you want to use the data. To view the flights data in the R console. . flights ## # A tibble: 336,776 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 2 830 819 11 UA ## 2 2013 1 1 533 529 4 850 830 20 UA ## 3 2013 1 1 542 540 2 923 850 33 AA ## 4 2013 1 1 544 545 -1 1004 1022 -18 B6 ## 5 2013 1 1 554 600 -6 812 837 -25 DL ## 6 2013 1 1 554 558 -4 740 728 12 UA ## 7 2013 1 1 555 600 -5 913 854 19 B6 ## 8 2013 1 1 557 600 -3 709 723 -14 EV ## 9 2013 1 1 557 600 -3 838 846 -8 B6 ## 10 2013 1 1 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay To view the flights data in a spreadsheet-like viewer. View(flights) Use ?flights to open the help viewer to get info about all the variables. ?flights Check the size of the flights data frame using nrow(), ncol(), length(), and dim(). # number of rows nrow(flights) # [1] 336776 # number of columns ncol(flights) # [1] 19 # number of columns length(flights) # [1] 19 # number of rows and columns dim(flights) # [1] 336776 19 get the column names with colnames() colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; "],["comparisons-and-logical-operators.html", "4.2 Comparisons and logical operators", " 4.2 Comparisons and logical operators 4.2.1 Comparisons &gt; greater than &gt;= greater than or equal &lt; less than &lt;= less than or equal == equal != not equal In math we use = for equality. In programming we use == for equality, and = for assignment. compare numbers 1 &gt; 2 # [1] FALSE 1 &gt;= 2 # [1] FALSE 1 &lt; 2 # [1] TRUE 1 &lt;= 2 # [1] TRUE 1 == 2 # [1] FALSE 1 != 2 # [1] TRUE compare characters &#39;a&#39; &gt; &#39;b&#39; # [1] FALSE &#39;a&#39; &gt;= &#39;b&#39; # [1] FALSE &#39;a&#39; &lt; &#39;b&#39; # [1] TRUE &#39;a&#39; &lt;= &#39;b&#39; # [1] TRUE &#39;a&#39; == &#39;b&#39; # [1] FALSE &#39;a&#39; != &#39;b&#39; # [1] TRUE Case matters when comparing characters. For English, lowercase letters are less than uppercase letters. &#39;a&#39; &gt; &#39;A&#39; # [1] FALSE &#39;a&#39; &gt;= &#39;A&#39; # [1] FALSE &#39;a&#39; &lt; &#39;A&#39; # [1] TRUE &#39;a&#39; &lt;= &#39;A&#39; # [1] TRUE &#39;a&#39; == &#39;A&#39; # [1] FALSE &#39;a&#39; != &#39;A&#39; # [1] TRUE We can change case when comparing characters. tolower() will change characters to lower case. toupper() will change characters to upper case. tolower(&#39;A&#39;) # [1] &quot;a&quot; toupper(&#39;a&#39;) # [1] &quot;A&quot; &#39;a&#39; == tolower(&#39;A&#39;) # [1] TRUE toupper(&#39;a&#39;) == &#39;A&#39; # [1] TRUE 4.2.2 Logical operators &amp; and; all expressions must be true in order to return true TRUE &amp; TRUE # [1] TRUE TRUE &amp; FALSE # [1] FALSE | or; one or more expressions must be true in order to return true; | is the key above the return key, not lowercase letter l. TRUE | TRUE # [1] TRUE TRUE | FALSE # [1] TRUE ! not; negate the expression !TRUE # [1] FALSE !FALSE # [1] TRUE !!TRUE # [1] TRUE assign objects a &lt;- 1 b &lt;- 5 compare object and numbers a &lt; 3 # [1] TRUE a &gt; 3 # [1] FALSE a == 3 # [1] FALSE a != 3 # [1] TRUE compare objects a &lt; b # [1] TRUE a &gt; b # [1] FALSE a == b # [1] FALSE a != b # [1] TRUE comparison and logical operators a &gt; 3 # [1] FALSE b &gt; 3 # [1] TRUE a &gt; 3 &amp; b &gt; 3 # [1] FALSE a &gt; 3 | b &gt; 3 # [1] TRUE !(a == b) # [1] TRUE "],["filter-rows-with-filter.html", "4.3 Filter rows with filter()", " 4.3 Filter rows with filter() filter() allows you to pick out certain rows (observations) . filter() picks the rows which evaluates to TRUE for all criteria. The first argument to filter() is a data frame, the subsequent arguments are the expressions. Combine comparisons and logical operators on the columns to select rows. # number of rows and columns dim(flights) ## [1] 336776 19 # get the column names colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; # select flights from November filter(flights, month == 11) ## # A tibble: 27,268 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 11 1 5 2359 6 352 345 7 B6 ## 2 2013 11 1 35 2250 105 123 2356 87 B6 ## 3 2013 11 1 455 500 -5 641 651 -10 US ## 4 2013 11 1 539 545 -6 856 827 29 UA ## 5 2013 11 1 542 545 -3 831 855 -24 AA ## 6 2013 11 1 549 600 -11 912 923 -11 UA ## 7 2013 11 1 550 600 -10 705 659 6 US ## 8 2013 11 1 554 600 -6 659 701 -2 US ## 9 2013 11 1 554 600 -6 826 827 -1 DL ## 10 2013 11 1 554 600 -6 749 751 -2 DL ## # … with 27,258 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay A tibble: 27,268 × 19 tells you 27,268 rows match the criteria # select flights from December filter(flights, month == 12) ## # A tibble: 28,135 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 12 1 13 2359 14 446 445 1 B6 ## 2 2013 12 1 17 2359 18 443 437 6 B6 ## 3 2013 12 1 453 500 -7 636 651 -15 US ## 4 2013 12 1 520 515 5 749 808 -19 UA ## 5 2013 12 1 536 540 -4 845 850 -5 AA ## 6 2013 12 1 540 550 -10 1005 1027 -22 B6 ## 7 2013 12 1 541 545 -4 734 755 -21 EV ## 8 2013 12 1 546 545 1 826 835 -9 UA ## 9 2013 12 1 549 600 -11 648 659 -11 US ## 10 2013 12 1 550 600 -10 825 854 -29 B6 ## # … with 28,125 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay # select flights not from December (e.g. January to November) filter(flights, month != 12) ## # A tibble: 308,641 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 2 830 819 11 UA ## 2 2013 1 1 533 529 4 850 830 20 UA ## 3 2013 1 1 542 540 2 923 850 33 AA ## 4 2013 1 1 544 545 -1 1004 1022 -18 B6 ## 5 2013 1 1 554 600 -6 812 837 -25 DL ## 6 2013 1 1 554 558 -4 740 728 12 UA ## 7 2013 1 1 555 600 -5 913 854 19 B6 ## 8 2013 1 1 557 600 -3 709 723 -14 EV ## 9 2013 1 1 557 600 -3 838 846 -8 B6 ## 10 2013 1 1 558 600 -2 753 745 8 AA ## # … with 308,631 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay # select flights from November or December filter(flights, month == 11 | month == 12) ## # A tibble: 55,403 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 11 1 5 2359 6 352 345 7 B6 ## 2 2013 11 1 35 2250 105 123 2356 87 B6 ## 3 2013 11 1 455 500 -5 641 651 -10 US ## 4 2013 11 1 539 545 -6 856 827 29 UA ## 5 2013 11 1 542 545 -3 831 855 -24 AA ## 6 2013 11 1 549 600 -11 912 923 -11 UA ## 7 2013 11 1 550 600 -10 705 659 6 US ## 8 2013 11 1 554 600 -6 659 701 -2 US ## 9 2013 11 1 554 600 -6 826 827 -1 DL ## 10 2013 11 1 554 600 -6 749 751 -2 DL ## # … with 55,393 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay &amp; (and) vs | (or) # select flights from November or from 1st day of any month filter(flights, month == 11 | day == 1) ## # A tibble: 37,318 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 2 830 819 11 UA ## 2 2013 1 1 533 529 4 850 830 20 UA ## 3 2013 1 1 542 540 2 923 850 33 AA ## 4 2013 1 1 544 545 -1 1004 1022 -18 B6 ## 5 2013 1 1 554 600 -6 812 837 -25 DL ## 6 2013 1 1 554 558 -4 740 728 12 UA ## 7 2013 1 1 555 600 -5 913 854 19 B6 ## 8 2013 1 1 557 600 -3 709 723 -14 EV ## 9 2013 1 1 557 600 -3 838 846 -8 B6 ## 10 2013 1 1 558 600 -2 753 745 8 AA ## # … with 37,308 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay # select flights from November 1st filter(flights, month == 11 &amp; day == 1) ## # A tibble: 986 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 11 1 5 2359 6 352 345 7 B6 ## 2 2013 11 1 35 2250 105 123 2356 87 B6 ## 3 2013 11 1 455 500 -5 641 651 -10 US ## 4 2013 11 1 539 545 -6 856 827 29 UA ## 5 2013 11 1 542 545 -3 831 855 -24 AA ## 6 2013 11 1 549 600 -11 912 923 -11 UA ## 7 2013 11 1 550 600 -10 705 659 6 US ## 8 2013 11 1 554 600 -6 659 701 -2 US ## 9 2013 11 1 554 600 -6 826 827 -1 DL ## 10 2013 11 1 554 600 -6 749 751 -2 DL ## # … with 976 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay If you provide multiple comma-separated expressions, dplyr will automatically use &amp; to combine the expressions. # both will select flights from November 1st filter(flights, month == 11 &amp; day == 1) filter(flights, month == 11, day == 1) dplyr functions do not change the original data. To save the results from a function, you need to assign the results to a object. nov1 &lt;- filter(flights, month == 11, day == 1) nrow(nov1) ## [1] 986 nrow(flights) ## [1] 336776 4.3.1 Missing values Often times, rows will not have data for certain columns. In spreadsheets, csv, tsv, the cells will be blank. In R data frames, the missing values are represented as NA (not available). Operations with NA will return NA. NA &gt; 5 # [1] NA 10 == NA # [1] NA NA + 10 # [1] NA NA / 2 # [1] NA NA == NA # [1] NA To check if value is missing use is.na() is.na(NA) # [1] TRUE By default, filter() excludes NA values. To include NA values, you must add an expression. tibble is the tidyverse version of a data frame. tibble haves some extra functions that normal data frames do not have. # create a tibble with a column named &quot;x&quot;, with 3 values df &lt;- tibble(x = c(1, NA, 3)) df ## # A tibble: 3 × 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 NA ## 3 3 # select rows with values greater than 1 filter(df, x &gt; 1) ## # A tibble: 1 × 1 ## x ## &lt;dbl&gt; ## 1 3 # select rows with NA or values greater than 1 filter(df, is.na(x) | x &gt; 1) ## # A tibble: 2 × 1 ## x ## &lt;dbl&gt; ## 1 NA ## 2 3 "],["arrange-rows-with-arrange.html", "4.4 Arrange rows with arrange()", " 4.4 Arrange rows with arrange() arrange() changes the order of the rows. The first argument to arrange() is a data frame, the subsequent arguments are columns names are expression used to sort the rows. Ascending (small to big) is the default order. Use desc() for descending order (big to small). # sort flights by depature delay using ascending order arrange(flights, dep_delay) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 12 7 2040 2123 -43 40 2352 48 B6 ## 2 2013 2 3 2022 2055 -33 2240 2338 -58 DL ## 3 2013 11 10 1408 1440 -32 1549 1559 -10 EV ## 4 2013 1 11 1900 1930 -30 2233 2243 -10 DL ## 5 2013 1 29 1703 1730 -27 1947 1957 -10 F9 ## 6 2013 8 9 729 755 -26 1002 955 7 MQ ## 7 2013 10 23 1907 1932 -25 2143 2143 0 EV ## 8 2013 3 30 2030 2055 -25 2213 2250 -37 MQ ## 9 2013 3 2 1431 1455 -24 1601 1631 -30 9E ## 10 2013 5 5 934 958 -24 1225 1309 -44 B6 ## # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay # sort flights by depature delay using descending order. arrange(flights, desc(dep_delay)) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 9 641 900 1301 1242 1530 1272 HA ## 2 2013 6 15 1432 1935 1137 1607 2120 1127 MQ ## 3 2013 1 10 1121 1635 1126 1239 1810 1109 MQ ## 4 2013 9 20 1139 1845 1014 1457 2210 1007 AA ## 5 2013 7 22 845 1600 1005 1044 1815 989 MQ ## 6 2013 4 10 1100 1900 960 1342 2211 931 DL ## 7 2013 3 17 2321 810 911 135 1020 915 DL ## 8 2013 6 27 959 1900 899 1236 2226 850 DL ## 9 2013 7 22 2257 759 898 121 1026 895 DL ## 10 2013 12 5 756 1700 896 1058 2020 878 AA ## # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay sort by multiple columns # sort flights by year, month, and day using ascending order arrange(flights, year, month, day) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 2 830 819 11 UA ## 2 2013 1 1 533 529 4 850 830 20 UA ## 3 2013 1 1 542 540 2 923 850 33 AA ## 4 2013 1 1 544 545 -1 1004 1022 -18 B6 ## 5 2013 1 1 554 600 -6 812 837 -25 DL ## 6 2013 1 1 554 558 -4 740 728 12 UA ## 7 2013 1 1 555 600 -5 913 854 19 B6 ## 8 2013 1 1 557 600 -3 709 723 -14 EV ## 9 2013 1 1 557 600 -3 838 846 -8 B6 ## 10 2013 1 1 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay arrange() puts NA values at the end. # create tibble with 3 values df &lt;- tibble(x = c(1, NA, 3)) # sort puts NA at the end arrange(df, x) ## # A tibble: 3 × 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 3 ## 3 NA "],["select-columns-with-select.html", "4.5 Select columns with select()", " 4.5 Select columns with select() select() lets you pick which columns (variables) to use. The first argument to select() is a data frame, the subsequent arguments are columns to use. # colnames() retrieves the column names colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; the order you list the columns will determine the order of the columns returned by select(). # select year, month, and day columns. select(flights, year, month, day) ## # A tibble: 336,776 × 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows # use &#39;:&#39; to select columns from year to day (inclusive). select(flights, year:day) ## # A tibble: 336,776 × 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows # use &#39;-&#39; to select columns except from year to day (inclusive). select(flights, -(year:day)) ## # A tibble: 336,776 × 16 ## dep_t…¹ sched…² dep_d…³ arr_t…⁴ sched…⁵ arr_d…⁶ carrier flight tailnum origin ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA 1545 N14228 EWR ## 2 533 529 4 850 830 20 UA 1714 N24211 LGA ## 3 542 540 2 923 850 33 AA 1141 N619AA JFK ## 4 544 545 -1 1004 1022 -18 B6 725 N804JB JFK ## 5 554 600 -6 812 837 -25 DL 461 N668DN LGA ## 6 554 558 -4 740 728 12 UA 1696 N39463 EWR ## 7 555 600 -5 913 854 19 B6 507 N516JB EWR ## 8 557 600 -3 709 723 -14 EV 5708 N829AS LGA ## 9 557 600 -3 838 846 -8 B6 79 N593JB JFK ## 10 558 600 -2 753 745 8 AA 301 N3ALAA LGA ## # … with 336,766 more rows, 6 more variables: dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated ## # variable names ¹​dep_time, ²​sched_dep_time, ³​dep_delay, ⁴​arr_time, ## # ⁵​sched_arr_time, ⁶​arr_delay helper functions for select() starts_with() # select columns that start with &quot;dep&quot; select(flights, starts_with(&quot;dep&quot;)) ## # A tibble: 336,776 × 2 ## dep_time dep_delay ## &lt;int&gt; &lt;dbl&gt; ## 1 517 2 ## 2 533 4 ## 3 542 2 ## 4 544 -1 ## 5 554 -6 ## 6 554 -4 ## 7 555 -5 ## 8 557 -3 ## 9 557 -3 ## 10 558 -2 ## # … with 336,766 more rows ends_with() # select columns that end with &quot;delay&quot; select(flights, ends_with(&quot;delay&quot;)) ## # A tibble: 336,776 × 2 ## dep_delay arr_delay ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 ## 2 4 20 ## 3 2 33 ## 4 -1 -18 ## 5 -6 -25 ## 6 -4 12 ## 7 -5 19 ## 8 -3 -14 ## 9 -3 -8 ## 10 -2 8 ## # … with 336,766 more rows contains() # select columns that contain &quot;dep&quot; select(flights, contains(&quot;dep&quot;)) ## # A tibble: 336,776 × 3 ## dep_time sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 2 ## 2 533 529 4 ## 3 542 540 2 ## 4 544 545 -1 ## 5 554 600 -6 ## 6 554 558 -4 ## 7 555 600 -5 ## 8 557 600 -3 ## 9 557 600 -3 ## 10 558 600 -2 ## # … with 336,766 more rows matches() # select columns that matches regular expression. # &quot;^a(.)r&quot; means it starts with a, has any character, and then r. select(flights, matches(&quot;^a(.)r&quot;)) ## # A tibble: 336,776 × 3 ## arr_time arr_delay air_time ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 830 11 227 ## 2 850 20 227 ## 3 923 33 160 ## 4 1004 -18 183 ## 5 812 -25 116 ## 6 740 12 150 ## 7 913 19 158 ## 8 709 -14 53 ## 9 838 -8 140 ## 10 753 8 138 ## # … with 336,766 more rows num_range() # create tibble with columns x1, x2, x3, x4 df &lt;- tibble(x1 = c(1, 2), x2 = c(2, 3), x3 = c(4, 5), x4 = c(6, 7)) # select column that matches x1, x2 and x3 select(df, num_range(&quot;x&quot;, 1:3)) ## # A tibble: 2 × 3 ## x1 x2 x3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 4 ## 2 2 3 5 rename() changes the column names. rename(data_frame, new_name = old_name) # rename the column dep_time to departure_time rename(flights, departure_time = dep_time) ## # A tibble: 336,776 × 19 ## year month day departure…¹ sched…² dep_d…³ arr_t…⁴ sched…⁵ arr_d…⁶ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 2 830 819 11 UA ## 2 2013 1 1 533 529 4 850 830 20 UA ## 3 2013 1 1 542 540 2 923 850 33 AA ## 4 2013 1 1 544 545 -1 1004 1022 -18 B6 ## 5 2013 1 1 554 600 -6 812 837 -25 DL ## 6 2013 1 1 554 558 -4 740 728 12 UA ## 7 2013 1 1 555 600 -5 913 854 19 B6 ## 8 2013 1 1 557 600 -3 709 723 -14 EV ## 9 2013 1 1 557 600 -3 838 846 -8 B6 ## 10 2013 1 1 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​departure_time, ²​sched_dep_time, ³​dep_delay, ⁴​arr_time, ⁵​sched_arr_time, ## # ⁶​arr_delay use select() and everything() to move some columns to start of the dataframe # rearrange columns to time_hour, air_time, rest of the columns select(flights, time_hour, air_time, everything()) ## # A tibble: 336,776 × 19 ## time_hour air_t…¹ year month day dep_t…² sched…³ dep_d…⁴ arr_t…⁵ ## &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013-01-01 05:00:00 227 2013 1 1 517 515 2 830 ## 2 2013-01-01 05:00:00 227 2013 1 1 533 529 4 850 ## 3 2013-01-01 05:00:00 160 2013 1 1 542 540 2 923 ## 4 2013-01-01 05:00:00 183 2013 1 1 544 545 -1 1004 ## 5 2013-01-01 06:00:00 116 2013 1 1 554 600 -6 812 ## 6 2013-01-01 05:00:00 150 2013 1 1 554 558 -4 740 ## 7 2013-01-01 06:00:00 158 2013 1 1 555 600 -5 913 ## 8 2013-01-01 06:00:00 53 2013 1 1 557 600 -3 709 ## 9 2013-01-01 06:00:00 140 2013 1 1 557 600 -3 838 ## 10 2013-01-01 06:00:00 138 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, 10 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, and abbreviated ## # variable names ¹​air_time, ²​dep_time, ³​sched_dep_time, ⁴​dep_delay, ⁵​arr_time "],["add-new-variables-with-mutate.html", "4.6 Add new variables with mutate()", " 4.6 Add new variables with mutate() mutate() adds new columns based on values from existing columns. Data frame includes existing and new columns. # create data frame with 7 columns: year, month, day, dep_delay, arr_delay, distance, air_time flights_7_columns &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) # calculate and add columns for gain, hours, and gain_per_hour mutate(flights_7_columns, gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 × 10 ## year month day dep_delay arr_delay distance air_time gain hours gain_pe…¹ ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 -9 3.78 -2.38 ## 2 2013 1 1 4 20 1416 227 -16 3.78 -4.23 ## 3 2013 1 1 2 33 1089 160 -31 2.67 -11.6 ## 4 2013 1 1 -1 -18 1576 183 17 3.05 5.57 ## 5 2013 1 1 -6 -25 762 116 19 1.93 9.83 ## 6 2013 1 1 -4 12 719 150 -16 2.5 -6.4 ## 7 2013 1 1 -5 19 1065 158 -24 2.63 -9.11 ## 8 2013 1 1 -3 -14 229 53 11 0.883 12.5 ## 9 2013 1 1 -3 -8 944 140 5 2.33 2.14 ## 10 2013 1 1 -2 8 733 138 -10 2.3 -4.35 ## # … with 336,766 more rows, and abbreviated variable name ¹​gain_per_hour transmute() adds new columns based on values from existing columns. Data frame only includes new columns. # calculate and add columns for gain, hours, and gain_per_hour transmute(flights_7_columns, gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 × 3 ## gain hours gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -9 3.78 -2.38 ## 2 -16 3.78 -4.23 ## 3 -31 2.67 -11.6 ## 4 17 3.05 5.57 ## 5 19 1.93 9.83 ## 6 -16 2.5 -6.4 ## 7 -24 2.63 -9.11 ## 8 11 0.883 12.5 ## 9 5 2.33 2.14 ## 10 -10 2.3 -4.35 ## # … with 336,766 more rows 4.6.1 Useful creation functions There are many functions to use with mutate(). The function must be vectorised: it must take a vector of values as input, return a vector with the same number of values as output. Arithmetic operators: +, -, *, /, ^ aggregate functions: sum, mean Modular arithmetic: %/% (integer division) and %% (remainder) Logs: log(), log2(), log10() Offsets: lead() leading values; lag() lagging values. Cumulative and rolling aggregates: cumsum() cumulative sums, cumprod() cumulative products, cummin() cumulative min, cummax() cumulative max, cummean() cumulative means. Logical comparisons: &lt;, &lt;=, &gt;, &gt;=, !=, and == Ranking: min_rank(x) gives ranks from smallest to largest. min_rank(desc(x)) gives ranks from largest to smallest. row_number(), dense_rank(), percent_rank(), cume_dist(), ntile(). Testing out various functions to see what they do. transmute(flights, dep_time, arr_time, # Modular arithmetic dep_hour = dep_time %/% 100, dep_minute = dep_time %% 100, # Arithmetic duration = arr_time - dep_time, # logs log_duration = log2(duration), # Offsets lead_duration = lead(duration) ) ## Warning in mask$eval_all_mutate(quo): NaNs produced ## # A tibble: 336,776 × 7 ## dep_time arr_time dep_hour dep_minute duration log_duration lead_duration ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 517 830 5 17 313 8.29 317 ## 2 533 850 5 33 317 8.31 381 ## 3 542 923 5 42 381 8.57 460 ## 4 544 1004 5 44 460 8.85 258 ## 5 554 812 5 54 258 8.01 186 ## 6 554 740 5 54 186 7.54 358 ## 7 555 913 5 55 358 8.48 152 ## 8 557 709 5 57 152 7.25 281 ## 9 557 838 5 57 281 8.13 195 ## 10 558 753 5 58 195 7.61 291 ## # … with 336,766 more rows transmute(flights, dep_time, arr_time, # Arithmetic duration = arr_time - dep_time, # Cumulative aggregates cumsum_duration = cumsum(duration), # Logical comparisons long_duration = duration &gt; 300, # Ranking rank_duration = min_rank(duration) ) ## # A tibble: 336,776 × 6 ## dep_time arr_time duration cumsum_duration long_duration rank_duration ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; &lt;int&gt; ## 1 517 830 313 313 TRUE 285919 ## 2 533 850 317 630 TRUE 290078 ## 3 542 923 381 1011 TRUE 317071 ## 4 544 1004 460 1471 TRUE 325198 ## 5 554 812 258 1729 FALSE 199982 ## 6 554 740 186 1915 FALSE 114148 ## 7 555 913 358 2273 TRUE 307731 ## 8 557 709 152 2425 FALSE 77988 ## 9 557 838 281 2706 FALSE 224583 ## 10 558 753 195 2901 FALSE 129730 ## # … with 336,766 more rows "],["grouped-summaries-with-summarize.html", "4.7 Grouped summaries with summarize()", " 4.7 Grouped summaries with summarize() summarize() or summarise() collapses a data frame to a single row By default, summarize includes NA values. summarize() will return NA if any values are NA. # calculate the mean departure delay for all the flights. Include NA. summarize(flights, delay = mean(dep_delay)) ## # A tibble: 1 × 1 ## delay ## &lt;dbl&gt; ## 1 NA Need to use na.rm = TRUE to remove NA values. # calculate the mean departure delay for all the flights. Remove NA. summarize(flights, delay = mean(dep_delay, na.rm = TRUE)) ## # A tibble: 1 × 1 ## delay ## &lt;dbl&gt; ## 1 12.6 You use nrow(), filter(), and is.na() check the number of NA values for a column. # total rows in flights nrow(flights) ## [1] 336776 # [1] 336776 # rows where dep_delay is NA nrow(filter(flights, is.na(dep_delay))) ## [1] 8255 # [1] 8255 # rows where dep_delay has a value nrow(filter(flights, !is.na(dep_delay))) ## [1] 328521 # [1] 328521 Use summarize() and group_by() to calculate values for each group. # group flights by year, month and day to get daily flights by_day &lt;- group_by(flights, year, month, day) # calculate mean departure delay for each day summarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the ## `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # … with 355 more rows 4.7.1 Combining multiple operations with the pipe Use pipe %&gt;% to perform multiple operations on a data set. Do step 1, and then do step 2… pipe makes code more readable. # groyup flights by day, and then calculate mean departure delay for each day flights %&gt;% group_by(year, month, day) %&gt;% summarize(delay = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the ## `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # … with 355 more rows 4.7.2 Counts Whenever you do any aggregation, you should include a count of values n(), or a count of non-missing values sum(!is.na(x)) to check number of items per group. # get flights that were not cancelled not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) # group flights by tail number, and then calculate mean arrival delay and number of not canceled flights for each tail number delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarize( delay = mean(arr_delay, na.rm = TRUE), n = n() ) delays ## # A tibble: 4,037 × 3 ## tailnum delay n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 D942DN 31.5 4 ## 2 N0EGMQ 9.98 352 ## 3 N10156 12.7 145 ## 4 N102UW 2.94 48 ## 5 N103US -6.93 46 ## 6 N104UW 1.80 46 ## 7 N10575 20.7 269 ## 8 N105UW -0.267 45 ## 9 N107US -5.73 41 ## 10 N108UW -1.25 60 ## # … with 4,027 more rows combine dplyr with ggplot to rearrange and plot data. dplyr and rest of tidyverse uses %\\&gt;%; ggplot uses + # pick the delayed flights with more than 25 flights, and then plot the flights. delays %&gt;% filter(n &gt; 25) %&gt;% ggplot(mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) 4.7.3 Useful summary functions Many functions can be used with summarize() Measures of location: median(x) value where 50% of x is above it, and 50% is below it. Measures of spread: sd(x) standard deviation is the standard measure of spread. interquartile range IQR(x) and median absolute deviation mad(x) are good if there are outliers. Measures of rank: min(x), quantile(x, 0.25), max(x) Measures of position: first(x), nth(x, 2), last(x). Counts: n() returns the size of the current group. sum(!is.na(x)) returns the number of non-missing values. n_distinct(x) returns the number of unique values. count() is a shortcut for group_by() and summarize() to return count by group. # count the number of flights per destination not_cancelled %&gt;% group_by(dest) %&gt;% summarize(n = n()) ## # A tibble: 104 × 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ABQ 254 ## 2 ACK 264 ## 3 ALB 418 ## 4 ANC 8 ## 5 ATL 16837 ## 6 AUS 2411 ## 7 AVL 261 ## 8 BDL 412 ## 9 BGR 358 ## 10 BHM 269 ## # … with 94 more rows # count the number of flights per destination not_cancelled %&gt;% count(dest) ## # A tibble: 104 × 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ABQ 254 ## 2 ACK 264 ## 3 ALB 418 ## 4 ANC 8 ## 5 ATL 16837 ## 6 AUS 2411 ## 7 AVL 261 ## 8 BDL 412 ## 9 BGR 358 ## 10 BHM 269 ## # … with 94 more rows use sort=TRUE with count() to sort the counts # count the number of flights per destination, and sort the results not_cancelled %&gt;% count(dest, sort=TRUE) ## # A tibble: 104 × 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ATL 16837 ## 2 ORD 16566 ## 3 LAX 16026 ## 4 BOS 15022 ## 5 MCO 13967 ## 6 CLT 13674 ## 7 SFO 13173 ## 8 FLL 11897 ## 9 MIA 11593 ## 10 DCA 9111 ## # … with 94 more rows optionally provide a weight variable to get a sum of that variable. # get the total number of miles planes flew for each destination not_cancelled %&gt;% count(dest, wt = distance) ## # A tibble: 104 × 2 ## dest n ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ 463804 ## 2 ACK 52536 ## 3 ALB 59774 ## 4 ANC 26960 ## 5 ATL 12747938 ## 6 AUS 3650862 ## 7 AVL 152323 ## 8 BDL 47792 ## 9 BGR 135324 ## 10 BHM 232953 ## # … with 94 more rows When used with numeric functions, TRUE is converted to 1 and FALSE is converted to 0. sum(TRUE) # [1] 1 sum(5 &gt; 0) # [1] 1 sum(FALSE) # [1] 0 sum(5 &lt; 0) # [1] 0 Counts and proportions of logical values: sum(x) gives the number of TRUEs, and mean(x) gives the proportion of TRUEs. # number of flight per day delayed by more than an 60 minutes not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(hour_count = sum(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the ## `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day hour_count ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 60 ## 2 2013 1 2 79 ## 3 2013 1 3 51 ## 4 2013 1 4 36 ## 5 2013 1 5 25 ## 6 2013 1 6 39 ## 7 2013 1 7 31 ## 8 2013 1 8 19 ## 9 2013 1 9 18 ## 10 2013 1 10 17 ## # … with 355 more rows # proportion of flights per day delayed by more than an 60 minutes not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(hour_prop = mean(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the ## `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day hour_prop ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 0.0722 ## 2 2013 1 2 0.0851 ## 3 2013 1 3 0.0567 ## 4 2013 1 4 0.0396 ## 5 2013 1 5 0.0349 ## 6 2013 1 6 0.0470 ## 7 2013 1 7 0.0333 ## 8 2013 1 8 0.0213 ## 9 2013 1 9 0.0202 ## 10 2013 1 10 0.0183 ## # … with 355 more rows 4.7.4 Grouping by multiple variables progressively rolling up summaries for sums and counts # group flights by day daily &lt;- group_by(flights, year, month, day) # number flights per day (per_day &lt;- summarize(daily, flights = n())) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the ## `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 842 ## 2 2013 1 2 943 ## 3 2013 1 3 914 ## 4 2013 1 4 915 ## 5 2013 1 5 720 ## 6 2013 1 6 832 ## 7 2013 1 7 933 ## 8 2013 1 8 899 ## 9 2013 1 9 902 ## 10 2013 1 10 932 ## # … with 355 more rows # number flights per month (per_month &lt;- summarize(per_day, flights = sum(flights))) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the ## `.groups` argument. ## # A tibble: 12 × 3 ## # Groups: year [1] ## year month flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 27004 ## 2 2013 2 24951 ## 3 2013 3 28834 ## 4 2013 4 28330 ## 5 2013 5 28796 ## 6 2013 6 28243 ## 7 2013 7 29425 ## 8 2013 8 29327 ## 9 2013 9 27574 ## 10 2013 10 28889 ## 11 2013 11 27268 ## 12 2013 12 28135 # number of flights per year (per_year &lt;- summarize(per_month, flights = sum(flights))) ## # A tibble: 1 × 2 ## year flights ## &lt;int&gt; &lt;int&gt; ## 1 2013 336776 4.7.5 Ungrouping ungroup() removes grouping. # ungroup the daily flights to count the total number of flights daily %&gt;% ungroup() %&gt;% summarize(flights = n()) ## # A tibble: 1 × 1 ## flights ## &lt;int&gt; ## 1 336776 If during analysis the data doesn’t look right, you can try to use ungroup() to check if the data was previously grouped. "],["grouped-mutates-and-filters.html", "4.8 Grouped mutates (and filters)", " 4.8 Grouped mutates (and filters) use group() with mutate() and filter() # get the flights with the top 10 largest arrival delays per day top_delay &lt;- flights_7_columns %&gt;% group_by(year, month, day) %&gt;% filter(rank(desc(arr_delay)) &lt;= 10) top_delay ## # A tibble: 3,609 × 7 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 ## 2 2013 1 1 290 338 1134 213 ## 3 2013 1 1 260 263 266 46 ## 4 2013 1 1 155 166 277 68 ## 5 2013 1 1 157 174 213 60 ## 6 2013 1 1 216 222 708 121 ## 7 2013 1 1 255 250 589 115 ## 8 2013 1 1 285 246 1085 146 ## 9 2013 1 1 192 191 199 44 ## 10 2013 1 1 379 456 1092 222 ## # … with 3,599 more rows # add rank column, and sort the rows by day and rank to check if top_delay # is returning what we expect top_delay %&gt;% mutate(rank = rank(desc(arr_delay)) ) %&gt;% arrange(year, month, day, rank) ## # A tibble: 3,609 × 8 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time rank ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 1 ## 2 2013 1 1 379 456 1092 222 2 ## 3 2013 1 1 290 338 1134 213 3 ## 4 2013 1 1 260 263 266 46 4 ## 5 2013 1 1 255 250 589 115 5 ## 6 2013 1 1 285 246 1085 146 6 ## 7 2013 1 1 216 222 708 121 7 ## 8 2013 1 1 192 191 199 44 8 ## 9 2013 1 1 157 174 213 60 9 ## 10 2013 1 1 155 166 277 68 10 ## # … with 3,599 more rows "],["meeting-videos-3.html", "4.9 Meeting Videos", " 4.9 Meeting Videos 4.9.1 Cohort 5 Meeting chat log 00:13:48 Jon Harmon (jonthegeek): &quot;dplyr&quot; as in &quot;data plyer&quot; (tools for working with data) 00:22:03 Ryan Metcalf: I call the | as “handlebar”…may be my own lingo too. 00:22:20 lucus w: I like vbar 00:38:30 Ryan Metcalf: Quick thought, on dat ingestion, does the tidyverse convert null to NA? Or an alternative, does is.na look for null too? 00:39:19 Jon Harmon (jonthegeek): Null coming in from a database will convert to NA. NULL specifically means &quot;does not exist,&quot; and can&#39;t be inside a vector of numbers in R. It&#39;s its own data type in R. 00:39:24 lucus w: I believe NA and NULL aren’t the same thing, so I’d guess no 00:39:53 Njoki Njuki Lucy: can one use filter to remove na? 00:40:01 Ryan Metcalf: 👍🏻 00:40:45 lucus w: filter(!is.na(x)) wil do the trick 00:40:51 Jon Harmon (jonthegeek): filter(flights, !is.na(month)) would remove NA rows. 00:41:05 Jon Harmon (jonthegeek): Lucus beat me to it :D 00:42:22 Njoki Njuki Lucy: awesome, thank you both :) 00:46:06 Jon Harmon (jonthegeek): Chapter 14 has more on regular expressions. 00:47:03 Jon Harmon (jonthegeek): https://regexr.com/ 00:58:04 lucus w: I wish all aggregate functions would have na.rm = TRUE as a default 01:04:21 lucus w: is magrittr a function or just an operator 01:04:35 lucus w: %&gt;% 01:04:38 Jon Harmon (jonthegeek): If you&#39;re curious why the pipe package is called magrittr: https://en.wikipedia.org/wiki/The_Treachery_of_Images#/media/File:MagrittePipe.jpg 01:05:02 Jon Harmon (jonthegeek): magrittr is the package which exports the %&gt;% function (but it&#39;s a special kind of function because it can go in the middle of its arguments) 01:16:15 Eileen: Great presentation 01:16:17 Ryan Metcalf: Great job! 01:16:34 LG: Thank you! 01:16:46 Njoki Njuki Lucy: Thank you! 01:17:40 Eileen: Thank you! 4.9.2 Cohort 6 Meeting chat log 00:01:33 Adeyemi Olusola: good day Daniel 00:01:48 Daniel Adereti: Hello Adeyemi! 00:03:09 Adeyemi Olusola: we are experiencing loadshedding as regards electricity in SA. So, If I am unavailable at some point kindly know that its light issues 00:03:26 Daniel Adereti: Got you! 00:06:42 Daniel Adereti: Let&#39;s give people about 5 minutes to join in 00:07:21 Daniel Adereti: Also, expecting our volunteer Matthew to join a bit late 00:07:38 Shannon: Sounds good 00:07:56 Daniel Adereti: He had to reschedule a number of things due to the timezone issues (CDT vs WAT) 00:09:07 Shannon: it&#39;s a bit crackly 00:09:30 Adeyemi Olusola: yes...its getting better 00:10:29 Adeyemi Olusola: yeah 00:10:32 Shannon: much better! 00:10:45 Adeyemi Olusola: you decide 00:12:04 Shannon: yes! seeing your RStudio screen clearly 00:19:39 Vrinda Kalia: That’s my guess as well 00:21:10 Freya Watkins (she/her): maybe it&#39;s just the order, a=1, b=2 etc? I guess 00:21:25 Daniel Adereti: seems like @freya 00:21:26 Shannon: That seems right 00:21:27 Adeyemi Olusola: my guess... 00:21:36 Adeyemi Olusola: perhaps we can try z and t 00:22:56 Daniel Adereti: &#39;z&#39; &gt; &#39;t&#39; == TRUE, so it appears it is by order 00:23:10 Adeyemi Olusola: nice one 00:24:25 Adeyemi Olusola: equal to 00:24:29 Adeyemi Olusola: a = 1 00:24:40 Vrinda Kalia: on Mac: option + - 00:24:45 Freya Watkins (she/her): ALT-minus is a shortcut for on Windows 00:29:26 Adeyemi Olusola: 1 = 5 is false but the negation turns it true 00:32:00 Adeyemi Olusola: yes, we can 00:32:54 Vrinda Kalia: Sorry, I don’t see the pop-up. We see the help pane 00:33:23 Adeyemi Olusola: Yes, I was referring to the help pane, I thought he will be scrolling along the pane 00:36:01 Vrinda Kalia: flights$month 00:38:15 Shannon: I haven&#39;t seen/used the as.levels() function yet, looks like it can be useful! 00:38:57 Daniel Adereti: levels(as.factor(flights$month)) 00:39:07 Adeyemi Olusola: exactly 00:39:31 Shannon: Nice! 00:40:59 Shannon: oops, as.factor(), not as.levels() 00:41:19 Adeyemi Olusola: @Shannon exactly 00:41:44 Shannon: So many functions to learn! :) 00:44:54 Adeyemi Olusola: its filtering november 00:45:20 Adeyemi Olusola: across years 00:47:09 Adeyemi Olusola: the time is also there 00:47:43 Adeyemi Olusola: so there are many flights in one (1) day 00:52:32 Daniel Adereti: Let&#39;s aim to finish the filter() fxn lesson today, right? it ends at &quot;missing values&quot; 00:52:57 Shannon: that sounds good 00:58:50 Vrinda Kalia: That sounds good! 00:58:52 Adeyemi Olusola: Nice work!!!! 00:59:04 Adeyemi Olusola: Thanks a lot Mattew! 00:59:04 Aalekhya Reddam: That’s great! Thank you Matthew :) 00:59:05 Vrinda Kalia: thank you so much, Matthew! 00:59:23 Shannon: Thank you, Matthew! 00:59:35 Adeyemi Olusola: Bye Bye 00:59:42 Freya Watkins (she/her): Thanks Matthew! 00:59:45 Daniel Adereti: Thank you! "],["workflow-pipes.html", "Chapter 5 Workflow: Pipes", " Chapter 5 Workflow: Pipes Learning objectives: Use the %&gt;% operator to make code more readable. lhs versus rhs Recognize when not to use the %&gt;% operator. Review other pipe operators that may be helpful. "],["introduction-2.html", "5.1 Introduction", " 5.1 Introduction The pipe operator comes from the {magrittr} package by Stefan Milton Bache If you use ANY tidyverse libraries, {magrittr} is already included (how to validate this statement) For learning humans… read the %&gt;% operator as semantically: and then library(magrittr) "],["lets-see-it-in-code.html", "5.2 Lets see it in Code!!!", " 5.2 Lets see it in Code!!! The following example will highlight a code snippet without piping (Object Assignment and Nested) and with piping. a &lt;- dplyr::filter(mtcars, carb &gt; 1) b &lt;- dplyr::group_by(a, cyl) c &lt;- dplyr::summarise(b, Avg_mpg = mean(mpg)) d &lt;- dplyr::arrange(c, desc(Avg_mpg)) print(d) Above, objects a-d are created as “placeholders”. Objects that are nothing more then memory space to hold the output of a function. The difference is, each of these can be called upon in future script. One of my favorite talks: Jenny Bryant at Plotcon, 2016. Specific to the topic, start at min 15:00. The discussion is related to Dataframes and the key takeaway is wrangle your data once. But couldn’t I just nest my function? dplyr::arrange( dplyr::summarize( dplyr::group_by( dplyr::filter(mtcars, carb &gt; 1), cyl ), Avg_mpg = mean(mpg) ), desc(Avg_mpg) ) Nesting a long function is acceptable and in some languages preferred. However, given the structure of RStudio and its plethora of packages, there is no need. Using the Pipe mtcars %&gt;% dplyr::filter(carb &gt; 1) %&gt;% dplyr::group_by(cyl) %&gt;% dplyr::summarise(Avg_mpg = mean(mpg)) %&gt;% dplyr::arrange(desc(Avg_mpg)) The third example not only reduces complexity… you are building a pipeline to process the mtcars dataset. There is no difference in computation from the first example… only, now everything is in memory. NOTE: There is a section in here about pryr that I wasn’t sure the intent other then a discussion on memory use. R is intellegent and will share colums across dataframes. The material was excluded from the discussion. "],["overwritting-data-easy-right.html", "5.3 Overwritting Data… easy, right?", " 5.3 Overwritting Data… easy, right? One method of wrangling data is to just overwrite and reassign a calculation to its original object. But, there is a problem… Overwriting an object prevents clean debugging. You’ll have to rerun your code over and over to see what is changing. The repetition of the object being transformed implies… “what does my data look like now?” If you want to make yourself crazy… continually read in a new copy of your data just to walk through the process over again. This is not conducive to efficiency. "],["the-pipe-makes-lexical-transformations.html", "5.4 The pipe makes lexical transformations", " 5.4 The pipe makes lexical transformations magrittr reassembles the code in the pipe to a form that works by overwriting an intermediate object, see link This means that the pipe won’t work for two classes of functions: Functions that use the current environment. Functions that use lazy evaluation. "],["when-not-to-use-the-pipe.html", "5.5 When not to use the pipe", " 5.5 When not to use the pipe Your pipes are longer than (say) ten steps. You have multiple inputs or outputs. You are starting to think about a directed graph with a complex dependency structure. "],["other-tools-from-magrittr.html", "5.6 Other tools from magrittr", " 5.6 Other tools from magrittr Before we begin, let’s discuss lhs and rhs lhs - Left Hand Side rhs - Right Hand Side Alternative Pipes Tee pipe: %T&gt;% When working with more complex pipes, it’s sometimes useful to call a function for its side-effects Returns the left-hand side instead of the right-hand side library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract rnorm(100) %&gt;% matrix(ncol = 2) %&gt;% plot() %&gt;% str() ## NULL # Using the Tee pipe allows for seeing the data prior to plotting rnorm(100) %&gt;% matrix(ncol = 2) %T&gt;% plot() %&gt;% str() ## num [1:50, 1:2] 1.3858 0.0505 0.5169 -2.6798 -0.2826 ... Exposition pipe: %$% It explodes out the variables in a data frame so that you can refer to them explicitly # Output the correlation of `disp` to `mpg` mtcars %$% cor(disp, mpg) ## [1] -0.8475514 Assignment pipe: %&lt;&gt;% Allows you to replace code mtcars &lt;- mtcars %&gt;% transform(cyl = cyl * 2) Using the Assignment Operator %&lt;&gt;% mtcars %&lt;&gt;% transform(cyl = cyl * 2) In my opinion, a little bit of duplication (i.e. repeating the name of the object twice) is fine in return for making assignment more explicit. - Hadley Wickham "],["meeting-videos-4.html", "5.7 Meeting Videos", " 5.7 Meeting Videos 5.7.1 Cohort 5 Meeting chat log 00:12:57 Jon Harmon (jonthegeek): https://en.wikipedia.org/wiki/The_Treachery_of_Images 00:16:47 Jon Harmon (jonthegeek): https://cran.r-project.org/package=magrittr 00:20:53 Jon Harmon (jonthegeek): https://smile.amazon.com/Mathematical-Notation-Guide-Engineers-Scientists/dp/1466230525/ref=sr_1_2?keywords=Mathematical+Notation&amp;qid=1641665745&amp;sr=8-2 00:22:16 Jon Harmon (jonthegeek): |&gt; 00:23:04 Ryan Metcalf: And, is this the “Walrus” operator? `:=` 00:23:19 Jon Harmon (jonthegeek): %&gt;% 00:23:28 Jon Harmon (jonthegeek): |&gt; 00:24:14 Jon Harmon (jonthegeek): a |&gt; f() 00:24:23 Jon Harmon (jonthegeek): f(a) 00:41:01 Becki R. (she/her): Ryan, can you put a link to the video in the chat? 00:42:27 Jon Harmon (jonthegeek): a %&gt;% myfun(a = 10, b = .) 00:42:59 Jon Harmon (jonthegeek): a |&gt; myfun(a = 10, b = .) 00:43:00 Ryan Metcalf: Jenny Bryant Youtube Video: https://youtu.be/4MfUCX_KpdE 00:43:07 Becki R. (she/her): Thanks 00:44:57 Jon Harmon (jonthegeek): a %&gt;% myfun(arg1 = 10, arg2 = .) 00:45:48 Jon Harmon (jonthegeek): a %&gt;% myfun(arg2 = .) 00:47:40 Federica Gazzelloni: https://www.r-bloggers.com/2021/05/the-new-r-pipe/ 00:50:00 Jon Harmon (jonthegeek): https://twitter.com/hadleywickham/status/1359852563726819332 00:51:58 Federica Gazzelloni: https://community.rstudio.com/t/why-is-r-core-creating-a-new-pipe-operator/89020 01:03:35 Federica Gazzelloni: you can use: set.seed(123) with some numbers inside to recall the same random set 01:03:56 Federica Gazzelloni: set.seed(123) 01:04:06 Federica Gazzelloni: rnorm(100)… 01:08:46 Jon Harmon (jonthegeek): a &lt;- a %&gt;% a %&lt;&gt;% 01:10:41 Jon Harmon (jonthegeek): mtcars &lt;- head(mtcars) 01:10:50 Jon Harmon (jonthegeek): mtcars &lt;- mtcars %&gt;% head() 01:10:57 Jon Harmon (jonthegeek): mtcars %&lt;&gt;% head() 01:13:56 Becki R. (she/her): Where is the signup list for presenting chapters? 5.7.2 Cohort 6 Meeting chat log 00:09:32 Marielena Soilemezidi: = 00:26:49 Daniel Adereti: Yes, I agree. It appears the dot allows to insert any argument 00:52:38 Daniel Adereti: Thanks Marielena, also share Shannon&#39;s thoughts, pipes had always been taught like a must use operator, glad to see it is meant to be selective 00:55:20 Daniel Adereti: works for me too, it is quite a large chapter 00:55:39 Daniel Adereti: Sorry, my mic seems problematic, hence my typing "],["data-tidying.html", "Chapter 6 Data tidying", " Chapter 6 Data tidying Learning objectives: Classify datasets as tidy or non-tidy. Pivot data to make it tidy. Separate and unite columns to make them tidy. Deal with missing values in a dataset. Combine functions to tidy a dataset. Recognize reasons that non-tidy data might be preferred in some cases. "],["slide-title.html", "6.1 SLIDE TITLE", " 6.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-5.html", "6.2 Meeting Videos", " 6.2 Meeting Videos 6.2.1 Cohort 5 Meeting chat log 00:07:37 Federica Gazzelloni: Hello everyone! 00:07:53 Sandra Muroy: Hi Federica! 00:07:58 Adeyemi Olusola: hello everyon3. 00:09:56 Ryan Metcalf: Good day Cohort! 00:10:15 Sandra Muroy: Hi Adeyemi and Ryan :) 00:13:15 Becki R. (she/her): Hello! 00:13:38 Becki R. (she/her): yes 00:28:57 Keuntae Kim: punctuation mark also works for the numeric column name. 00:29:14 Keuntae Kim: table4a$`1999` 00:29:16 Keuntae Kim: I think.. 00:29:47 Keuntae Kim: you got that... haha 00:37:53 Njoki Njuki Lucy: Thank you Jon, you just answered my question :) 00:44:12 Federica Gazzelloni: thanks 00:51:17 lucus w: The new {knitr} syntax allows inline chuck options. Better yet you can use yaml styling 00:52:00 lucus w: ```{r} 00:52:39 lucus w: ```{r} #| echo:FALSE ``` 00:58:05 Ryan Metcalf: I know realize….I have an older version of the Print book versus the online version! Now I know why I was scratching my head! 00:58:13 Ryan Metcalf: “Now” 01:02:10 Keuntae Kim: Agree. reshape/reshape seem to begin deprecated even if there are still users (like me). 😀 01:02:14 Jon Harmon (jonthegeek): Yeah, I don&#39;t think they&#39;ve done a printing since pivot_* came out. 01:13:45 lucus w: Good job on going through the exercise but maybe randomly select some 01:13:57 Federica Gazzelloni: agree 01:14:53 Keuntae Kim: agree, but exercises are very interesting. they are what we usually encounter when wrangling the data in practice. 01:17:12 lucus w: Sorry folks I have to drop.. good job Sandra!! 01:20:11 Keuntae Kim: Excellent job Sandra! You really dive in the contents very deeply! 01:20:27 Ryan Metcalf: Great Job Sandra! Meeting chat log 00:11:11 Njoki Njuki Lucy: Hi everyone! 00:12:06 Becki R. (she/her): Hello! 00:14:06 Susie N: You could also just do as.numeric correct? 00:14:09 Susie N: Just not as nice 00:19:26 Jon Harmon (jonthegeek): Yup, the convert just figures out the as.* for you automatically. 00:22:11 Keuntae Kim: https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html 00:22:38 Keuntae Kim: simple intro. I used this for my text mining analysis. 00:23:56 Jon Harmon (jonthegeek): I use regexr.com a lot to test out regex quickly. 00:24:47 Keuntae Kim: Thank you for the link! 00:24:52 Federica Gazzelloni: thanks 00:50:11 Susie N: Amazing job breaking it all down! 00:50:41 Njoki Njuki Lucy: Thank you Sandra! 00:55:00 Becki R. (she/her): Thanks, Sandra! 00:55:36 Keuntae Kim: In the wide-format, it is easy to produce additional derivative variables--such as percentages? 00:56:24 Keuntae Kim: It is because, in the wide format, each row represents one single unique observation. 00:56:58 Keuntae Kim: Census data 00:57:03 Keuntae Kim: is organized in the wide format. 00:57:26 Jon Harmon (jonthegeek): Read vignettes here for cases where it makes sense to be wide: https://cran.r-project.org/web/packages/widyr/index.html 00:58:17 Federica Gazzelloni: thanks Sandra 6.2.2 Cohort 6 Meeting chat log 00:11:55 Marielena Soilemezidi: hi guys! :) 00:12:14 Adeyemi Olusola: Hello 00:12:16 Daniel Adereti: Hallo! 00:14:58 Marielena Soilemezidi: yep! 00:18:42 Daniel Adereti: The link to the paper: https://www.jstatsoft.org/article/view/v059i10 00:34:12 Daniel Adereti: why is table 2 not tidy again? 00:34:26 Marielena Soilemezidi: it mixes populations and cases 00:44:13 Marielena Soilemezidi: nope! All good :) 00:44:17 Daniel Adereti: none from me 01:12:20 Daniel Adereti: We are overtime though, maybe we conclude with Pivotwider next week? 01:13:06 Marielena Soilemezidi: thank you, Adeyemi! 01:13:06 Daniel Adereti: Fantastic class! Thanks Adeyemi! 01:13:14 Marielena Soilemezidi: great presentation :) 01:13:16 Folashade Bayode: Thank you "],["workflow-code-style.html", "Chapter 7 Workflow: code style", " Chapter 7 Workflow: code style Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-1.html", "7.1 SLIDE TITLE", " 7.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-6.html", "7.2 Meeting Videos", " 7.2 Meeting Videos 7.2.1 Cohort 7 Meeting chat log LOG 7.2.2 Cohort 8 Meeting chat log LOG "],["data-import.html", "Chapter 8 Data import", " Chapter 8 Data import Learning objectives: Read data from disk using the readr::read_*() family of functions. Compare and contrast the read_*() functions with the base R equivalents. Parse character data into other data types using the readr::parse_*() functions. List the complications that can arise when parsing numerical strings. Understand how the various character encodings can make it tricky to parse characters. Describe the common conventions used for date/time data. Diagnose problems that may arise when using the read_*() functions. Write data to disk using the readr::write_*() family of functions. "],["slide-title-2.html", "8.1 SLIDE TITLE", " 8.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-7.html", "8.2 Meeting Videos", " 8.2 Meeting Videos 8.2.1 Cohort 5 Meeting chat log 00:07:14 Njoki Njuki Lucy: Hi Becki! 00:11:14 Ryan Metcalf: Sorry team, hot spot is getting an update then will switch to computer 00:11:38 Federica Gazzelloni: Hello Ryan! 00:17:34 Jon Harmon (jonthegeek): this that another is fixed width 00:18:56 Jon Harmon (jonthegeek): this, that, another 00:21:12 lucus w: Some of the healthcare data especially in clinical trials are created using fixed width.. the datasets will usually be shipped with some kind of a data dictionary defining the amongst others, the width of each column 00:21:32 lucus w: So parsing the files will include providing each width specification 00:21:49 Sandra Muroy: oh interesting! thanks Lucus 00:21:59 Federica Gazzelloni: 👍🏻 00:22:03 Jon Harmon (jonthegeek): Now that you say that, I&#39;ve also seen that in some of the US government data shared on data.gov. 00:22:09 lucus w: Pretty popular in SAS language 00:22:33 Ryan Metcalf: Excellent statement Lucas. I was initially thinking you’d have to know the data preparation process before choosing the correct read() function. 00:24:34 lucus w: Yes.. maybe Njoki will get to it as well, but readr uses heuristic process to guess.. so it lazily just works 00:25:07 Federica Gazzelloni: This is very interesting, I supposed to use read_csv() just with files 00:28:07 Federica Gazzelloni: how can I use freed() to see the speed? 00:30:06 Jon Harmon (jonthegeek): It&#39;s fread() not freed(). It&#39;s in the data.table package. You&#39;d need a fairly large csv to notice the speed difference (and the latest version of readr is faster in some cases). 00:30:15 Federica Gazzelloni: right 00:31:52 Federica Gazzelloni: I’d like to know more about problems() 00:36:07 lucus w: Its 1,000 00:36:20 Federica Gazzelloni: thanks 00:41:45 Jon Harmon (jonthegeek): 1,000.2 00:41:52 Jon Harmon (jonthegeek): 1.000.2 00:43:12 lucus w: Oh just read everything as a text and fix them accordingly later 00:43:31 lucus w: *or 00:43:48 Jon Harmon (jonthegeek): Yeah, but sometimes fixing them can be painful. 00:44:17 lucus w: True 00:50:56 Jon Harmon (jonthegeek): &quot;you tee eff eight&quot; 00:58:15 Jon Harmon (jonthegeek): &gt; x2 &lt;- &quot;\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd&quot; &gt; parse_character(x2, locale = locale(encoding = &quot;Shift-JIS&quot;)) [1] &quot;こんにちは&quot; 00:58:37 Becki R. (she/her): japanese 01:02:28 lucus w: That’s probably a best way of putting it Ryan 01:05:15 Jon Harmon (jonthegeek): From Wikipedia: &quot;The objective of a heuristic is to produce a solution in a reasonable time frame that is good enough for solving the problem at hand. This solution may not be the best of all the solutions to this problem, or it may simply approximate the exact solution. But it is still valuable because finding it does not require a prohibitively long time.&quot; 01:05:44 Shamsuddeen Muhammad: Like the def 01:05:45 Sandra Muroy: thanks Jon! 01:12:53 Becki R. (she/her): I need to get going. See you all next week! 01:13:14 Jon Harmon (jonthegeek): We&#39;ll stop after this section! 01:13:40 lucus w: date_names_langs() 01:14:12 lucus w: So for Swahili it will be locale(“sw”) 01:15:08 Ryan Metcalf: Outstanding job Lucy! Thank you everyone! Meeting chat log 00:04:46 Federica G. (she/her): Hello! 00:05:19 Becki R. (she/her): Hello! 00:06:09 Becki R. (she/her): Yes! 00:06:39 Becki R. (she/her): I&#39;m fine with starting 00:06:40 Federica G. (she/her): shall we wait until 5 past? 00:06:43 Susie: Good idea 00:06:48 Becki R. (she/her): 5 past also sounds god 00:06:50 Becki R. (she/her): good 00:08:17 Becki R. (she/her): How far did you all get last week? 00:09:07 Becki R. (she/her): thanks 00:39:13 Becki R. (she/her): It&#39;s a bit muffled 00:41:06 Ryan Metcalf: https://blog.revolutionanalytics.com/2016/05/feather-package.html 00:41:50 Shamsuddeen Muhammad: https://github.com/wesm/feather 00:41:52 Ryan Metcalf: Not direct answer. It appears the feather project “o create a standard data file format that can be used for data exchange by and between R, Python, and any other software that implements its open-source format&quot; 00:43:58 Shamsuddeen Muhammad: @Ryan that’s right. Also, speed is one of the concern. 00:48:20 Shamsuddeen Muhammad: A good package I used also readtext: https://github.com/quanteda/readtext 00:50:25 Becki R. (she/her): do you have a link to the import function information? 00:51:20 Federica G. (she/her): you need to right click the file name and it appears 00:52:04 Sandra Muroy: it&#39;s also located in the Environment tab 00:52:05 Federica G. (she/her): the file name in the file pane 00:52:33 Becki R. (she/her): Ah, thanks. 01:13:11 Ryan Metcalf: From parse_date(): Month: &quot;%m&quot; (2 digits), &quot;%b&quot; (abbreviated name in current locale), &quot;%B&quot; (full name in current locale). 01:18:25 Ryan Metcalf: readr() CRAN link: https://cran.r-project.org/web/packages/readr/readr.pdf 01:21:10 Federica G. (she/her): here are the date formats: https://www.r-bloggers.com/2013/08/date-formats-in-r/ 01:22:10 Federica G. (she/her): at the bottom of the blog you find the codification 01:22:29 Sandra Muroy: great! thank you Ryan and Federica 01:26:56 Njoki Njuki Lucy: exercises: https://jrnold.github.io/r4ds-exercise-solutions/data-import.html 01:27:06 Njoki Njuki Lucy: course book: https://r4ds.had.co.nz/data-import.html 01:27:36 Federica G. (she/her): thanks 01:27:39 Becki R. (she/her): thank you! 8.2.2 Cohort 6 Meeting chat log 00:04:29 Adeyemi Olusola: Hello Daniel. Happy New Year 00:04:35 Adeyemi Olusola: !!! 00:04:41 Daniel Adereti: Happy new year, chief! 00:05:07 Daniel Adereti: Let&#39;s give folks some 5 mins to join since it is early in the year 00:05:15 Adeyemi Olusola: Okay. 00:06:14 Daniel Adereti: Hello Freya! 00:08:29 Freya Watkins (she/her): Hi and happy new year :) 00:08:57 Shannon: Happy new year! 00:09:02 Daniel Adereti: Happy new year Freya. Hello Shannon! 00:09:22 Adeyemi Olusola: HI all. HNY! 00:41:09 Shannon: I haven&#39;t used read_fwf() 00:41:43 Daniel Adereti: Found this short article on fixed width files: https://www.techwalla.com/articles/what-is-a-delimited-a-fixed-width-file 00:42:03 Shannon: Thanks, Daniel 00:43:16 Daniel Adereti: The solutions book: https://jrnold.github.io/r4ds-exercise-solutions/data-import.html 00:43:41 Freya Watkins (she/her): No 01:05:12 Daniel Adereti: Hello Adeyemi, can you please share the Rmarkdown file you just used? 01:07:46 Shannon: Thank you, Adeyemi, great lesson 01:07:53 Freya Watkins (she/her): Thanks! 01:07:58 Daniel Adereti: Thank you Adeyemi! 01:07:59 Adeyemi Olusola: Thank you "],["workflow-scripts-and-projects.html", "Chapter 9 Workflow: scripts and projects", " Chapter 9 Workflow: scripts and projects Learning objectives: Use keyboard shortcuts to use the RStudio script pane efficiently. Understand the script diagnostics that the RStudio script editor provides. Understand how to use Rstudio and the getwd() function to find your working directory. Recognize the similarities and differences between Windows paths and Mac/Linux paths. Create an Rstudio project. "],["slide-title-3.html", "9.1 SLIDE TITLE", " 9.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-8.html", "9.2 Meeting Videos", " 9.2 Meeting Videos 9.2.1 Cohort 5 Meeting chat log 00:40:51 Becki R. (she/her): It works both ways, I think. It&#39;s just convention to use &lt;-. 00:45:11 Wai-Yin: You can use &lt;- or = for assignment. &lt;- is the convention in R. -&gt; results in ab error. 00:58:59 lucus w: https://www.rocker-project.org/ 01:01:43 Bruno A. Machado: tks Lucus for the link 👍 01:13:48 Susie N.: I have to head out! Thank you Ryan for the great breakdown 01:14:07 Federica Gazzelloni: Thanks! 01:14:19 Becki R. (she/her): Thanks everyone, see you next week! 01:17:04 Bruno A. Machado: tks team 01:17:21 Eileen Murphy: Thank you Ryan Meeting chat log 00:05:55 docksbox@pm.me: Hello! 00:07:40 Becki R. (she/her): Hello! 00:07:52 Sandra Muroy: Hi! 00:07:57 Federica Gazzelloni: Hi! 00:09:49 Eileen: Hello! 00:15:44 Becki R. (she/her): Very cool! 00:29:31 Jon Harmon (jonthegeek): https://CRAN.R-project.org/package=renv 00:31:35 lucus w: Or just here::here() package, it’s my favorite 00:32:48 Ryan Metcalf: Ah, Thank you Lucas! I think you may have solved an error I was trying to overcome! 00:32:57 Jon Harmon (jonthegeek): here::here(&quot;my_dir&quot;, &quot;myfile.R&quot;) 00:33:06 lucus w: There you go, yup 00:34:37 Jon Harmon (jonthegeek): usethis 00:34:38 lucus w: You can use usethis 00:37:56 Jon Harmon (jonthegeek): .Last.value 00:38:58 lucus w: It’s a life saver especially working in databases 00:44:32 Federica Gazzelloni: reticulate 00:45:11 Federica Gazzelloni: https://rstudio.github.io/reticulate/articles/r_markdown.html 00:48:18 Ryan Metcalf: @Shamsuddeen, what was that command again? Cmd + Shift + P? 00:48:40 Susan Neilson: That’s right 00:49:43 Ryan Metcalf: Awesome! Ive never used that before. These bookclub meetups are so helpful! Thank you everyone! 00:50:04 Federica Gazzelloni: yep! very useful 00:50:09 Shamsuddeen Muhammad: https://speakerdeck.com/jennybc/how-to-name-files 00:50:28 Shamsuddeen Muhammad: Naming things 00:51:10 Jon Harmon (jonthegeek): 20210904 00:51:55 Shamsuddeen Muhammad: Chapter 2 Project-oriented workflow : https://rstats.wtf/project-oriented-workflow.html 00:52:13 Jon Harmon (jonthegeek): Had to google that tab: https://bookdown.org/ndphillips/YaRrr/ 00:52:15 Shamsuddeen Muhammad: What They Forgot to Teach You About R 00:55:05 Jon Harmon (jonthegeek): https://github.com/MonkmanMH/EIKIFJB 00:55:38 Ryan Metcalf: Transmute I think….. 00:56:27 Jon Harmon (jonthegeek): tidyr::replace_na() 00:56:54 lucus w: Check out janitor 01:02:32 Shamsuddeen Muhammad: https://tidyr.tidyverse.org/reference/replace_na.html 01:02:42 Shamsuddeen Muhammad: df %&gt;% dplyr::mutate(x = replace_na(x, 0)) 01:03:30 Jon Harmon (jonthegeek): &quot;&quot; 01:04:16 Ryan Metcalf: You’ve discovered the beauty of a programmer!!! 01:04:28 Shamsuddeen Muhammad: Yes Yes !!! 01:05:22 Susan Neilson: “95% of being a programmer is knowing how to Google” - my programmer friend 01:06:27 Ryan Metcalf: I find googling the package and then reading the PDF Manual. CRAN is your friend. 01:10:38 Sandra Muroy: thanks everyone for your input! 01:10:57 Ryan Metcalf: Thank you Susie! Great presentation and conversation! 01:11:04 Susan Neilson: Thanks everyone ! 01:11:08 Federica Gazzelloni: thanks 01:11:12 Becki R. (she/her): Thank you! 01:11:22 Susan Neilson: https://bookdown.org/ndphillips/YaRrr/rdata-files.html 9.2.2 Cohort 6 Meeting chat log 00:09:22 Matthew Efoli: good evening 00:09:29 Matthew Efoli: good day 00:09:35 Vrinda Kalia: Hello! 00:09:55 Daniel Adereti: Hello! 00:10:04 Shannon: Hello! 00:10:06 Daniel Adereti: ready when you are, Matthew 00:11:40 Adeyemi Olusola: Good evening everyone 00:28:31 Daniel Adereti: will it be possible to sort in ascending order as well? 00:30:39 Adeyemi Olusola: sort() should do trick 00:31:13 Adeyemi Olusola: I have issues with my audio 00:31:39 Adeyemi Olusola: lets try sort = () 00:32:07 Vrinda Kalia: I am not sure about using sort within the count function. I am only aware of using the desc argument in the sort() function 00:33:06 Daniel Adereti: it seems the sort() has its own arguments 00:33:41 Aalekhya Reddam: Sorry everyone, I have to head out but will watch the recording. See you all next week! 00:34:33 Shannon: not_cancelled %&gt;% 00:34:45 Shannon: oops sorry, didn&#39;t finish that... 00:36:00 Adeyemi Olusola: not_cancelled%&gt;% 00:36:05 Adeyemi Olusola: desc() 00:37:46 Daniel Adereti: maybe we continue and figure it out next time? 00:37:53 Daniel Adereti: sorry for chopping your flow! 00:38:27 Esmeralda Cruz: maybe arrange function? 00:38:58 Esmeralda Cruz: ok 00:44:31 Daniel Adereti: thanks for that shortcut 00:50:23 Daniel Adereti: Please explain &quot;filter(rank(desc(arr_delay)) &lt;= 10&quot; 00:55:38 Daniel Adereti: Thanks! noticed the same too, the descending argument does not seem to have any effect 00:56:31 Daniel Adereti: sure! 00:56:35 Daniel Adereti: thanks 00:58:00 Shannon: oh, because we didn&#39;t have a rank column in the first example? 00:59:24 Daniel Adereti: like a rank column as part of the dataset? 01:02:11 Daniel Adereti: Thanks! 01:04:01 Shannon: yes 01:10:42 Vrinda Kalia: I need to leave for a meeting. Thank you so much for leading a great discussion, Matthew! 01:11:00 Shannon: Thanks, Matthew! I liked the way you presented with both the bookdown file as well as RStudio. 01:11:09 Daniel Adereti: Thanks Matthew! 01:11:14 Maria Eleni Soilemezidi: Thank you for the presentation! That was very helpful! :) 01:11:15 Matthew Efoli: Thanks 01:11:37 Maria Eleni Soilemezidi: See you next week! 01:11:50 Esmeralda Cruz: Thank you :) for your time Matthew 01:12:05 Esmeralda Cruz: yes, both are correct Meeting chat log 00:01:19 Adeyemi Olusola: Good day everyone 00:01:32 Daniel: Hello! 00:17:42 Esmeralda Cruz: nop 00:33:45 Daniel: https://jrnold.github.io/r4ds-exercise-solutions/tibbles.html 00:44:48 Esmeralda Cruz: interesting 00:46:11 Esmeralda Cruz: ok, make sense 00:49:45 Esmeralda Cruz: ok "],["exploratory-data-analysis.html", "Chapter 10 Exploratory Data Analysis ", " Chapter 10 Exploratory Data Analysis "],["learning-objectives.html", "10.1 Learning objectives", " 10.1 Learning objectives Recognize the two types of questions that will always be useful for making discoveries within your data: “What type of variation occurs within my variables?” and “What type of covariation occurs between my variables?” Explore the variation within the variables of your observations. Deal with outliers and missing values in your data. Explore the covariation between the variables of your observations. Recognize how models can be used to explore patterns in your data. "],["overall-vocabulary.html", "10.2 Overall Vocabulary", " 10.2 Overall Vocabulary variable: a quantity, quality, or property that you can measure. value: the state of a variable when you measure it. Can change. observation: a set of measurements made under similar conditions. One value per variable. tabular data: observations of variables. tidy data: 1 observation per row, 1 variable per column, 1 value per cell. Definition of “tidy” for a dataset can depend on what you’re trying to answer. "],["variation.html", "10.3 Variation", " 10.3 Variation variation: the tendency of values of a variable to change between measurements. categorical variable: can only take certain values. Visualize variation with bar chart. ggplot(data = diamonds) + aes(x = cut) + geom_bar() continuous variables: can take on infinite set of ordered values. Visualize variation with histogram. ggplot(data = diamonds) + aes(x = carat) + geom_histogram(binwidth = 0.5) geom_freqpoly is geom_histogram alternative that doesn’t show bars. Reminder: the %&gt;% pipe = “and then”. {ggplot2} uses + to add layers, read it as “with” or “and”. smaller &lt;- diamonds %&gt;% filter(carat &lt; 3) ggplot(smaller) + aes(x = carat, colour = cut) + geom_freqpoly(binwidth = 0.1) Use the visualizations to develop questions! Which values are the most common? Why? Which values are rare? Why? Does that match your expectations? Can you see any unusual patterns? What might explain them? ggplot(smaller, mapping = aes(x = carat)) + geom_histogram(binwidth = 0.01) Subgroups create more questions: How are the observations within each cluster similar to each other? How are the observations in separate clusters different from each other? How can you explain or describe the clusters? Why might the appearance of clusters be misleading? Use coord_cartesian to zoom in to see unusual values. Can be ok to drop weird values, especially if you can explain where they came from. Always disclose that you did that, though. "],["missing-values-1.html", "10.4 Missing values", " 10.4 Missing values 2 options to deal with weird values: Drop the entire row. &lt;– probably don’t do this Replace bad data with NA. diamonds2 &lt;- diamonds %&gt;% mutate(y = ifelse(y &lt; 3 | y &gt; 20, NA, y)) {ggplot2} will give a warning when values are missing, can suppress with na.rm = TRUE. "],["covariation.html", "10.5 Covariation", " 10.5 Covariation covariation: tendency of values of different variables to vary together in a related way. Visualizing covariance depends on types of variables in the pair: 10.5.1 categorical + continuous x = categorical y = continuous. geom_boxplot Lots of options exist to do this better. See Cedric Scherer’s tutorial! 10.5.2 categorical + categorical geom_count dplyr::count then geom_tile 10.5.3 continuous + continuous geom_point geom_bin2d geom_hex "],["finding-patterns.html", "10.6 Finding Patterns", " 10.6 Finding Patterns Ask yourself: Could this pattern be due to coincidence (i.e. random chance)? How can you describe the relationship implied by the pattern? How strong is the relationship implied by the pattern? What other variables might affect the relationship? Does the relationship change if you look at individual subgroups of the data? "],["simplified-ggplot2.html", "10.7 Simplified ggplot2", " 10.7 Simplified ggplot2 ggplot(data = faithful, mapping = aes(x = eruptions)) + geom_freqpoly(binwidth = 0.25) ggplot(faithful, aes(eruptions)) + geom_freqpoly(binwidth = 0.25) # Or Jon&#39;s crazy way ggplot(faithful) + aes(eruptions) + geom_freqpoly(binwidth = 0.25) "],["learning-more.html", "10.8 Learning More", " 10.8 Learning More r4ds.io/join for more book clubs! R Graph Gallery The Graphs section of the R Cookbook "],["meeting-videos-9.html", "10.9 Meeting Videos", " 10.9 Meeting Videos 10.9.1 Cohort 5 Meeting chat log 00:13:43 Njoki Njuki Lucy: Is it best to visualize the variation in a categorical variable with only two levels using a bar chart? If not, what&#39;s the chart to use if I may ask? 00:16:00 Ryan Metcalf: Great question Njoki, Categorical, by definition is a set that a variable can have. Say, Male / Female / Other. This example indicates a variable can have three states. It depends on your data set. 00:16:51 Eileen: bar or pie chart? 00:16:51 Ryan Metcalf: There are other forms of presentation other than a bar chart. I.E “quantifying” each category. 00:18:37 Eileen: box chart 00:18:46 Njoki Njuki Lucy: thank you so much everyone :) 00:24:31 lucus w: This website is excellent in determining geom to use: www.data-to-viz.com 00:25:22 Njoki Njuki Lucy: awesome, thanks 00:25:44 Eileen: Box charts are great for showing outliers 00:26:31 Federica Gazzelloni: other interesting resources: 00:26:34 Federica Gazzelloni: https://www.r-graph-gallery.com/ggplot2-package.html 00:26:51 Federica Gazzelloni: http://www.cookbook-r.com/Graphs/ 00:34:19 Amitrajit: what is the difference in putting aes() inside geom_count() rather than main ggplot() call? 00:35:38 Ryan Metcalf: Like maybe Supply vs Demand curves? 00:41:16 Federica Gazzelloni: what about the factor() that we add to a variable when we apply a color? 00:42:33 Susie Neilson: I do aes your way Jon! 00:43:07 Federica Gazzelloni: and grouping inside the aes 00:49:27 Amitrajit: thanks! 00:49:32 Federica Gazzelloni: thanks 00:49:35 Njoki Njuki Lucy: thank you, bye 00:49:45 Eileen: Thank you! 10.9.2 Cohort 6 Meeting chat log 00:06:21 Matthew Efoli: good evening Daniel and Esmeralda 00:07:39 Matthew Efoli: hello everyone 00:08:08 Daniel Adereti: Hello Matthew! 00:08:44 Daniel Adereti: I guess we can start? so we can finish the 2 chapters as Exploratory Data Analysis is quite long and involved 00:09:04 Freya Watkins: Sounds good! Hi all :) 00:10:55 Freya Watkins: yes can see 00:23:14 Daniel Adereti: na &gt; Not available 00:23:32 Maria Eleni Soilemezidi: rm = remove 00:25:49 Esmeralda Cruz: yes 00:26:29 Esmeralda Cruz: to remove the outliers maybe? 00:29:20 Adeyemi Olusola: No 00:29:22 Freya Watkins: we can&#39;t see it no 00:29:27 Maria Eleni Soilemezidi: no we can&#39;t see it! 00:29:38 Maria Eleni Soilemezidi: thank you! Yes 00:32:57 Daniel Adereti: Cedric&#39;s article is a nice one! Helpful to understand descriptive use case of different plot ideas 00:43:19 Daniel Adereti: we can do the exercises 00:43:27 Esmeralda Cruz: ok 00:43:28 Maria Eleni Soilemezidi: yes, sure! 00:45:20 Adeyemi Olusola: we can try reorder 00:45:28 Adeyemi Olusola: from the previous example 00:51:44 Maria Eleni Soilemezidi: that&#39;s a good idea 00:52:28 Daniel Adereti: Thanks! 00:52:42 Daniel Adereti: cut_in_color_graph &lt;- diamonds %&gt;% group_by(color, cut) %&gt;% summarise(n = n()) %&gt;% mutate(proportion_cut_in_color = n/sum(n)) %&gt;% ggplot(aes(x = color, y = cut))+ geom_tile(aes(fill = proportion_cut_in_color))+ labs(fill = &quot;proportion\\ncut in color&quot;) 00:53:32 Esmeralda Cruz: 😮 00:53:47 Adeyemi Olusola: smiles 00:54:13 Adeyemi Olusola: but lets try reorder...I think we should be able to pull something from it, though not sure about the heatmap thingy 00:54:26 Adeyemi Olusola: on our own though* 01:05:38 Maria Eleni Soilemezidi: no worries! Thank you for the presentation, Matthew! :) 01:05:39 Freya Watkins: Thanks Matthew! 01:06:44 Maria Eleni Soilemezidi: bye everyone, see you next week! "],["workflow-getting-help.html", "Chapter 11 Workflow: getting help", " Chapter 11 Workflow: getting help Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-4.html", "11.1 SLIDE TITLE", " 11.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-10.html", "11.2 Meeting Videos", " 11.2 Meeting Videos 11.2.1 Cohort 7 Meeting chat log LOG 11.2.2 Cohort 8 Meeting chat log LOG Understand how data transformation fits into the typical data science project. "],["logical-vectors.html", "Chapter 12 Logical vectors", " Chapter 12 Logical vectors Note: Since these slides were made, this chapter has been split into multiple chapters. After you edit these slides, remove this note. Learning objectives: Compare and contrast atomic vectors and lists. Recognize the six types of atomic vectors. Determine the key properties (typeof and length) of vectors. Recognize the three important types of augmented vectors. Construct logical vectors. Construct numeric vectors. Differentiate between the two types of numeric vectors, double and integer. Construct character vectors. Recognize the different types of missing values. Coerce vectors between different types. Test whether a vector has a given type. Recognize when a vector will be recycled to match the length of another vector, and when it will not. Name the elements of vectors. Subset vectors. Construct lists. Differentiate between [, [[, and $ for subsetting lists. Use attributes to provide additional information about vectors. Recognize the S3 object-oriented system. Construct factors. Construct dates and date-times. Recognize that tibbles are augmented lists. "],["introduction-3.html", "12.1 Introduction", " 12.1 Introduction Since we have already learnt about tibbles, in this chapter we will study vectors that underlie them. 12.1.1 Prerequisites Here we focus on base R data structures, hence no need to load any packages. But we will a couple of functions from purrr package to avoid some inconsistencies in base R. library(tidyverse) "],["vector-basics.html", "12.2 Vector basics", " 12.2 Vector basics There are two types of vectors: Atomic vectors, of which there are six types: logical integer double character complex raw Integer and double vectors are collectively called numeric vectors. Lists, at times, are called recursive vectors because lists can contain other lists. The main difference between vectors and lists: Atomic vectors are homogeneous i.e., contain only one type (in my understanding). Lists are heterogeneous i.e., can have different types. Another related object: NULL. It is often used to represent the absence of a vector (unlike NA which is used to represent the absence of a value). NULL typically acts as a vector of length 0. Figure 20.1: The hierarchy of R’s vector types: Two key properties for each vector: Its type, which can be determined with typeof(). typeof(letters) typeof(1:10) Its length, which can be determined with length(). x1 &lt;- list(&quot;a&quot;, &quot;b&quot;, 1:10); length(x1) x2 &lt;- c(&quot;a&quot;, &quot;b&quot;); length(x2) Qn: does this imply that the length of a list is the # of elements in a list for example (x1)? Vectors can also contain arbitrary additional metadata in the form of attributes. Which are then used to create augmented vectors which build on additional behaviour. There are three important types of augmented vectors: Factors are built on top of integer vectors. Dates and date-times are built on top of numeric vectors. Data frames and tibbles are built on top of lists. "],["important-types-of-atomic-vector.html", "12.3 Important types of atomic vector", " 12.3 Important types of atomic vector The four most important types of atomic vectors: logical, integer, double, and character. Note: Raw and complex are rarely used during a data analysis, hence not part of this of discussion. 12.3.1 Logical Simplest type of atomic vector –&gt; can take only three possible values: FALSE, TRUE, and NA. They are constructed with comparison operators. OR, can create them by hand with c(): 1:10 %% 3 == 0 c(TRUE, TRUE, FALSE, NA) Qn: what exactly is %% doing here? I understand is x modulus y… 12.3.2 Numeric As learnt, integer and double are known collectively as numeric vectors. In R, numbers are doubles by default. To create an integer, place L after the number. typeof(1) typeof(1L) 1.5L Note: the warning after running 1.5L is because that integers only take whole numbers. I think. Two important differences between doubles and integers: Doubles are approximations. They represent floating point numbers that can’t be precisely represented with a fixed amount of memory. Therefore, we should consider all doubles as approximations. E.g., the square root of two: (x3 &lt;- sqrt(2) ^ 2) options(scipen = 999) x3 - 2 Side note: options(scipen = 999) to remove the scientific numbers as I often confuse reading e- or e+. When working with floating point numbers, it is common that the calculations include some approximation. Hence, when we compare floating point numbers we should use dplyr::near() instead of == as it allows for some numerical tolerance. (what does this mean?) dplyr::near(1.745, 2) # compares if 1.745 is the same as 2 # FALSE Integers have one special value: NA while doubles have four: NA, NaN, Inf and -Inf. NaN, Inf and -Inf can arise during division: c(-1, 0, 1) / 0 To check for these special values, let’s use the helper functions is.finite(), is.infinite(), and is.nan() instead of using ==. is.finite(c(-1, 0, 1) / 0) is.infinite(c(-1, 0, 1) / 0) is.na(c(-1, 0, 1) / 0) is.nan(c(-1, 0, 1) / 0) 12.3.3 Character Most complex atomic vector because each element of a character vector is a string, and a string contains an arbitrary amount of data. R uses a global string pool. Implying that each unique string is only stored in memory once. And every use of the string points to that representation. This reduces the amount of memory needed by duplicated strings. To see this, let’s use pryr::object_size(): x &lt;- &quot;This is a reasonably long string.&quot; pryr::object_size(x) y &lt;- rep(x, 1000) pryr::object_size(y) y doesn’t take up 1,000x as much memory as x, because each element of y is just a pointer to that same string. A pointer is 8 bytes, so 1000 pointers to a 152 B string is 8 * 1000 + 152 = 8.14 kB. 12.3.4 Missing values Each atomic vector has its own missing value: NA # logical NA_integer_ # integer NA_real_ # double NA_character_ # character But we don’t need to know about these different types since we can always use NA and it’ll be converted to the correct type using the implicit coercion rules. However, there are some functions that are strict about their inputs, so it’s useful to have this knowledge sitting in your back pocket so you can be specific when needed. 12.3.5 Exercises Describe the difference between is.finite(x) and !is.infinite(x). (x &lt;- c(-1/0, 0/0, 1/0, 5, 5L, NA)) is.finite(x) is.infinite(x) !is.infinite(x) is.finite() function does consider non-missing numeric values to be finite, and -Inf, NaN, Inf are considered not to be finite. is.infinite() considers only -Inf and Inf as infinite. Hence, !is.infinite() considers -Inf and Inf to be finite while non-missing numeric values, NaN, and NA not to be infinite. Read the source code for dplyr::near() (Hint: to see the source code, drop the ()). How does it work? dplyr::near() It doesn’t check equality as I first thought, but it checks if two numbers are within a certain tolerance (tol), usually given as .Machine$double.eps^0.5, which is the smallest floating point number that the computer can represent. (Good to know!!) A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research. help(integer) help(double) For integers vectors, R uses a 32-bit representation. I.e., it can represent \\(2^{32}\\) different values with the integers. But one of these values is set aside for NA_integer_. .Machine$integer.max .Machine$integer.max + 1L The range of integers values represented in R is \\(+- 2^{31}-1\\). Hence, the maximum integer is \\(2^{31}-1\\) instead of \\(2^{32}\\) because 1 bit is used to represent the sign \\((+ -)\\) and one value is to represent \\(NA_integer_\\). An integer greater than that value, R will return NA values. For double vectors, R uses a 64-bit representation, i.e., they can hold up to \\(2^{64}\\) values. But, some of those values are assigned to special values: -Inf, Inf, NA_real_, and NaN. .Machine$double.xmax Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise. The difference between conversion of a double to an integer differs in how they deal with the fractional part of the double. Round down, towards \\(-\\infty\\) i.e., taking the floor of a number –&gt; floor(). Round up, towards \\(\\infty\\) i.e., taking the ceiling of a number –&gt; ceiling(). Round towards zero –&gt; trunc() and as.integer(). Round away from zero. Round to the nearest integer. If ties exists, then numbers are defined with a fractional part of 0.5? Round half down, towards \\(-\\infty\\). Round half up, towards \\(\\infty\\) Round half towards zero Round half away from zero Round half towards the even integer –&gt; round(). Round half towards the odd integer. tibble( x = c(1.8, 1.5, 1.2, 0.8, 0.5, 0.2, -0.2, -0.5, -0.8, -1.2, -1.5, -1.8), `Round down` = floor(x), `Round up` = ceiling(x), `Round towards zero` = trunc(x), `Nearest, round half to even` = round(x) # 0.5 is rounded to 0 ) What functions from the readr package allow you to turn a string into logical, integer, and double vector? parse_logical() parses logical values, which can appear as variations of TRUE/FALSE or 1/0. parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;1&quot;, &quot;0&quot;, &quot;true&quot;, &quot;t&quot;, &quot;NA&quot;)) parse_integer() parses integer values. parse_integer(c(&quot;1235&quot;, &quot;0134&quot;, &quot;NA&quot;)) In case of any non-numeric characters in the string such as commas, decimals, parse_integer() will throw an error unlike parse_numeric() which ignores all the non-numeric characters before or after the first number. parse_integer(c(&quot;1000&quot;, &quot;$1,000&quot;, &quot;10.00&quot;)) parse_number(c(&quot;1.0&quot;, &quot;3.5&quot;, &quot;$1,000.00&quot;, &quot;NA&quot;, &quot;ABCD12234.90&quot;, &quot;1234ABC&quot;, &quot;A123B&quot;, &quot;A1B2C&quot;)) "],["using-atomic-vectors.html", "12.4 Using atomic vectors", " 12.4 Using atomic vectors Let’s review some of the important tools for working with the different types of atomic vectors: How to convert from one type to another, and when that happens automatically. How to tell if an object is a specific type of vector. What happens when you work with vectors of different lengths. How to name the elements of a vector. How to pull out elements of interest. 12.4.1 Coercion We can coerce or convert one type of vector to another in two ways: Explicit coercion -&gt; call a function like as.logical(), as.integer(), as.double(), or as.character(). Before doing this, check the type of the vector. For example, you may need to tweak your readr col_types specification. Implicit coercion -&gt; use a vector in a specific context that expects a certain type of vector. For example, using a logical vector with a numeric summary function or using a double vector where an integer vector is expected. Our focus here will be implicit coercion as explicit coercion is relatively rarely used in data analysis plus easy to understand. An important type of implicit coercion: using a logical vector in a numeric context. TRUE is converted to 1 and FALSE is converted to 0. Hence, summing the logical vector is the # of trues and the mean of a logical vector is the proportion of trues. x &lt;- sample(20, 100, replace = TRUE) y &lt;- x &gt; 10 sum(y) # how many are greater than 10? mean(y) # what proportion are greater than 10? Or, some code that relies on implicit coercion in the opposite direction, from integer to logical: if (length(x)) { # do something } Here, 0 is converted to FALSE and everything else is converted to TRUE. For easier understanding of the code, let’s be explicit: length(x) &gt; 0. NOTE1: When we create a vector containing multiple types with c(): the most complex type always wins. –&gt; Aha moment! typeof(c(TRUE, 1L)) #integer wins typeof(c(1L, 1.5)) #double wins #why? Thinking here, because integer is created from a double? typeof(c(1.5, &quot;a&quot;)) #character wins NOTE2: An atomic vector can not only have a mix of different types since the type is a property of the complete vector, not the individual elements. For a mix of multiple types in the same vector, use a list. 12.4.2 Test functions Suppose we want to have different things based on the type of vector: One option is to use typeof(). Or, use a test function which returns a TRUE or FALSE. Not recommended: base R functions -&gt; is.vector() and is.atomic(). Instead let’s use the is_* functions provided by purrr , summarised below. 12.4.3 Scalars and recycling rules Not only does R implicitly coerce the types of vectors to be compatible, but it also implicitly coerce the length of vectors. This is called vector recycling because the shorter vector is repeated (or recycled) to the same length as the longer vector. Mostly useful when we are mixing vectors and “scalars”. Note, R doesn’t have scalars instead, a single number is a vector of length 1. Since there are no scalars, most built-in functions are vectorised meaning that they will operate on a vector of numbers. Hence, such a code will work: sample(10) + 100 runif(10) &gt; 0.5 What happens if we add two vectors of different lengths? 1:10 + 1:2 R expands the shortest vector to the same length as the longest –&gt; recycling. But what if the length of the longer is not an integer multiple of the length of the shorter: 1:10 + 1:3 Vector recycling can silently conceal the problem, hence, the vectorised functions in tidyverse will throw errors when recycling anything other than a scalar. We can use rep() to do recycling ourselves. tibble(x = 1:4, y = 1:2) tibble(x = 1:4, y = rep(1:2, 2)) tibble(x = 1:4, y = rep(1:2, each = 2)) 12.4.4 Naming vectors We can name all types of vectors during creation with c(): c(x = 1, y = 2, z = 4) Or, with purrr::set_names(): set_names(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) Why name vectors? Because are useful in subsetting. 12.4.5 Subsetting To filter vectors, we use the subsetting function -&gt; [ and is called like x[a].There are four types of things that you can subset a vector with: A numeric vector containing only integers, and these must either be all positive, all negative, or zero. Subsetting with positive integers keeps the elements at those positions: x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;) x[c(3, 2, 5)] If we repeat a position, we can actually make a longer output than input: x[c(1, 1, 5, 5, 5, 2)] Negative values drop the elements at the specified positions: x[c(-1, -3, -5)] It’s an error to mix positive and negative values: x[c(1, -1)] The error message mentions subsetting with zero, which returns no values: x[0] This is useful if we want to create unusual data structures to functions with. (Jon, please expound!) Subsetting with a logical vector keeps all values corresponding to a TRUE value; often useful in conjunction with the comparison functions. x &lt;- c(10, 3, NA, 5, 8, 1, NA) # All non-missing values of x x[!is.na(x)] # All even (or missing!) values of x x[x %% 2 == 0] If you have a named vector, you can subset it with a character vector: x &lt;- c(abc = 1, def = 2, xyz = 5) x[c(&quot;xyz&quot;, &quot;def&quot;)] We can also use a character vector to duplicate individual entries. x[c(&quot;xyz&quot;, &quot;xyz&quot;, &quot;def&quot;, &quot;def&quot;)] The simplest type of subsetting is nothing, x[], which returns the complete x. This is mostly useful when subsetting matrices (and other high dimensional structures) because we can select all the rows or all the columns, by leaving that index blank. E.g., if x is 2d, x[1, ] selects the first row and all the columns. Learn more about the applications of subsetting: “Subsetting” chapter of Advanced R: http://adv-r.had.co.nz/Subsetting.html#applications. An important difference between [ and [[ -&gt; [[ extracts only a single element, and always drops names. Use it whenever we want to make it clear that we’re extracting a single item, as in a for loop. 12.4.6 Exercises What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))? x &lt;- c(-Inf, -1, 0, 1, Inf, NA, NaN) mean(is.na(x)) sum(!is.finite(x)) mean(is.na(x)) calculates the proprtion of missing (NA) and not-a-number (NaN) values in a vector. The result of 0.286 is equal to 2 / 7 as expected. sum(!is.finite(x)) calculates the number of elements in the vector that are equal to missing (NA), not-a-number (NaN), or infinity (Inf). Carefully read the documentation of is.vector(). What does it actually test for? Why does is.atomic() not agree with the definition of atomic vectors above? is.vector() checks whether an object has no attributes other than names. is.vector(list(a = 1, b = 2)) But any object that has an attribute apart from names is not: x &lt;- 1:10 attr(x, &quot;something&quot;) &lt;- TRUE is.vector(x) is.atomic() explicitly checks whether an object is one of the atomic types (“logical”, “integer”, “numeric”, “complex”, “character”, and “raw”) or NULL. is.atomic(1:10) is.atomic(list(a = 1)) is.atomic() will consider objects to be atomic even if they have extra attributes. is.atomic(x) Compare and contrast setNames() with purrr::set_names(). setNames() takes two arguments, a vector to be named and a vector of names to apply to its elements. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) setNames(nm = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) set_names() has more ways to set names than setNames(). We can specify the names the same way as setNames(): purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The names can also be specified as unnamed arguments: purrr::set_names(1:4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) set_names() will name an object with itself if no nm argument is provided (the opposite of setNames() behavior). purrr::set_names(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The main difference between set_names() and setNames() is that set_names() allows for using a function or formula to transform the existing names. purrr::set_names(c(a = 1, b = 2, c = 3), toupper) purrr::set_names(c(a = 1, b = 2, c = 3), ~toupper(.)) set_names() function also checks that the length of the names argument is the same length as the vector that is being named, and will raise an error if it is not. purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;)) setNames() function will allow the names to be shorter than the vector being named, and will set the missing names to NA. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;)) Create functions that take a vector as input and returns: The last value. Should you use [ or [[? The elements at even numbered positions. Every element except the last value. Only even numbers (and no missing values). Why is x[-which(x &gt; 0)] not the same as x[x &lt;= 0]? What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist? "],["recursive-vectors-lists.html", "12.5 Recursive vectors (lists)", " 12.5 Recursive vectors (lists) Lists can contain other lists implying that are more complex than atomic vectors. Hence, suitable to represent hierarchical or tree-like structures. Use list() to create lists. (xl &lt;- list(1, 2, 3)) We use the function str() to assess the structure. str(xl) dplyr::glimpse(xl) #seems one and the same thing? Lists can be named: xl_named &lt;- list(a = 1, b = 2, c = 3) str(xl_named) list() can contain a mix of objects unlike atomic vectors. yl &lt;- list(&quot;a&quot;, 1L, 1.5, TRUE) str(yl) Lists can contain other lists! zl &lt;- list(list(1, 2), list(3, 4)) str(zl) 12.5.1 Visualising lists Let’s see a visual representation of lists. E.g., x1 &lt;- list(c(1, 2), c(3, 4)) x2 &lt;- list(list(1, 2), list(3, 4)) x3 &lt;- list(1, list(2, list(3))) A visual drawing of the lists: There are three principles: Lists have rounded corners. Atomic vectors have square corners. Children are drawn inside their parent, and have a slightly darker background to make it easier to see the hierarchy. The orientation of the children (i.e. rows or columns) isn’t important, a row or column orientation are picked to either save space or illustrate an important property in the example. ?? 12.5.2 Subsetting We can subset lists using three ways, let’s see the example below. a &lt;- list(a = 1:3, b = &quot;a string&quot;, c = pi, d = list(-1, -5)) [ extracts a sub-list. And the result will always be a list. str(a[1:2]) str(a[4]) We can also subset lists with a logical, integer or character vector as seen in vectors. [[ extracts a single component from a list. It removes a level of hierarchy from the list. str(a[[1]]) str(a[[4]]) $ is a shorthand to extract named elements of a list. It works similarly to [[ except that you don’t need to use quotes. a$a a[[&quot;a&quot;]] Difference between [ and [[ is important for lists: [[ drills down into the list while [ returns a new, smaller list. Let’s compare the code and output above with the visual shown below. 12.5.3 Lists of condiments Let’s discuss an illustration of the difference between [ and [[ to solidify our understanding! :) Below we see an usual pepper shaker, and let it be our list x. x[1] is a pepper shaker containing a single pepper packet: x[2] would look the same, but would contain the second packet. x[1:2] would be a pepper shaker containing two pepper packets. x[[1]] is: x[[1]][[1]] to get the content of the pepper package: 12.5.4 Exercises Draw the following lists as nested sets: list(list(list(list(list(list(a)))))) list(a, b, list(c, d), list(e, f)) To draw pretty a visual diagram, refer to DiagramR R Package to render Graphviz diagrams. But what I have is hand-drawn. Not pretty!! :) For a: For b: 2. What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble? Subsetting a tibble works the same way as a list; a data frame can be thought of as a list of columns. The key difference between a list and a tibble -&gt; all the elements (columns) of a tibble must have the same length (number of rows). Lists can have vectors with different lengths as elements. x &lt;- tibble(a = 1:2, b = 3:4) x[[&quot;a&quot;]] x[&quot;a&quot;] x[1] x[1, ] "],["attributes.html", "12.6 Attributes", " 12.6 Attributes Any vector can contain arbitrary additional metadata through its attributes. Can be thought as named list of vectors that can be attached to any object. We can get and set individual attribute values with attr() or see them all at once with attributes(). x &lt;- 1:10 attr(x, &quot;greeting&quot;) attr(x, &quot;greeting&quot;) &lt;- &quot;Hi!&quot; attr(x, &quot;farewell&quot;) &lt;- &quot;Bye!&quot; attributes(x) Three very important attributes that used to implement fundamental parts of R: Names are used to name the elements of a vector. Dimensions (dims, for short) make a vector behave like a matrix or array. Class is used to implement the S3 object oriented system. Note: We have learnt of the names, and we won’t discuss matrices in this discussion as matrices aren;t used in this book! Class controls how generic functions work. Generic functions are key to object programming since they make functions behave differently for different classes of input. The discussion of object programming is covered in details in Advanced R: http://adv-r.had.co.nz/OO-essentials.html#s3 An example of generic function: as.Date The call to “UseMethod” means that this is a generic function, and it calls a specific method, a function, based on the class of the first argument. Note: All methods are functions; not all functions are methods. To list all the methods for a generic, use methods(): methods(&quot;as.Date&quot;) For example, if x is a character vector, as.Date() will call as.Date.character(); if it’s a factor, it’ll call as.Date.factor(). We can see the specific implementation of a method with getS3method(): getS3method(&quot;as.Date&quot;, &quot;default&quot;) getS3method(&quot;as.Date&quot;, &quot;numeric&quot;) The most important S3 generic is print() -&gt; controls how the object is printed when we type its name at the console. Subsetting functions: [, [[ and $ are other important generics. "],["augmented-vectors.html", "12.7 Augmented vectors", " 12.7 Augmented vectors Atomics vectors and lists are building blocks for other important vector types like factors and dates. These are called augmented vectors because they are vectors with additional attributes, including class. Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. Here, we will discuss four important augmented vectors: Factors Dates Date-times Tibbles 12.7.1 Factors They are designed to represent categorical data that can take a fixed set of possible values. They are built on top of integers and have a levels attribute: x_factor &lt;- factor(c(&quot;ab&quot;, &quot;cd&quot;, &quot;ab&quot;), levels = c(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;)) typeof(x_factor) attributes(x_factor) 12.7.2 Dates and date-times In R, dates are numeric vectors that represent the number of days since 1 January 1970. x_date &lt;- as.Date(&quot;1971-01-01&quot;) unclass(x_date) typeof(x_date) attributes(x_date) Dates-times are numeric vectors with class POSIXct that represent the # of seconds since 1 January 1970. Note: “POSIXct” stands for “Portable Operating System Interface”, calendar time. x_date_time &lt;- lubridate::ymd_hm(&quot;1970-01-01 01:00&quot;) unclass(x_date_time) typeof(x_date_time) attributes(x_date_time) The tzone attribute is optional–&gt; controls how the time is printed, not what absolute time it refers to. attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Pacific&quot; x_date_time attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Eastern&quot; x_date_time Qn: how to find the other time zones? Another type of date-times called POSIXlt which are built on top of named lists: y_date_time &lt;- as.POSIXlt(x_date_time) typeof(y_date_time) attributes(y_date_time) POSIXlts are rare inside the tidyverse. But pop up in base R, because they are needed to extract specific components of a date, like the year or month. Since lubridate provides helpers for us to do this instead, we don’t need them. POSIXct’s are always easier to work with, so if we have a POSIXlt, we should always convert it to a regular data time lubridate::as_date_time(). 12.7.3 Tibbles Tibbles are augmented lists. They have class “tbl_df” + “tbl” + “data.frame”, and names (column) and row.names attributes: tb &lt;- tibble::tibble(x = 1:5, y = 5:1) typeof(tb) attributes(tb) The difference between a tibble and a list: All the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint. Traditional data.frames have a very similar structure: df &lt;- data.frame(x = 1:5, y = 5:1) typeof(df) attributes(df) The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default. 12.7.4 Exercises What does hms::hms(3600) return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use? (x &lt;- hms::hms(3600)) class(x) attributes(x) hms::hms returns an object of class, and prints the time in “%H:%M:%S” format. The attributes it uses are units and class Try and make a tibble that has columns with different lengths. What happens? tibble(x = 1, y = 1:5) The “scalar” 1 is recycled to the length of the longer vector. tibble(x = 1:3, y = 1:4) Creating a tibble with two vectors of different lengths will give an error. Based on the definition above, is it ok to have a list as a column of a tibble? tibble(x = 1:3, y = list(&quot;a&quot;, 1, list(1:3))) Tibbles can have atomic vectors (with additional attributes)of different types: doubles, character, integers, logical, factor, date. Hence, they can have a list vector as long as its the same length! "],["meeting-videos-11.html", "12.8 Meeting Videos", " 12.8 Meeting Videos 12.8.1 Cohort 5 Meeting chat log 00:39:35 Jon Harmon (jonthegeek): .Machine$double.eps 00:40:36 Jon Harmon (jonthegeek): &gt; .Machine$integer.max [1] 2147483647 00:41:23 Federica Gazzelloni: ?`.Machine` 00:42:11 Ryan Metcalf: Some really fun reading about CPU “inner” workings: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/ 00:42:35 Jon Harmon (jonthegeek): &gt; typeof(.Machine$integer.max + 1) [1] &quot;double&quot; 00:42:55 Jon Harmon (jonthegeek): &gt; .Machine$integer.max + 1L [1] NA Warning message: In .Machine$integer.max + 1L : NAs produced by integer overflow 00:43:52 Becki R. (she/her): thanks for the link, Ryan! 00:44:44 Jon Harmon (jonthegeek): &gt; sqrt(2)**2 == 2 [1] FALSE 00:45:16 Jon Harmon (jonthegeek): &gt; dplyr::near(sqrt(2)**2, 2) [1] TRUE 00:57:52 Ryan Metcalf: Not directly related to Cache or RAM….But similar. It is where you get FAT, FAT32, NTFS, ExFat, EXT, EXT3, etc…etc… there are hundreds of file allocation. 00:59:29 Sandra Muroy: thanks Ryan! 01:02:08 Becki R. (she/her): I&#39;m finding the info on computer architecture (?) fascinating so I appreciate the detour. 01:03:05 Sandra Muroy: I&#39;m glad :) 01:10:01 Ryan Metcalf: I think I just had an epiphany!!! Is this were the “Big Endian” and “Little Endian” comes in? The leading bit representing positive and negative? 01:10:27 Jon Harmon (jonthegeek): &gt; typeof(0L) [1] &quot;integer&quot; 01:12:42 Jon Harmon (jonthegeek): &gt; .Machine$double.xmax [1] 1.797693e+308 01:15:53 Jon Harmon (jonthegeek): &gt; 1:10 + 1 [1] 2 3 4 5 6 7 8 9 10 11 01:16:19 Jon Harmon (jonthegeek): &gt; 1:10 + 2:11 [1] 3 5 7 9 11 13 15 17 19 21 Meeting chat log 00:03:09 Becki R. (she/her): I have a buzz in my audio so I&#39;m staying muted. 00:30:48 Federica Gazzelloni: http://adv-r.had.co.nz/Subsetting.html 00:33:31 Jon Harmon (jonthegeek): mtcars[&quot;mpg&quot;] mtcars[[&quot;mpg&quot;]] 00:35:19 Jon Harmon (jonthegeek): months &lt;- purrr::set_names(month.name, month.abb) 00:35:40 Jon Harmon (jonthegeek): months[&quot;Jan&quot;] 00:35:46 Jon Harmon (jonthegeek): Jan &quot;January&quot; 00:36:10 Jon Harmon (jonthegeek): &gt; months[[&quot;Jan&quot;]] [1] &quot;January&quot; 00:38:28 Federica Gazzelloni: it acts like unlist() 00:38:48 Jon Harmon (jonthegeek): &gt; unlist(mtcars[&quot;mpg&quot;]) mpg1 mpg2 mpg3 mpg4 mpg5 mpg6 mpg7 mpg8 mpg9 mpg10 mpg11 mpg12 mpg13 mpg14 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 mpg15 mpg16 mpg17 mpg18 mpg19 mpg20 mpg21 mpg22 mpg23 mpg24 mpg25 mpg26 mpg27 mpg28 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 mpg29 mpg30 mpg31 mpg32 15.8 19.7 15.0 21.4 00:39:13 Jon Harmon (jonthegeek): &gt; unname(unlist(mtcars[&quot;mpg&quot;])) [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:39:29 Jon Harmon (jonthegeek): single &lt;- mtcars[&quot;mpg&quot;] 00:39:50 Jon Harmon (jonthegeek): &gt; attributes(single) &lt;- NULL &gt; single [[1]] [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:42:51 Jon Harmon (jonthegeek): &gt; str(months[[1]]) chr &quot;January&quot; &gt; str(months[1]) Named chr &quot;January&quot; - attr(*, &quot;names&quot;)= chr &quot;Jan&quot; 00:43:41 Jon Harmon (jonthegeek): ?`[` 00:44:15 Jon Harmon (jonthegeek): The most important distinction between [, [[ and $ is that the [ can select more than one element whereas the other two select a single element. 00:47:28 Ryan Metcalf: BRB 00:56:31 Jon Harmon (jonthegeek): The tangent I obsessed on just now: &gt; pillar:::glimpse.default function (x, width = NULL, max.level = 3, ...) { str(x, width = get_width_glimpse(width), max.level = max.level, ...) invisible(x) } (huh, &quot;glimpse&quot; technically comes from the {pillar} package) 01:12:09 Jon Harmon (jonthegeek): &gt; round(c(1.5, 2.5, 3.5, 4.5)) [1] 2 2 4 4 01:14:08 Jon Harmon (jonthegeek): Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). 12.8.2 Cohort 6 Meeting chat log 00:36:56 Daniel Adereti: Lucky I am not a python user. lol 00:37:05 Marielena Soilemezidi: 😂 00:38:03 Marielena Soilemezidi: python will come and get you too, Daniel! 00:38:18 Daniel Adereti: lol! can&#39;t avoid it! 00:42:11 Daniel Adereti: Unfortunately, we have a strict 18 mins to end the lessons, let&#39;s see where we end up. Thanks "],["numbers.html", "Chapter 13 Numbers", " Chapter 13 Numbers Note: Since these slides were made, this chapter has been split into multiple chapters. After you edit these slides, remove this note. Learning objectives: Compare and contrast atomic vectors and lists. Recognize the six types of atomic vectors. Determine the key properties (typeof and length) of vectors. Recognize the three important types of augmented vectors. Construct logical vectors. Construct numeric vectors. Differentiate between the two types of numeric vectors, double and integer. Construct character vectors. Recognize the different types of missing values. Coerce vectors between different types. Test whether a vector has a given type. Recognize when a vector will be recycled to match the length of another vector, and when it will not. Name the elements of vectors. Subset vectors. Construct lists. Differentiate between [, [[, and $ for subsetting lists. Use attributes to provide additional information about vectors. Recognize the S3 object-oriented system. Construct factors. Construct dates and date-times. Recognize that tibbles are augmented lists. "],["introduction-4.html", "13.1 Introduction", " 13.1 Introduction Since we have already learnt about tibbles, in this chapter we will study vectors that underlie them. 13.1.1 Prerequisites Here we focus on base R data structures, hence no need to load any packages. But we will a couple of functions from purrr package to avoid some inconsistencies in base R. library(tidyverse) "],["vector-basics-1.html", "13.2 Vector basics", " 13.2 Vector basics There are two types of vectors: Atomic vectors, of which there are six types: logical integer double character complex raw Integer and double vectors are collectively called numeric vectors. Lists, at times, are called recursive vectors because lists can contain other lists. The main difference between vectors and lists: Atomic vectors are homogeneous i.e., contain only one type (in my understanding). Lists are heterogeneous i.e., can have different types. Another related object: NULL. It is often used to represent the absence of a vector (unlike NA which is used to represent the absence of a value). NULL typically acts as a vector of length 0. Figure 20.1: The hierarchy of R’s vector types: Two key properties for each vector: Its type, which can be determined with typeof(). typeof(letters) typeof(1:10) Its length, which can be determined with length(). x1 &lt;- list(&quot;a&quot;, &quot;b&quot;, 1:10); length(x1) x2 &lt;- c(&quot;a&quot;, &quot;b&quot;); length(x2) Qn: does this imply that the length of a list is the # of elements in a list for example (x1)? Vectors can also contain arbitrary additional metadata in the form of attributes. Which are then used to create augmented vectors which build on additional behaviour. There are three important types of augmented vectors: Factors are built on top of integer vectors. Dates and date-times are built on top of numeric vectors. Data frames and tibbles are built on top of lists. "],["important-types-of-atomic-vector-1.html", "13.3 Important types of atomic vector", " 13.3 Important types of atomic vector The four most important types of atomic vectors: logical, integer, double, and character. Note: Raw and complex are rarely used during a data analysis, hence not part of this of discussion. 13.3.1 Logical Simplest type of atomic vector –&gt; can take only three possible values: FALSE, TRUE, and NA. They are constructed with comparison operators. OR, can create them by hand with c(): 1:10 %% 3 == 0 c(TRUE, TRUE, FALSE, NA) Qn: what exactly is %% doing here? I understand is x modulus y… 13.3.2 Numeric As learnt, integer and double are known collectively as numeric vectors. In R, numbers are doubles by default. To create an integer, place L after the number. typeof(1) typeof(1L) 1.5L Note: the warning after running 1.5L is because that integers only take whole numbers. I think. Two important differences between doubles and integers: Doubles are approximations. They represent floating point numbers that can’t be precisely represented with a fixed amount of memory. Therefore, we should consider all doubles as approximations. E.g., the square root of two: (x3 &lt;- sqrt(2) ^ 2) options(scipen = 999) x3 - 2 Side note: options(scipen = 999) to remove the scientific numbers as I often confuse reading e- or e+. When working with floating point numbers, it is common that the calculations include some approximation. Hence, when we compare floating point numbers we should use dplyr::near() instead of == as it allows for some numerical tolerance. (what does this mean?) dplyr::near(1.745, 2) # compares if 1.745 is the same as 2 # FALSE Integers have one special value: NA while doubles have four: NA, NaN, Inf and -Inf. NaN, Inf and -Inf can arise during division: c(-1, 0, 1) / 0 To check for these special values, let’s use the helper functions is.finite(), is.infinite(), and is.nan() instead of using ==. is.finite(c(-1, 0, 1) / 0) is.infinite(c(-1, 0, 1) / 0) is.na(c(-1, 0, 1) / 0) is.nan(c(-1, 0, 1) / 0) 13.3.3 Character Most complex atomic vector because each element of a character vector is a string, and a string contains an arbitrary amount of data. R uses a global string pool. Implying that each unique string is only stored in memory once. And every use of the string points to that representation. This reduces the amount of memory needed by duplicated strings. To see this, let’s use pryr::object_size(): x &lt;- &quot;This is a reasonably long string.&quot; pryr::object_size(x) y &lt;- rep(x, 1000) pryr::object_size(y) y doesn’t take up 1,000x as much memory as x, because each element of y is just a pointer to that same string. A pointer is 8 bytes, so 1000 pointers to a 152 B string is 8 * 1000 + 152 = 8.14 kB. 13.3.4 Missing values Each atomic vector has its own missing value: NA # logical NA_integer_ # integer NA_real_ # double NA_character_ # character But we don’t need to know about these different types since we can always use NA and it’ll be converted to the correct type using the implicit coercion rules. However, there are some functions that are strict about their inputs, so it’s useful to have this knowledge sitting in your back pocket so you can be specific when needed. 13.3.5 Exercises Describe the difference between is.finite(x) and !is.infinite(x). (x &lt;- c(-1/0, 0/0, 1/0, 5, 5L, NA)) is.finite(x) is.infinite(x) !is.infinite(x) is.finite() function does consider non-missing numeric values to be finite, and -Inf, NaN, Inf are considered not to be finite. is.infinite() considers only -Inf and Inf as infinite. Hence, !is.infinite() considers -Inf and Inf to be finite while non-missing numeric values, NaN, and NA not to be infinite. Read the source code for dplyr::near() (Hint: to see the source code, drop the ()). How does it work? dplyr::near() It doesn’t check equality as I first thought, but it checks if two numbers are within a certain tolerance (tol), usually given as .Machine$double.eps^0.5, which is the smallest floating point number that the computer can represent. (Good to know!!) A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research. help(integer) help(double) For integers vectors, R uses a 32-bit representation. I.e., it can represent \\(2^{32}\\) different values with the integers. But one of these values is set aside for NA_integer_. .Machine$integer.max .Machine$integer.max + 1L The range of integers values represented in R is \\(+- 2^{31}-1\\). Hence, the maximum integer is \\(2^{31}-1\\) instead of \\(2^{32}\\) because 1 bit is used to represent the sign \\((+ -)\\) and one value is to represent \\(NA_integer_\\). An integer greater than that value, R will return NA values. For double vectors, R uses a 64-bit representation, i.e., they can hold up to \\(2^{64}\\) values. But, some of those values are assigned to special values: -Inf, Inf, NA_real_, and NaN. .Machine$double.xmax Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise. The difference between conversion of a double to an integer differs in how they deal with the fractional part of the double. Round down, towards \\(-\\infty\\) i.e., taking the floor of a number –&gt; floor(). Round up, towards \\(\\infty\\) i.e., taking the ceiling of a number –&gt; ceiling(). Round towards zero –&gt; trunc() and as.integer(). Round away from zero. Round to the nearest integer. If ties exists, then numbers are defined with a fractional part of 0.5? Round half down, towards \\(-\\infty\\). Round half up, towards \\(\\infty\\) Round half towards zero Round half away from zero Round half towards the even integer –&gt; round(). Round half towards the odd integer. tibble( x = c(1.8, 1.5, 1.2, 0.8, 0.5, 0.2, -0.2, -0.5, -0.8, -1.2, -1.5, -1.8), `Round down` = floor(x), `Round up` = ceiling(x), `Round towards zero` = trunc(x), `Nearest, round half to even` = round(x) # 0.5 is rounded to 0 ) What functions from the readr package allow you to turn a string into logical, integer, and double vector? parse_logical() parses logical values, which can appear as variations of TRUE/FALSE or 1/0. parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;1&quot;, &quot;0&quot;, &quot;true&quot;, &quot;t&quot;, &quot;NA&quot;)) parse_integer() parses integer values. parse_integer(c(&quot;1235&quot;, &quot;0134&quot;, &quot;NA&quot;)) In case of any non-numeric characters in the string such as commas, decimals, parse_integer() will throw an error unlike parse_numeric() which ignores all the non-numeric characters before or after the first number. parse_integer(c(&quot;1000&quot;, &quot;$1,000&quot;, &quot;10.00&quot;)) parse_number(c(&quot;1.0&quot;, &quot;3.5&quot;, &quot;$1,000.00&quot;, &quot;NA&quot;, &quot;ABCD12234.90&quot;, &quot;1234ABC&quot;, &quot;A123B&quot;, &quot;A1B2C&quot;)) "],["using-atomic-vectors-1.html", "13.4 Using atomic vectors", " 13.4 Using atomic vectors Let’s review some of the important tools for working with the different types of atomic vectors: How to convert from one type to another, and when that happens automatically. How to tell if an object is a specific type of vector. What happens when you work with vectors of different lengths. How to name the elements of a vector. How to pull out elements of interest. 13.4.1 Coercion We can coerce or convert one type of vector to another in two ways: Explicit coercion -&gt; call a function like as.logical(), as.integer(), as.double(), or as.character(). Before doing this, check the type of the vector. For example, you may need to tweak your readr col_types specification. Implicit coercion -&gt; use a vector in a specific context that expects a certain type of vector. For example, using a logical vector with a numeric summary function or using a double vector where an integer vector is expected. Our focus here will be implicit coercion as explicit coercion is relatively rarely used in data analysis plus easy to understand. An important type of implicit coercion: using a logical vector in a numeric context. TRUE is converted to 1 and FALSE is converted to 0. Hence, summing the logical vector is the # of trues and the mean of a logical vector is the proportion of trues. x &lt;- sample(20, 100, replace = TRUE) y &lt;- x &gt; 10 sum(y) # how many are greater than 10? mean(y) # what proportion are greater than 10? Or, some code that relies on implicit coercion in the opposite direction, from integer to logical: if (length(x)) { # do something } Here, 0 is converted to FALSE and everything else is converted to TRUE. For easier understanding of the code, let’s be explicit: length(x) &gt; 0. NOTE1: When we create a vector containing multiple types with c(): the most complex type always wins. –&gt; Aha moment! typeof(c(TRUE, 1L)) #integer wins typeof(c(1L, 1.5)) #double wins #why? Thinking here, because integer is created from a double? typeof(c(1.5, &quot;a&quot;)) #character wins NOTE2: An atomic vector can not only have a mix of different types since the type is a property of the complete vector, not the individual elements. For a mix of multiple types in the same vector, use a list. 13.4.2 Test functions Suppose we want to have different things based on the type of vector: One option is to use typeof(). Or, use a test function which returns a TRUE or FALSE. Not recommended: base R functions -&gt; is.vector() and is.atomic(). Instead let’s use the is_* functions provided by purrr , summarised below. 13.4.3 Scalars and recycling rules Not only does R implicitly coerce the types of vectors to be compatible, but it also implicitly coerce the length of vectors. This is called vector recycling because the shorter vector is repeated (or recycled) to the same length as the longer vector. Mostly useful when we are mixing vectors and “scalars”. Note, R doesn’t have scalars instead, a single number is a vector of length 1. Since there are no scalars, most built-in functions are vectorised meaning that they will operate on a vector of numbers. Hence, such a code will work: sample(10) + 100 runif(10) &gt; 0.5 What happens if we add two vectors of different lengths? 1:10 + 1:2 R expands the shortest vector to the same length as the longest –&gt; recycling. But what if the length of the longer is not an integer multiple of the length of the shorter: 1:10 + 1:3 Vector recycling can silently conceal the problem, hence, the vectorised functions in tidyverse will throw errors when recycling anything other than a scalar. We can use rep() to do recycling ourselves. tibble(x = 1:4, y = 1:2) tibble(x = 1:4, y = rep(1:2, 2)) tibble(x = 1:4, y = rep(1:2, each = 2)) 13.4.4 Naming vectors We can name all types of vectors during creation with c(): c(x = 1, y = 2, z = 4) Or, with purrr::set_names(): set_names(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) Why name vectors? Because are useful in subsetting. 13.4.5 Subsetting To filter vectors, we use the subsetting function -&gt; [ and is called like x[a].There are four types of things that you can subset a vector with: A numeric vector containing only integers, and these must either be all positive, all negative, or zero. Subsetting with positive integers keeps the elements at those positions: x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;) x[c(3, 2, 5)] If we repeat a position, we can actually make a longer output than input: x[c(1, 1, 5, 5, 5, 2)] Negative values drop the elements at the specified positions: x[c(-1, -3, -5)] It’s an error to mix positive and negative values: x[c(1, -1)] The error message mentions subsetting with zero, which returns no values: x[0] This is useful if we want to create unusual data structures to functions with. (Jon, please expound!) Subsetting with a logical vector keeps all values corresponding to a TRUE value; often useful in conjunction with the comparison functions. x &lt;- c(10, 3, NA, 5, 8, 1, NA) # All non-missing values of x x[!is.na(x)] # All even (or missing!) values of x x[x %% 2 == 0] If you have a named vector, you can subset it with a character vector: x &lt;- c(abc = 1, def = 2, xyz = 5) x[c(&quot;xyz&quot;, &quot;def&quot;)] We can also use a character vector to duplicate individual entries. x[c(&quot;xyz&quot;, &quot;xyz&quot;, &quot;def&quot;, &quot;def&quot;)] The simplest type of subsetting is nothing, x[], which returns the complete x. This is mostly useful when subsetting matrices (and other high dimensional structures) because we can select all the rows or all the columns, by leaving that index blank. E.g., if x is 2d, x[1, ] selects the first row and all the columns. Learn more about the applications of subsetting: “Subsetting” chapter of Advanced R: http://adv-r.had.co.nz/Subsetting.html#applications. An important difference between [ and [[ -&gt; [[ extracts only a single element, and always drops names. Use it whenever we want to make it clear that we’re extracting a single item, as in a for loop. 13.4.6 Exercises What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))? x &lt;- c(-Inf, -1, 0, 1, Inf, NA, NaN) mean(is.na(x)) sum(!is.finite(x)) mean(is.na(x)) calculates the proprtion of missing (NA) and not-a-number (NaN) values in a vector. The result of 0.286 is equal to 2 / 7 as expected. sum(!is.finite(x)) calculates the number of elements in the vector that are equal to missing (NA), not-a-number (NaN), or infinity (Inf). Carefully read the documentation of is.vector(). What does it actually test for? Why does is.atomic() not agree with the definition of atomic vectors above? is.vector() checks whether an object has no attributes other than names. is.vector(list(a = 1, b = 2)) But any object that has an attribute apart from names is not: x &lt;- 1:10 attr(x, &quot;something&quot;) &lt;- TRUE is.vector(x) is.atomic() explicitly checks whether an object is one of the atomic types (“logical”, “integer”, “numeric”, “complex”, “character”, and “raw”) or NULL. is.atomic(1:10) is.atomic(list(a = 1)) is.atomic() will consider objects to be atomic even if they have extra attributes. is.atomic(x) Compare and contrast setNames() with purrr::set_names(). setNames() takes two arguments, a vector to be named and a vector of names to apply to its elements. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) setNames(nm = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) set_names() has more ways to set names than setNames(). We can specify the names the same way as setNames(): purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The names can also be specified as unnamed arguments: purrr::set_names(1:4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) set_names() will name an object with itself if no nm argument is provided (the opposite of setNames() behavior). purrr::set_names(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The main difference between set_names() and setNames() is that set_names() allows for using a function or formula to transform the existing names. purrr::set_names(c(a = 1, b = 2, c = 3), toupper) purrr::set_names(c(a = 1, b = 2, c = 3), ~toupper(.)) set_names() function also checks that the length of the names argument is the same length as the vector that is being named, and will raise an error if it is not. purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;)) setNames() function will allow the names to be shorter than the vector being named, and will set the missing names to NA. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;)) Create functions that take a vector as input and returns: The last value. Should you use [ or [[? The elements at even numbered positions. Every element except the last value. Only even numbers (and no missing values). Why is x[-which(x &gt; 0)] not the same as x[x &lt;= 0]? What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist? "],["recursive-vectors-lists-1.html", "13.5 Recursive vectors (lists)", " 13.5 Recursive vectors (lists) Lists can contain other lists implying that are more complex than atomic vectors. Hence, suitable to represent hierarchical or tree-like structures. Use list() to create lists. (xl &lt;- list(1, 2, 3)) We use the function str() to assess the structure. str(xl) dplyr::glimpse(xl) #seems one and the same thing? Lists can be named: xl_named &lt;- list(a = 1, b = 2, c = 3) str(xl_named) list() can contain a mix of objects unlike atomic vectors. yl &lt;- list(&quot;a&quot;, 1L, 1.5, TRUE) str(yl) Lists can contain other lists! zl &lt;- list(list(1, 2), list(3, 4)) str(zl) 13.5.1 Visualising lists Let’s see a visual representation of lists. E.g., x1 &lt;- list(c(1, 2), c(3, 4)) x2 &lt;- list(list(1, 2), list(3, 4)) x3 &lt;- list(1, list(2, list(3))) A visual drawing of the lists: There are three principles: Lists have rounded corners. Atomic vectors have square corners. Children are drawn inside their parent, and have a slightly darker background to make it easier to see the hierarchy. The orientation of the children (i.e. rows or columns) isn’t important, a row or column orientation are picked to either save space or illustrate an important property in the example. ?? 13.5.2 Subsetting We can subset lists using three ways, let’s see the example below. a &lt;- list(a = 1:3, b = &quot;a string&quot;, c = pi, d = list(-1, -5)) [ extracts a sub-list. And the result will always be a list. str(a[1:2]) str(a[4]) We can also subset lists with a logical, integer or character vector as seen in vectors. [[ extracts a single component from a list. It removes a level of hierarchy from the list. str(a[[1]]) str(a[[4]]) $ is a shorthand to extract named elements of a list. It works similarly to [[ except that you don’t need to use quotes. a$a a[[&quot;a&quot;]] Difference between [ and [[ is important for lists: [[ drills down into the list while [ returns a new, smaller list. Let’s compare the code and output above with the visual shown below. 13.5.3 Lists of condiments Let’s discuss an illustration of the difference between [ and [[ to solidify our understanding! :) Below we see an usual pepper shaker, and let it be our list x. x[1] is a pepper shaker containing a single pepper packet: x[2] would look the same, but would contain the second packet. x[1:2] would be a pepper shaker containing two pepper packets. x[[1]] is: x[[1]][[1]] to get the content of the pepper package: 13.5.4 Exercises Draw the following lists as nested sets: list(list(list(list(list(list(a)))))) list(a, b, list(c, d), list(e, f)) To draw pretty a visual diagram, refer to DiagramR R Package to render Graphviz diagrams. But what I have is hand-drawn. Not pretty!! :) For a: For b: 2. What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble? Subsetting a tibble works the same way as a list; a data frame can be thought of as a list of columns. The key difference between a list and a tibble -&gt; all the elements (columns) of a tibble must have the same length (number of rows). Lists can have vectors with different lengths as elements. x &lt;- tibble(a = 1:2, b = 3:4) x[[&quot;a&quot;]] x[&quot;a&quot;] x[1] x[1, ] "],["attributes-1.html", "13.6 Attributes", " 13.6 Attributes Any vector can contain arbitrary additional metadata through its attributes. Can be thought as named list of vectors that can be attached to any object. We can get and set individual attribute values with attr() or see them all at once with attributes(). x &lt;- 1:10 attr(x, &quot;greeting&quot;) attr(x, &quot;greeting&quot;) &lt;- &quot;Hi!&quot; attr(x, &quot;farewell&quot;) &lt;- &quot;Bye!&quot; attributes(x) Three very important attributes that used to implement fundamental parts of R: Names are used to name the elements of a vector. Dimensions (dims, for short) make a vector behave like a matrix or array. Class is used to implement the S3 object oriented system. Note: We have learnt of the names, and we won’t discuss matrices in this discussion as matrices aren;t used in this book! Class controls how generic functions work. Generic functions are key to object programming since they make functions behave differently for different classes of input. The discussion of object programming is covered in details in Advanced R: http://adv-r.had.co.nz/OO-essentials.html#s3 An example of generic function: as.Date The call to “UseMethod” means that this is a generic function, and it calls a specific method, a function, based on the class of the first argument. Note: All methods are functions; not all functions are methods. To list all the methods for a generic, use methods(): methods(&quot;as.Date&quot;) For example, if x is a character vector, as.Date() will call as.Date.character(); if it’s a factor, it’ll call as.Date.factor(). We can see the specific implementation of a method with getS3method(): getS3method(&quot;as.Date&quot;, &quot;default&quot;) getS3method(&quot;as.Date&quot;, &quot;numeric&quot;) The most important S3 generic is print() -&gt; controls how the object is printed when we type its name at the console. Subsetting functions: [, [[ and $ are other important generics. "],["augmented-vectors-1.html", "13.7 Augmented vectors", " 13.7 Augmented vectors Atomics vectors and lists are building blocks for other important vector types like factors and dates. These are called augmented vectors because they are vectors with additional attributes, including class. Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. Here, we will discuss four important augmented vectors: Factors Dates Date-times Tibbles 13.7.1 Factors They are designed to represent categorical data that can take a fixed set of possible values. They are built on top of integers and have a levels attribute: x_factor &lt;- factor(c(&quot;ab&quot;, &quot;cd&quot;, &quot;ab&quot;), levels = c(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;)) typeof(x_factor) attributes(x_factor) 13.7.2 Dates and date-times In R, dates are numeric vectors that represent the number of days since 1 January 1970. x_date &lt;- as.Date(&quot;1971-01-01&quot;) unclass(x_date) typeof(x_date) attributes(x_date) Dates-times are numeric vectors with class POSIXct that represent the # of seconds since 1 January 1970. Note: “POSIXct” stands for “Portable Operating System Interface”, calendar time. x_date_time &lt;- lubridate::ymd_hm(&quot;1970-01-01 01:00&quot;) unclass(x_date_time) typeof(x_date_time) attributes(x_date_time) The tzone attribute is optional–&gt; controls how the time is printed, not what absolute time it refers to. attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Pacific&quot; x_date_time attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Eastern&quot; x_date_time Qn: how to find the other time zones? Another type of date-times called POSIXlt which are built on top of named lists: y_date_time &lt;- as.POSIXlt(x_date_time) typeof(y_date_time) attributes(y_date_time) POSIXlts are rare inside the tidyverse. But pop up in base R, because they are needed to extract specific components of a date, like the year or month. Since lubridate provides helpers for us to do this instead, we don’t need them. POSIXct’s are always easier to work with, so if we have a POSIXlt, we should always convert it to a regular data time lubridate::as_date_time(). 13.7.3 Tibbles Tibbles are augmented lists. They have class “tbl_df” + “tbl” + “data.frame”, and names (column) and row.names attributes: tb &lt;- tibble::tibble(x = 1:5, y = 5:1) typeof(tb) attributes(tb) The difference between a tibble and a list: All the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint. Traditional data.frames have a very similar structure: df &lt;- data.frame(x = 1:5, y = 5:1) typeof(df) attributes(df) The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default. 13.7.4 Exercises What does hms::hms(3600) return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use? (x &lt;- hms::hms(3600)) class(x) attributes(x) hms::hms returns an object of class, and prints the time in “%H:%M:%S” format. The attributes it uses are units and class Try and make a tibble that has columns with different lengths. What happens? tibble(x = 1, y = 1:5) The “scalar” 1 is recycled to the length of the longer vector. tibble(x = 1:3, y = 1:4) Creating a tibble with two vectors of different lengths will give an error. Based on the definition above, is it ok to have a list as a column of a tibble? tibble(x = 1:3, y = list(&quot;a&quot;, 1, list(1:3))) Tibbles can have atomic vectors (with additional attributes)of different types: doubles, character, integers, logical, factor, date. Hence, they can have a list vector as long as its the same length! "],["meeting-videos-12.html", "13.8 Meeting Videos", " 13.8 Meeting Videos 13.8.1 Cohort 5 Meeting chat log 00:39:35 Jon Harmon (jonthegeek): .Machine$double.eps 00:40:36 Jon Harmon (jonthegeek): &gt; .Machine$integer.max [1] 2147483647 00:41:23 Federica Gazzelloni: ?`.Machine` 00:42:11 Ryan Metcalf: Some really fun reading about CPU “inner” workings: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/ 00:42:35 Jon Harmon (jonthegeek): &gt; typeof(.Machine$integer.max + 1) [1] &quot;double&quot; 00:42:55 Jon Harmon (jonthegeek): &gt; .Machine$integer.max + 1L [1] NA Warning message: In .Machine$integer.max + 1L : NAs produced by integer overflow 00:43:52 Becki R. (she/her): thanks for the link, Ryan! 00:44:44 Jon Harmon (jonthegeek): &gt; sqrt(2)**2 == 2 [1] FALSE 00:45:16 Jon Harmon (jonthegeek): &gt; dplyr::near(sqrt(2)**2, 2) [1] TRUE 00:57:52 Ryan Metcalf: Not directly related to Cache or RAM….But similar. It is where you get FAT, FAT32, NTFS, ExFat, EXT, EXT3, etc…etc… there are hundreds of file allocation. 00:59:29 Sandra Muroy: thanks Ryan! 01:02:08 Becki R. (she/her): I&#39;m finding the info on computer architecture (?) fascinating so I appreciate the detour. 01:03:05 Sandra Muroy: I&#39;m glad :) 01:10:01 Ryan Metcalf: I think I just had an epiphany!!! Is this were the “Big Endian” and “Little Endian” comes in? The leading bit representing positive and negative? 01:10:27 Jon Harmon (jonthegeek): &gt; typeof(0L) [1] &quot;integer&quot; 01:12:42 Jon Harmon (jonthegeek): &gt; .Machine$double.xmax [1] 1.797693e+308 01:15:53 Jon Harmon (jonthegeek): &gt; 1:10 + 1 [1] 2 3 4 5 6 7 8 9 10 11 01:16:19 Jon Harmon (jonthegeek): &gt; 1:10 + 2:11 [1] 3 5 7 9 11 13 15 17 19 21 Meeting chat log 00:03:09 Becki R. (she/her): I have a buzz in my audio so I&#39;m staying muted. 00:30:48 Federica Gazzelloni: http://adv-r.had.co.nz/Subsetting.html 00:33:31 Jon Harmon (jonthegeek): mtcars[&quot;mpg&quot;] mtcars[[&quot;mpg&quot;]] 00:35:19 Jon Harmon (jonthegeek): months &lt;- purrr::set_names(month.name, month.abb) 00:35:40 Jon Harmon (jonthegeek): months[&quot;Jan&quot;] 00:35:46 Jon Harmon (jonthegeek): Jan &quot;January&quot; 00:36:10 Jon Harmon (jonthegeek): &gt; months[[&quot;Jan&quot;]] [1] &quot;January&quot; 00:38:28 Federica Gazzelloni: it acts like unlist() 00:38:48 Jon Harmon (jonthegeek): &gt; unlist(mtcars[&quot;mpg&quot;]) mpg1 mpg2 mpg3 mpg4 mpg5 mpg6 mpg7 mpg8 mpg9 mpg10 mpg11 mpg12 mpg13 mpg14 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 mpg15 mpg16 mpg17 mpg18 mpg19 mpg20 mpg21 mpg22 mpg23 mpg24 mpg25 mpg26 mpg27 mpg28 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 mpg29 mpg30 mpg31 mpg32 15.8 19.7 15.0 21.4 00:39:13 Jon Harmon (jonthegeek): &gt; unname(unlist(mtcars[&quot;mpg&quot;])) [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:39:29 Jon Harmon (jonthegeek): single &lt;- mtcars[&quot;mpg&quot;] 00:39:50 Jon Harmon (jonthegeek): &gt; attributes(single) &lt;- NULL &gt; single [[1]] [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:42:51 Jon Harmon (jonthegeek): &gt; str(months[[1]]) chr &quot;January&quot; &gt; str(months[1]) Named chr &quot;January&quot; - attr(*, &quot;names&quot;)= chr &quot;Jan&quot; 00:43:41 Jon Harmon (jonthegeek): ?`[` 00:44:15 Jon Harmon (jonthegeek): The most important distinction between [, [[ and $ is that the [ can select more than one element whereas the other two select a single element. 00:47:28 Ryan Metcalf: BRB 00:56:31 Jon Harmon (jonthegeek): The tangent I obsessed on just now: &gt; pillar:::glimpse.default function (x, width = NULL, max.level = 3, ...) { str(x, width = get_width_glimpse(width), max.level = max.level, ...) invisible(x) } (huh, &quot;glimpse&quot; technically comes from the {pillar} package) 01:12:09 Jon Harmon (jonthegeek): &gt; round(c(1.5, 2.5, 3.5, 4.5)) [1] 2 2 4 4 01:14:08 Jon Harmon (jonthegeek): Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). 13.8.2 Cohort 6 Meeting chat log 00:36:56 Daniel Adereti: Lucky I am not a python user. lol 00:37:05 Marielena Soilemezidi: 😂 00:38:03 Marielena Soilemezidi: python will come and get you too, Daniel! 00:38:18 Daniel Adereti: lol! can&#39;t avoid it! 00:42:11 Daniel Adereti: Unfortunately, we have a strict 18 mins to end the lessons, let&#39;s see where we end up. Thanks "],["strings.html", "Chapter 14 Strings", " Chapter 14 Strings Note: Since these slides were made, this chapter has been split into “Strings” and “Regular expressions”. After you edit these slides, remove this note. Learning objectives: Manipulate character vectors using simple {stringr} functions. Use regular expressions (regex) to match patterns in strings. Use regex to match simple characters, ., and \\. Use regex ^, $, and \\b to match anchors and boundaries. Use regex \\d, \\s, [], and [^] to match character classes. Use regex | and () to match alternatives. Use regex ?, +, *, {n}, {n,}, {,m}, and {n, m} to match repetitions in patterns. Use regex grouping and backreferences to refer to previous matches. Use {stringr} functions and regex to manipulate strings. Detect pattern matches with stringr::str_detect(). Select subsets of strings that match a pattern with stringr::str_subset(). Count pattern matches with stringr::str_count(). Extract pattern matches with stringr::str_extract() and stringr::str_extract_all(). Extract group matches with stringr::str_match(), stringr::str_match_all(), and tidyr::extract(). Replace pattern matches with stringr::str_replace() and stringr::str_replace_all(). Split strings into pieces with stringr::str_split() and stringr::boundary(). Locate matches within a string with stringr::str_locate() and stringr::str_locate_all(). Use other {stringr} matching rules to find specific patterns. Use regex patterns with base functions such as apropos() and dir() to find things. Describe the relationship between {stringr} and {stringi}. "],["introduction-5.html", "14.1 Introduction", " 14.1 Introduction This chapter is going to be wicked fun!!! Regexs make up the backbone of textual searches. “But can’t I just ctrl + f and search my document? Well, yes…but no… Regular Expressions translate your search into computer code. stringr pkgdown site stringr cheatsheet 14.1.1 Pre-Requisites We will be utilizing the {stringr} package which is part of the core tidyverse. library(tidyverse) "],["string-basics.html", "14.2 String Basics", " 14.2 String Basics You can create strings with either single quotes ' or with double quotes \". The computer doesn’t care. However, which ever you choose, just stick with the format throughout your script. string1 &lt;- &#39;This is also a string, but uses single quotes&#39; string2 &lt;- &quot;This is a string with double quotes&quot; During scripting, if you do not close a string but try to start a new line you will see the + line entry. But how do you quit so you can add the closing quote? Just hit the escape key. &quot;This is a string, but I forgot to close the quote Help, I&#39;m stuck! (Hit the escape key) One of the more tricky things to remember when using regular expressions is the \\ backslash when you literally want to use a special character in a search. doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; print(doublequote) ## [1] &quot;\\&quot;&quot; print(singlequote) ## [1] &quot;&#39;&quot; Evaluating the above makes you question if my environment is correct. Yes it is. By printing to the screen, we are treating the output as a string…confused? To execute this as a regular expression however, we have to use writeLines(). doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; writeLines(doublequote) ## &quot; writeLines(singlequote) ## &#39; There are a handful of other special characters. The most common are \\n, newline, and \\t, tab, but you can see the complete list by requesting help on : ?'\"', or ?\"'\". You’ll also sometimes see strings like \\u00b5, this is a way of writing non-English characters that works on all platforms: x &lt;- &quot;\\u00b5&quot; x ## [1] &quot;µ&quot; y &lt;- &quot;\\U1F44D&quot; y ## [1] &quot;👍&quot; Another way to think “non-English” would be to say these are Unicode values. NOTE: The list is quite extensive (~144K). A better way to state the comment, unicode is inteded to represent the worlds diverse linguistic and lexiconal attributes! Multiple strings are often stored in a character vector, which you can create with c(): c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; 14.2.1 String Length Base R has many functions that can work with String Length. Unfortunetely, these can all be a bit different. Therefore, we are going to use the {stringr} package to maintain our semantics and work within one package…{tidyverse}! All string functions in {stringr} start with the root str_ making use of the package quite intuitive. str_length(c(&quot;a&quot;, &quot;R for Data Science&quot;, NA)) ## [1] 1 18 NA Using the RStudio IDE makes using the autocomplete feature quiet simple This is a excellent way to quickly call on a particular {stringr} function! 14.2.2 Combining Strings To combine two or more strings, use str_c() str_c(&quot;x&quot;, &quot;y&quot;) ## [1] &quot;xy&quot; str_c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) ## [1] &quot;xyz&quot; You can also add the sep argument to control how the strings are seperated. str_c(&quot;x&quot;, &quot;y&quot;, sep = &quot;, &quot;) ## [1] &quot;x, y&quot; Like many other functions in R, if you have missing data, you can add NA. x &lt;- c(&quot;abc&quot;, NA) str_c(&quot;|-&quot;, x, &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; NA str_c(&quot;|-&quot;, str_replace_na(x), &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; &quot;|-NA-|&quot; As shown above, str_c() is vectorised, and it automatically recycles shorter vectors to the same length as the longest: str_c(&quot;prefix-&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;-suffix&quot;) ## [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; I’m unsure if the use of recycle is accurate in the above statement. Another way to view this is a vector list inside a vector list. As the output is sent to the screen, the function acts like a for-loop inside a for-loop where each pass of the inside combination is iterated as combined with the outside combination iteration. Objects of length 0 are silently dropped. This is particularly useful in conjunction with if: name &lt;- &quot;Ryan&quot; time_of_day &lt;- &quot;afternon&quot; birthday &lt;- FALSE str_c( &quot;Good &quot;, time_of_day, &quot; &quot;, name, if (birthday) &quot; and HAPPY BIRTHDAY&quot;, &quot;.&quot; ) ## [1] &quot;Good afternon Ryan.&quot; The above example is written a bit confusing. The object birthday is passed as a boolean value of FALSE and therefore will never evaluate TRUE, making the if statement overhead. Maybe a better way to write the if statement would be to write an argument like sys.date == birthday in which case, if the system date of the computer matches the object birthday, you would get extra text. Finally, if you would like to collapse a vector of strings into a single string, use the collapse argument. str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), collapse = &quot;, &quot;) ## [1] &quot;x, y, z&quot; 14.2.3 Subsetting Strings You can extract parts of a string using str_sub(). As well as the string, str_sub() takes start and end arguments which give the (inclusive) position of the substring: x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, 1, 3) ## [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot; # negative numbers count backwards from end str_sub(x, -3, -1) ## [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot; Note that str_sub() won’t fail if the string is too short: it will just return as much as possible: str_sub(&quot;a&quot;, 1, 5) ## [1] &quot;a&quot; You can also use the assignment form of str_sub() to modify strings: str_sub(x, 1, 1) &lt;- str_to_lower(str_sub(x, 1, 1)) x ## [1] &quot;apple&quot; &quot;banana&quot; &quot;pear&quot; 14.2.4 Locales Alternatives to str_to_lower() is srr_to_upper() and str_to_title(). Changing case is a bit more complicated then it first appears Different languages have different rules for changing case # Turkish has two i&#39;s: with and without a dot, and it # has a different rule for capitalising them: str_to_upper(c(&quot;i&quot;, &quot;ı&quot;)) ## [1] &quot;I&quot; &quot;I&quot; str_to_upper(c(&quot;i&quot;, &quot;ı&quot;), locale = &quot;tr&quot;) ## [1] &quot;İ&quot; &quot;I&quot; Locale is specified as a ISO 639 language code, see Wikipedia Sorting and Order are also effected by Locale Base R only applies the system Locale Using {stringr} adds a local= argument x &lt;- c(&quot;apple&quot;, &quot;eggplant&quot;, &quot;banana&quot;) str_sort(x, locale = &quot;en&quot;) # English ## [1] &quot;apple&quot; &quot;banana&quot; &quot;eggplant&quot; str_sort(x, locale = &quot;haw&quot;) # Hawaiian ## [1] &quot;apple&quot; &quot;eggplant&quot; &quot;banana&quot; 14.2.5 Exercises In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA? paste() converts arguments to character strings and concatenates them. paste0() is the same function but slightly more efficent. The {stringr} they are equivelent to are str_c(). The major difference is the use of as.character() at its base versus {stingr}. The paste() and paste0() changes NA values to “NA”. In your own words, describe the difference between the sep and collapse arguments to str_c(). The sep argument treats each combined string as its own output. Whereas the collapse aregument creates one large string object. Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters? str_length() provides the quantity of characters in a string. str_sub() picks out the beginning and end of out of a vector. If the string has an even number of characters, it will only provide the smaller of the string. What does str_wrap() do? When might you want to use it? str_wrap() uses the Knuth-Plass paragraph wrapping algorithm. Knuth-Plass algorithm. This is important when using typesetting services like LaTeX. What does str_trim() do? What’s the opposite of str_trim()? str_trim() removes extra white space between vectorized strings. str_pad() is the opposite which puts characters back into the string. Write a function that turns (e.g.) a vector c(“a”, “b”, “c”) into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2. z &lt;- str_c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;, &quot;) z ## [1] &quot;a, b, c&quot; # Unsure on the second half of hte question. "],["matching-patterns-with-regular-expressions.html", "14.3 Matching Patterns with Regular Expressions", " 14.3 Matching Patterns with Regular Expressions To learn regular expressions (regexs) we’ll use str_view() and str_view_all(). RegExplain 14.3.1 Basic Matches The simplest expressions are pattern matching: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;an&quot;) NOTE: If you run this locally, the window that opens looks empty. In truth, it is printed “white” on “white” and therefore hard to read. The next step up in complexity is ., which matches any character (except a newline): str_view(x, &quot;.a.&quot;) The trick here is if “.” matches any character…what if we want to search for “.”? We have to escape the term by using “\\”. Yet…this leads to another problem. Since “\\” is part of a string, we have to escape it twice. Therefore, it looks like this: “\\\\.”. # To create the regular expression, we need \\\\ dot &lt;- &quot;\\\\.&quot; # But the expression itself only contains one: writeLines(dot) ## \\. #&gt; \\. # And this tells R to look for an explicit . str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;), &quot;a\\\\.c&quot;) Good, we figured out how to search for periods (.) by using the escape character \\. Ok, but what if we want to search for \\? Hmmmm….we need to “escape the escape”. HA! Therefore, we need four backslashes! “\\\\\\\\”. x &lt;- &quot;a\\\\b&quot; writeLines(x) ## a\\b #&gt; a\\b str_view(x, &quot;\\\\\\\\&quot;) 14.3.1.1 Exercises Explain why each of these strings don’t match a \\: \"\\\", \"\\\\\", \"\\\\\\\". \\ doesn’t escape anything \"\\\" again, is a string and doesn’t escape anything \"\\\\\" escapes the escape, but doesn’t have any pattern to search for \"\\\\\\\" escapes the escape, but doesn’t finish the expression How would you match the sequence \"'\\? Unanswered What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string? Unanswered 14.3.2 Anchors By default, regular expressions will match anywhere in a string. However, if you want the beginning or end of a string, you can “anchor” the regular expression. Lets see how this works: # The following matches anywhere &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a&quot;) Intesting, I thought when searching for “a”, it would highlight every insteance of “a”. So “banana” would hit three times. Nevermind…str_view_all() is required to list ALL instances of a search term. # The following matches only the beginning of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) # The following matches only the end of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) To remember which pattern to use, remember the mnemonic “if you begin with power (^), you end up with money ($). Evan Misshula x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;apple&quot;) str_view(x, &quot;^apple$&quot;) 14.3.2.1 Exercise (Unanswered) How would you match the literal string “$^$”? Given the corpus of common words in stringr::words, create regular expressions that find all words that: Start with “y”. End with “x” Are exactly three letters long. (Don’t cheat by using str_length()!) Have seven letters or more. Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words. 14.3.3 Character Classes and Alternatives There are a number of special patterns that match more than one character. - \\d: matches any digit. - \\s: matches any whitespace (e.g. space, tab, newline). - [abc]: matches a, b, or c. - [^abc]: matches anything except a, b, or c. Remember, to create a regular expression containing \\d or \\s, you’ll need to escape the \\ for the string, so you’ll type “\\\\d” or “\\\\s”. # Look for a literal character that normally has special meaning in a regex str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[.]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;.[*]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[ ]&quot;) This works for most (but not all) regex metacharacters: $ . | ? * + ( ) [ {. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: ] \\ ^ and -. You can also use alternation to pick between one or more alternative patterns. If precedence ever gets confusing, use parentheses to make it clear what you want: str_view(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr(e|a)y&quot;) 14.3.3.1 Exercise (Unanswered) Create regular expressions to find all words that: Start with a vowel. That only contain consonants. (Hint: thinking about matching “not”-vowels.) End with ed, but not with eed. End with ing or ise. Empirically verify the rule “i before e except after c”. Is “q” always followed by a “u”? Write a regular expression that matches a word if it’s probably written in British English, not American English. Create a regular expression that will match telephone numbers as commonly written in your country. 14.3.4 Repetition Controlling how many time a pattern iterates is the next sequence of control. This can be accomplished with the following operators: ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;1888 is the longest year in Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;CC+&quot;) str_view(x, &#39;C[LX]+&#39;) The precedence of these operators is high which means most uses will need parentheses, like bana(na)+. You can also specify the number of matches precisely: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) By default, these form of searches are greedy, which matches the longest string possible. To make them lazy (searching for the shortest string), you can add ? at the end. str_view(x, &#39;C{2,3}?&#39;) str_view(x, &#39;C[LX]+?&#39;) 14.3.4.1 Exercises (Unanswered) Describe the equivalents of ?, +, * in {m,n} form. Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.) ^.*$ \"\\\\{.+\\\\}\" \\d{4}-\\d{2}-\\d{2} \"\\\\\\\\{4}\" Create regular expressions to find all words that: Start with three consonants. Have three or more vowels in a row. c.. Have two or more vowel-consonant pairs in a row. Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner. 14.3.5 Grouping and Backreferences Parentheses also create a numbered capturing group. A capturing group stores the part of the string matched by the part of the regular expression inside the parentheses -You can refer to the same text as previously matched by a capturing group with backreferences For example, the following regular expression finds all fruits that have a repeated pair of letters. str_view(fruit, &quot;(..)\\\\1&quot;, match = TRUE) Dumb question…how does the R Environment know the object fruit? Use the command data() in Console to see all listed datasets in BaseR as well as those included in your loaded packages. For example, fruit is a dataset included with {stringr}. 14.3.5.1 Exercises (Unanswered) Describe, in words, what these expressions will match: (.)\\1\\1 \"(.)(.)\\\\2\\\\1\" (..)\\1 \"(.).\\\\1.\\\\1\" \"(.)(.)(.).*\\\\3\\\\2\\\\1\" Construct regular expressions to match words that: Start and end with the same character. Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.) Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.) "],["tools.html", "14.4 Tools", " 14.4 Tools In this section you’ll learn a wide array of stringr functions that let you: Determine which strings match a pattern Find the positions of matches Extract the content of matches Replace matches with new values Split a string based on a match A word of caution before we continue: because regular expressions are so powerful, it’s easy to try and solve every problem with a single regular expression. In the words of Jamie Zawinski: Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. Exluded unbelievable long expression from presentation! Instead of creating one complex regular expression, it’s often easier to write a series of simpler regexs Quick story: I use regex at work to grep HTML for particular tags. Although I can do ctrl+f…I’d have to do it 1000s of times. Instead, I pass a recursive tag and iterate through the entire project. The process saves me HOURS! Break the problem down to smaller manageable chunks. Use a visual drawing if it helps to write out your expression. The point…don’t start from difficulty first! 14.4.1 Detect Matches To determine if a character vector matches a pattern, use str_detect(). It returns a logical vector the same length as the input: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;e&quot;) ## [1] TRUE FALSE TRUE The use of a boolean output (True/False) means, we can count them! TRUE = 1 FALSE = 0 Makind functions like sum() and mean() useful. # How many common words start with t? sum(str_detect(words, &quot;^t&quot;)) ## [1] 65 # What proportion of common words end with a vowel? mean(str_detect(words, &quot;[aeiou]$&quot;)) ## [1] 0.2765306 When you create large logical conditions, you may be able to break them down to simpler search terms and then combine them together. Always try to start simple. # Find all words containing at least one vowel, and negate no_vowels_1 &lt;- !str_detect(words, &quot;[aeiou]&quot;) # Find all words consisting only of consonants (non-vowels) no_vowels_2 &lt;- str_detect(words, &quot;^[^aeiou]+$&quot;) identical(no_vowels_1, no_vowels_2) ## [1] TRUE A common use of str_detect() is to match a pattern. You can do this with logical sub-setting or the convenient str_subset() wrapper: words[str_detect(words, &quot;x$&quot;)] ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; str_subset(words, &quot;x$&quot;) ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; NOTE, the first example’s syntax is foreign to me. Would any member like to express what is happening? Filter is another tool that can make string detection easier. df &lt;- tibble( word = words, i = seq_along(word) ) df %&gt;% filter(str_detect(word, &quot;x$&quot;)) ## # A tibble: 4 × 2 ## word i ## &lt;chr&gt; &lt;int&gt; ## 1 box 108 ## 2 sex 747 ## 3 six 772 ## 4 tax 841 A variation on str_detect() is str_count(): rather than a simple yes or no, it tells you how many matches there are in a string: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_count(x, &quot;a&quot;) ## [1] 1 3 1 # On average, how many vowels per word? mean(str_count(words, &quot;[aeiou]&quot;)) ## [1] 1.991837 It’s natural to use str_count() with mutate(): df %&gt;% mutate( vowels = str_count(word, &quot;[aeiou]&quot;), consonants = str_count(word, &quot;[^aeiou]&quot;) ) ## # A tibble: 980 × 4 ## word i vowels consonants ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 1 0 ## 2 able 2 2 2 ## 3 about 3 3 2 ## 4 absolute 4 4 4 ## 5 accept 5 2 4 ## 6 account 6 3 4 ## 7 achieve 7 4 3 ## 8 across 8 2 4 ## 9 act 9 1 2 ## 10 active 10 3 3 ## # … with 970 more rows Note that matches never overlap. For example, in “abababa”, how many times will the pattern “aba” match? Regular expressions say two, not three: str_count(&quot;abababa&quot;, &quot;aba&quot;) ## [1] 2 str_view_all(&quot;abababa&quot;, &quot;aba&quot;) Note the use of str_view_all(). As you’ll shortly learn, many stringr functions come in pairs: one function works with a single match, and the other works with all matches. The second function will have the suffix _all. 14.4.1.1 Exercises (Unanswered) For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls. Find all words that start or end with x. Find all words that start with a vowel and end with a consonant. Are there any words that contain at least one of each different vowel? What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?) 14.4.2 Extract Matches Use str_extract() to extract the actual text of a match Harvard Sentences length(sentences) ## [1] 720 head(sentences) ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; ## [6] &quot;The juice of lemons makes fine punch.&quot; Imagine we want to find all sentences that contain a color. Note…I’m changing this section from the British English form colour to the American English form. Create a vector of color names Then turn it into a single regular expression colors &lt;- c(&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;) color_match &lt;- str_c(colors, collapse = &quot;|&quot;) color_match ## [1] &quot;red|orange|yellow|green|blue|purple&quot; Select the sentences that contain a color Extract the color to figure out which one it is has_color &lt;- str_subset(sentences, color_match) matches &lt;- str_extract(has_color, color_match) head(matches) ## [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; Note that str_extract() only extracts the first match. more &lt;- sentences[str_count(sentences, color_match) &gt; 1] str_view_all(more, color_match) str_extract(more, color_match) ## [1] &quot;blue&quot; &quot;green&quot; &quot;orange&quot; To get all matches, use str_extract_all(). str_extract_all(more, color_match) ## [[1]] ## [1] &quot;blue&quot; &quot;red&quot; ## ## [[2]] ## [1] &quot;green&quot; &quot;red&quot; ## ## [[3]] ## [1] &quot;orange&quot; &quot;red&quot; If you pass the argument simplify = TRUE, str_extract_all() will return a matrix with short matches expanded to the same length as the longest. str_extract_all(more, color_match, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;blue&quot; &quot;red&quot; ## [2,] &quot;green&quot; &quot;red&quot; ## [3,] &quot;orange&quot; &quot;red&quot; x &lt;- c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;) str_extract_all(x, &quot;[a-z]&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;a&quot; &quot;b&quot; &quot;&quot; ## [3,] &quot;a&quot; &quot;b&quot; &quot;c&quot; 14.4.2.1 Exercises (Unanswered) In the previous example, you might have noticed that the regular expression matched “flickered”, which is not a colour. Modify the regex to fix the problem. From the Harvard sentences data, extract: The first word from each sentence. All words ending in ing. All plurals. 14.4.3 Grouped Matches Earlier we discussed using parentheses for clarifying precedence and for backreferences. ou can also use parentheses to extract parts of a complex match. noun &lt;- &quot;(a|the) ([^ ]+)&quot; has_noun &lt;- sentences %&gt;% str_subset(noun) %&gt;% head(10) has_noun %&gt;% str_extract(noun) ## [1] &quot;the smooth&quot; &quot;the sheet&quot; &quot;the depth&quot; &quot;a chicken&quot; &quot;the parked&quot; ## [6] &quot;the sun&quot; &quot;the huge&quot; &quot;the ball&quot; &quot;the woman&quot; &quot;a helps&quot; str_extract() gives us the complete match str_match() gives each individual component has_noun %&gt;% str_match(noun) ## [,1] [,2] [,3] ## [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; ## [2,] &quot;the sheet&quot; &quot;the&quot; &quot;sheet&quot; ## [3,] &quot;the depth&quot; &quot;the&quot; &quot;depth&quot; ## [4,] &quot;a chicken&quot; &quot;a&quot; &quot;chicken&quot; ## [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; ## [6,] &quot;the sun&quot; &quot;the&quot; &quot;sun&quot; ## [7,] &quot;the huge&quot; &quot;the&quot; &quot;huge&quot; ## [8,] &quot;the ball&quot; &quot;the&quot; &quot;ball&quot; ## [9,] &quot;the woman&quot; &quot;the&quot; &quot;woman&quot; ## [10,] &quot;a helps&quot; &quot;a&quot; &quot;helps&quot; (Unsurprisingly, our heuristic for detecting nouns is poor, and also picks up adjectives like smooth and parked.) If your data is in a tibble, it’s often easier to use tidyr::extract(). It works like str_match() but requires you to name the matches, which are then placed in new columns. tibble(sentence = sentences) %&gt;% tidyr::extract( sentence, c(&quot;article&quot;, &quot;noun&quot;), &quot;(a|the) ([^ ]+)&quot;, remove = FALSE ) ## # A tibble: 720 × 3 ## sentence article noun ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 The birch canoe slid on the smooth planks. the smooth ## 2 Glue the sheet to the dark blue background. the sheet ## 3 It&#39;s easy to tell the depth of a well. the depth ## 4 These days a chicken leg is a rare dish. a chicken ## 5 Rice is often served in round bowls. &lt;NA&gt; &lt;NA&gt; ## 6 The juice of lemons makes fine punch. &lt;NA&gt; &lt;NA&gt; ## 7 The box was thrown beside the parked truck. the parked ## 8 The hogs were fed chopped corn and garbage. &lt;NA&gt; &lt;NA&gt; ## 9 Four hours of steady work faced us. &lt;NA&gt; &lt;NA&gt; ## 10 Large size in stockings is hard to sell. &lt;NA&gt; &lt;NA&gt; ## # … with 710 more rows If you want all matches for each string, you’ll need str_match_all() 14.4.3.1 Exercises (Unanswered) Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word. Find all contractions. Separate out the pieces before and after the apostrophe. 14.4.4 Replacing Matches str_replace() and str_replace_all() allow you to replace matches with new strings. x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_replace(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-pple&quot; &quot;p-ar&quot; &quot;b-nana&quot; str_replace_all(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-ppl-&quot; &quot;p--r&quot; &quot;b-n-n-&quot; With str_replace_all() you can perform multiple replacements by supplying a named vector x &lt;- c(&quot;1 house&quot;, &quot;2 cars&quot;, &quot;3 people&quot;) str_replace_all(x, c(&quot;1&quot; = &quot;one&quot;, &quot;2&quot; = &quot;two&quot;, &quot;3&quot; = &quot;three&quot;)) ## [1] &quot;one house&quot; &quot;two cars&quot; &quot;three people&quot; Instead of replacing with a fixed string you can use backreferences to insert components of the match. sentences %&gt;% str_replace(&quot;([^ ]+) ([^ ]+) ([^ ]+)&quot;, &quot;\\\\1 \\\\3 \\\\2&quot;) %&gt;% head(5) ## [1] &quot;The canoe birch slid on the smooth planks.&quot; ## [2] &quot;Glue sheet the to the dark blue background.&quot; ## [3] &quot;It&#39;s to easy tell the depth of a well.&quot; ## [4] &quot;These a days chicken leg is a rare dish.&quot; ## [5] &quot;Rice often is served in round bowls.&quot; 14.4.4.1 Exercises (Unanswered) Replace all forward slashes in a string with backslashes. Implement a simple version of str_to_lower() using replace_all(). Switch the first and last letters in words. Which of those strings are still words? 14.4.5 Splitting Use str_split() to split a string up into pieces. sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; If you’re working with a length-1 vector, the easiest thing is to just extract the first element of the list. &quot;a|b|c|d&quot; %&gt;% str_split(&quot;\\\\|&quot;) %&gt;% .[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; You can use simplify = TRUE to return a matrix: sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; &quot;planks.&quot; ## [2,] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## [3,] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; ## [4,] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; &quot;rare&quot; ## [5,] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; &quot;&quot; ## [,9] ## [1,] &quot;&quot; ## [2,] &quot;&quot; ## [3,] &quot;well.&quot; ## [4,] &quot;dish.&quot; ## [5,] &quot;&quot; You can also request a maximum number of pieces fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;, n = 2, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Instead of splitting up strings by patterns, you can also split up by character, line, sentence and word boundary()s. x &lt;- &quot;This is a sentence. This is another sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_split(x, &quot; &quot;)[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence.&quot; &quot;&quot; &quot;This&quot; ## [7] &quot;is&quot; &quot;another&quot; &quot;sentence.&quot; str_split(x, boundary(&quot;word&quot;))[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; &quot;This&quot; &quot;is&quot; &quot;another&quot; ## [8] &quot;sentence&quot; 14.4.5.1 Exercises (Unanswered) Split up a string like \"apples, pears, and bananas\" into individual components. Why is it better to split up by boundary(\"word\") than \" \"? What does splitting with an empty string (\"\") do? Experiment, and then read the documentation. 14.4.6 Find Matches str_locate() and str_locate_all() give you the starting and ending positions of each match. You can use str_locate() to find the matching pattern, str_sub() to extract and/or modify them. "],["other-types-of-pattern.html", "14.5 Other types of Pattern", " 14.5 Other types of Pattern When you use a pattern that’s a string, it’s automatically wrapped into a call to regex(). # The regular call: str_view(fruit, &quot;nana&quot;) # Is shorthand for str_view(fruit, regex(&quot;nana&quot;)) You can use the other arguments of regex() to control details of the match: ignore_case = TRUE allows characters to match either their uppercase or lowercase forms. This always uses the current locale. bananas &lt;- c(&quot;banana&quot;, &quot;Banana&quot;, &quot;BANANA&quot;) str_view(bananas, &quot;banana&quot;) str_view(bananas, regex(&quot;banana&quot;, ignore_case = TRUE)) multiline = TRUE allows ^ and $ to match the start and end of each line rather than the start and end of the complete string. x &lt;- &quot;Line 1\\nLine 2\\nLine 3&quot; str_extract_all(x, &quot;^Line&quot;)[[1]] ## [1] &quot;Line&quot; str_extract_all(x, regex(&quot;^Line&quot;, multiline = TRUE))[[1]] ## [1] &quot;Line&quot; &quot;Line&quot; &quot;Line&quot; comments = TRUE allows you to use comments and white space to make complex regular expressions more understandable. Spaces are ignored, as is everything after #. To match a literal space, you’ll need to escape it: \"\\\\ \". phone &lt;- regex(&quot; \\\\(? # optional opening parens (\\\\d{3}) # area code [) -]? # optional closing parens, space, or dash (\\\\d{3}) # another three numbers [ -]? # optional space or dash (\\\\d{3}) # three more numbers &quot;, comments = TRUE) str_match(&quot;514-791-8141&quot;, phone) ## [,1] [,2] [,3] [,4] ## [1,] &quot;514-791-814&quot; &quot;514&quot; &quot;791&quot; &quot;814&quot; dotall = TRUE allows . to match everything, including \\n. There are three other functions you can use instead of regex(): fixed(): matches exactly the specified sequence of bytes. It ignores all special regular expressions and operates at a very low level. This allows you to avoid complex escaping and can be much faster than regular expressions. Note, I had to install the microbenchmark package before running the next code snippet. #install.packages(&quot;microbenchmark&quot;) library(microbenchmark) microbenchmark::microbenchmark( fixed = str_detect(sentences, fixed(&quot;the&quot;)), regex = str_detect(sentences, &quot;the&quot;), times = 20 ) ## Unit: microseconds ## expr min lq mean median uq max neval ## fixed 58.5 62.70 85.375 79.10 82.60 309.3 20 ## regex 286.1 288.05 312.055 294.55 301.75 591.0 20 Beware using fixed() with non-English data. It is problematic because there are often multiple ways of representing the same character. For example, there are two ways to define “á”: either as a single character or as an “a” plus an accent: a1 &lt;- &quot;\\u00e1&quot; a2 &lt;- &quot;a\\u0301&quot; c(a1, a2) ## [1] &quot;á&quot; &quot;á&quot; a1 == a2 ## [1] FALSE They render identically, but because they’re defined differently, fixed() doesn’t find a match. Instead, you can use coll(), defined next, to respect human character comparison rules: str_detect(a1, fixed(a2)) ## [1] FALSE str_detect(a1, coll(a2)) ## [1] TRUE coll(): compare strings using standard collation rules. This is useful for doing case insensitive matching. Note that coll() takes a locale parameter that controls which rules are used for comparing characters. Unfortunately different parts of the world use different rules! # That means you also need to be aware of the difference # when doing case insensitive matches: i &lt;- c(&quot;I&quot;, &quot;İ&quot;, &quot;i&quot;, &quot;ı&quot;) i ## [1] &quot;I&quot; &quot;İ&quot; &quot;i&quot; &quot;ı&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE)) ## [1] &quot;I&quot; &quot;i&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE, locale = &quot;tr&quot;)) ## [1] &quot;İ&quot; &quot;i&quot; Both fixed() and regex() have ignore_case arguments, but they do not allow you to pick the locale: they always use the default locale. stringi::stri_locale_info() ## $Language ## [1] &quot;c&quot; ## ## $Country ## [1] &quot;&quot; ## ## $Variant ## [1] &quot;&quot; ## ## $Name ## [1] &quot;c&quot; The downside of coll() is speed; because the rules for recognising which characters are the same are complicated, coll() is relatively slow compared to regex() and fixed(). As you saw with str_split() you can use boundary() to match boundaries. You can also use it with the other functions: x &lt;- &quot;This is a sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_extract_all(x, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; 14.5.1 Exercises (Unanswered) How would you find all strings containing \\ with regex() vs. with fixed()? What are the five most common words in sentences? "],["other-uses-of-regular-expressions.html", "14.6 Other uses of regular expressions", " 14.6 Other uses of regular expressions There are two useful function in base R that also use regular expressions: apropos() searches all objects available from the global environment. This is useful if you can’t quite remember the name of the function. apropos(&quot;replace&quot;) ## [1] &quot;%+replace%&quot; &quot;replace&quot; &quot;replace_na&quot; &quot;setReplaceMethod&quot; ## [5] &quot;str_replace&quot; &quot;str_replace_all&quot; &quot;str_replace_na&quot; &quot;theme_replace&quot; dir() lists all the files in a directory. The pattern argument takes a regular expression and only returns file names that match the pattern. head(dir(pattern = &quot;\\\\.Rmd$&quot;)) ## [1] &quot;01-introduction.Rmd&quot; &quot;02--whole_game.Rmd&quot; ## [3] &quot;02-data_visualisation.Rmd&quot; &quot;03-workflow_basics.Rmd&quot; ## [5] &quot;04-data_transformation.Rmd&quot; &quot;05-workflow_pipes.Rmd&quot; If you’re more comfortable with “globs” like *.Rmd, you can convert them to regular expressions with glob2rx() "],["stringi.html", "14.7 stringi", " 14.7 stringi stringr is built on top of the stringi package. stringr is useful when you’re learning because it exposes a minimal set of functions, which have been carefully picked to handle the most common string manipulation functions. stringi, on the other hand, is designed to be comprehensive. It contains almost every function you might ever need: stringi has 250 functions to stringr’s 49. If you find yourself struggling to do something in stringr, it’s worth taking a look at stringi. The packages work very similarly, so you should be able to translate your stringr knowledge in a natural way. The main difference is the prefix: str_ vs. stri_. 14.7.1 Exercises Find the stringi functions that: Count the number of words. Find duplicated strings. 3.Generate random text. How do you control the language that stri_sort() uses for sorting? "],["meeting-videos-13.html", "14.8 Meeting Videos", " 14.8 Meeting Videos 14.8.1 Cohort 5 Meeting chat log 00:10:10 Njoki Njuki Lucy: Hi everyone! 00:10:24 Federica Gazzelloni: Hello! 00:10:31 Sandra Muroy: hi! 00:11:09 Federica Gazzelloni: Hi Sandra! 00:11:27 Sandra Muroy: Hi Federica :D 00:11:43 Sandra Muroy: Hi Lucy! 00:19:20 Jon Harmon (jonthegeek): https://xkcd.com/208/ 00:20:10 Jon Harmon (jonthegeek): https://smltar.com/ is the new book by Julia Silge and Emil Hvitfeldt. 00:20:42 Jon Harmon (jonthegeek): https://www.tidytextmining.com/ is the older Tidytext book by Julia Silge and David Robinson. 00:28:15 Njoki Njuki Lucy: do you also load the packages or that&#39;s sufficient for a readable code? 00:28:59 Jon Harmon (jonthegeek): Within an Rmd I tend to put a library() call per package at the top so it&#39;s easy to find, but in my exploration work I rarely library anything other than magrittr. 00:30:11 Njoki Njuki Lucy: okay, thank you 00:39:53 Jon Harmon (jonthegeek): &gt; x &lt;- r&quot;(this treats all characters as ecaped. For example: \\ &quot; &#39;)&quot; &gt; writeLines(x) this treats all characters as ecaped. For example: \\ &quot; &#39; 00:45:30 Jon Harmon (jonthegeek): \\&quot; 00:45:31 Federica Gazzelloni: textutils: https://github.com/enricoschumann/textutils 00:45:42 Jon Harmon (jonthegeek): &quot;\\&quot;&quot; 00:46:00 Jon Harmon (jonthegeek): &quot;&quot;&quot; 00:46:19 Jon Harmon (jonthegeek): &quot;\\\\&quot; 00:49:07 Jon Harmon (jonthegeek): &gt; &quot;\\&quot; + 00:50:06 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\ttab&quot;) this tab 00:50:21 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\nnewline&quot;) this newline 00:50:40 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\something&quot; Error: &#39;\\s&#39; is an unrecognized escape in character string starting &quot;&quot;this\\s&quot; 00:51:20 Njoki Njuki Lucy: did I get it right that the character after \\ is escaped not printed? 00:51:30 Jon Harmon (jonthegeek): correct 00:51:41 Jon Harmon (jonthegeek): https://regexr.com/ 00:59:49 Jon Harmon (jonthegeek): &gt; str_c(rep(&quot;prefix&quot;, 3), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), rep(&quot;suffix&quot;, 3), sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 01:00:25 Jon Harmon (jonthegeek): &gt; str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 01:01:26 Jon Harmon (jonthegeek): &gt; str_c(c(&quot;prefix&quot;, &quot;other&quot;, &quot;another&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;other-b-suffix&quot; &quot;another-c-suffix&quot; 01:02:02 Jon Harmon (jonthegeek): &gt; str_c(c(&quot;prefix&quot;, &quot;other&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;other-b-suffix&quot; &quot;prefix-c-suffix&quot; Warning message: In stri_c(..., sep = sep, collapse = collapse, ignore_null = TRUE) : longer object length is not a multiple of shorter object length 01:04:54 Jon Harmon (jonthegeek): &gt; str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;, collapse = &quot;|&quot;) [1] &quot;prefix-a-suffix|prefix-b-suffix|prefix-c-suffix&quot; 01:09:51 Njoki Njuki Lucy: thank you so much Ryan and Jon, strings are starting to make sense now! 01:09:53 Sandra Muroy: thanks so much Ryna! 01:09:56 Sandra Muroy: Ryan! Meeting chat log 00:07:40 Jon Harmon (jonthegeek): statlearning.com 00:23:39 Jon Harmon (jonthegeek): ^ = start of text $ = end of text 00:31:17 Jon Harmon (jonthegeek): Notes are finally updated on our site if you want to follow along or review: https://r4ds.github.io/bookclub-r4ds/strings.html 00:31:37 Sandra Muroy: thanks Jon! 00:37:56 Jon Harmon (jonthegeek): https://en.wikipedia.org/wiki/Harvard_sentences 00:42:35 Jon Harmon (jonthegeek): sum(stringr::str_detect(sentences, str_c(words, collapse = &quot;|&quot;), negate = TRUE)) 00:45:50 Jon Harmon (jonthegeek): 1 %in% 1:10 00:46:02 Jon Harmon (jonthegeek): &quot;a&quot; %in% &quot;ab&quot; 00:46:08 Jon Harmon (jonthegeek): &quot;a&quot; 00:46:10 Jon Harmon (jonthegeek): &quot;ab&quot; 00:46:18 Jon Harmon (jonthegeek): &quot;a&quot; %in% c(&quot;a&quot;, &quot;b&quot;) 01:02:39 Jon Harmon (jonthegeek): regexr.com 14.8.2 Cohort 6 Meeting chat log 00:09:53 Daniel Adereti: We will kick off in 1 min 00:14:55 Shannon: https://r4ds.github.io/bookclub-r4ds/string-basics.html 00:18:48 Shannon: https://stringr.tidyverse.org/ 00:19:06 Shannon: https://github.com/rstudio/cheatsheets/blob/main/strings.pdf 00:21:02 Daniel Adereti: For new members, we have this sheet where we volunteer to take classes each week, you are welcome to fill in your names. Thanks! https://docs.google.com/spreadsheets/d/1zy2nXNkvcdqWuF8rQ5ApWRkVQG_UJt0azu3h_mEnY2E/edit?usp=drive_web&amp;ouid=115626840160043101981 00:26:49 Shannon: https://en.wikipedia.org/wiki/List_of_Unicode_characters 01:05:02 Daniel Adereti: That&#39;s fine! 01:05:13 Daniel Adereti: We can pick up next week 01:05:37 Adeyemi Olusola: Thank you! 01:05:45 Folashade Bayode: Thank you 😊 Meeting chat log 00:15:15 Daniel Adereti: We have this nice book that solves the exercises, if you are interested: https://jrnold.github.io/r4ds-exercise-solutions/strings.html 00:15:35 Marielena Soilemezidi: awesome, thanks Daniel! :) 00:22:13 Marielena Soilemezidi: the book has the same solution for this, so you did great actually! :) 00:36:42 Shannon: https://regexcrossword.com/challenges/beginner 00:37:04 Marielena Soilemezidi: ooh cool! 00:37:10 Marielena Soilemezidi: thanks Shannon! 00:43:17 Marielena Soilemezidi: 0.0 00:43:26 Marielena Soilemezidi: who thought of this example?! 00:52:47 Daniel Adereti: Hey Marielena, if you want to volunteer for a class, you can fill in your name here: https://docs.google.com/spreadsheets/d/1zy2nXNkvcdqWuF8rQ5ApWRkVQG_UJt0azu3h_mEnY2E/edit#gid=0 00:55:10 Marielena Soilemezidi: Thanks, Daniel! I&#39;ll check the next available chapters :) Meeting chat log 00:03:15 Adeyemi Olusola: Good day! 00:04:23 Adeyemi Olusola: That sounds perfect 00:48:27 Adeyemi Olusola: I have to drop off now. Thanks Shannon for the wonderful presentation! 00:49:28 Marielena Soilemezidi: oh, cool! :) 00:50:24 Marielena Soilemezidi: haha yaay! 00:51:47 Marielena Soilemezidi: weird! "],["regular-expressions.html", "Chapter 15 Regular expressions", " Chapter 15 Regular expressions Note: Since these slides were made, this chapter has been split into “Strings” and “Regular expressions”. After you edit these slides, remove this note. Learning objectives: Manipulate character vectors using simple {stringr} functions. Use regular expressions (regex) to match patterns in strings. Use regex to match simple characters, ., and \\. Use regex ^, $, and \\b to match anchors and boundaries. Use regex \\d, \\s, [], and [^] to match character classes. Use regex | and () to match alternatives. Use regex ?, +, *, {n}, {n,}, {,m}, and {n, m} to match repetitions in patterns. Use regex grouping and backreferences to refer to previous matches. Use {stringr} functions and regex to manipulate strings. Detect pattern matches with stringr::str_detect(). Select subsets of strings that match a pattern with stringr::str_subset(). Count pattern matches with stringr::str_count(). Extract pattern matches with stringr::str_extract() and stringr::str_extract_all(). Extract group matches with stringr::str_match(), stringr::str_match_all(), and tidyr::extract(). Replace pattern matches with stringr::str_replace() and stringr::str_replace_all(). Split strings into pieces with stringr::str_split() and stringr::boundary(). Locate matches within a string with stringr::str_locate() and stringr::str_locate_all(). Use other {stringr} matching rules to find specific patterns. Use regex patterns with base functions such as apropos() and dir() to find things. Describe the relationship between {stringr} and {stringi}. "],["introduction-6.html", "15.1 Introduction", " 15.1 Introduction This chapter is going to be wicked fun!!! Regexs make up the backbone of textual searches. “But can’t I just ctrl + f and search my document? Well, yes…but no… Regular Expressions translate your search into computer code. stringr pkgdown site stringr cheatsheet 15.1.1 Pre-Requisites We will be utilizing the {stringr} package which is part of the core tidyverse. library(tidyverse) "],["string-basics-1.html", "15.2 String Basics", " 15.2 String Basics You can create strings with either single quotes ' or with double quotes \". The computer doesn’t care. However, which ever you choose, just stick with the format throughout your script. string1 &lt;- &#39;This is also a string, but uses single quotes&#39; string2 &lt;- &quot;This is a string with double quotes&quot; During scripting, if you do not close a string but try to start a new line you will see the + line entry. But how do you quit so you can add the closing quote? Just hit the escape key. &quot;This is a string, but I forgot to close the quote Help, I&#39;m stuck! (Hit the escape key) One of the more tricky things to remember when using regular expressions is the \\ backslash when you literally want to use a special character in a search. doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; print(doublequote) ## [1] &quot;\\&quot;&quot; print(singlequote) ## [1] &quot;&#39;&quot; Evaluating the above makes you question if my environment is correct. Yes it is. By printing to the screen, we are treating the output as a string…confused? To execute this as a regular expression however, we have to use writeLines(). doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; writeLines(doublequote) ## &quot; writeLines(singlequote) ## &#39; There are a handful of other special characters. The most common are \\n, newline, and \\t, tab, but you can see the complete list by requesting help on : ?'\"', or ?\"'\". You’ll also sometimes see strings like \\u00b5, this is a way of writing non-English characters that works on all platforms: x &lt;- &quot;\\u00b5&quot; x ## [1] &quot;µ&quot; y &lt;- &quot;\\U1F44D&quot; y ## [1] &quot;👍&quot; Another way to think “non-English” would be to say these are Unicode values. NOTE: The list is quite extensive (~144K). A better way to state the comment, unicode is inteded to represent the worlds diverse linguistic and lexiconal attributes! Multiple strings are often stored in a character vector, which you can create with c(): c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; 15.2.1 String Length Base R has many functions that can work with String Length. Unfortunetely, these can all be a bit different. Therefore, we are going to use the {stringr} package to maintain our semantics and work within one package…{tidyverse}! All string functions in {stringr} start with the root str_ making use of the package quite intuitive. str_length(c(&quot;a&quot;, &quot;R for Data Science&quot;, NA)) ## [1] 1 18 NA Using the RStudio IDE makes using the autocomplete feature quiet simple This is a excellent way to quickly call on a particular {stringr} function! 15.2.2 Combining Strings To combine two or more strings, use str_c() str_c(&quot;x&quot;, &quot;y&quot;) ## [1] &quot;xy&quot; str_c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) ## [1] &quot;xyz&quot; You can also add the sep argument to control how the strings are seperated. str_c(&quot;x&quot;, &quot;y&quot;, sep = &quot;, &quot;) ## [1] &quot;x, y&quot; Like many other functions in R, if you have missing data, you can add NA. x &lt;- c(&quot;abc&quot;, NA) str_c(&quot;|-&quot;, x, &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; NA str_c(&quot;|-&quot;, str_replace_na(x), &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; &quot;|-NA-|&quot; As shown above, str_c() is vectorised, and it automatically recycles shorter vectors to the same length as the longest: str_c(&quot;prefix-&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;-suffix&quot;) ## [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; I’m unsure if the use of recycle is accurate in the above statement. Another way to view this is a vector list inside a vector list. As the output is sent to the screen, the function acts like a for-loop inside a for-loop where each pass of the inside combination is iterated as combined with the outside combination iteration. Objects of length 0 are silently dropped. This is particularly useful in conjunction with if: name &lt;- &quot;Ryan&quot; time_of_day &lt;- &quot;afternon&quot; birthday &lt;- FALSE str_c( &quot;Good &quot;, time_of_day, &quot; &quot;, name, if (birthday) &quot; and HAPPY BIRTHDAY&quot;, &quot;.&quot; ) ## [1] &quot;Good afternon Ryan.&quot; The above example is written a bit confusing. The object birthday is passed as a boolean value of FALSE and therefore will never evaluate TRUE, making the if statement overhead. Maybe a better way to write the if statement would be to write an argument like sys.date == birthday in which case, if the system date of the computer matches the object birthday, you would get extra text. Finally, if you would like to collapse a vector of strings into a single string, use the collapse argument. str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), collapse = &quot;, &quot;) ## [1] &quot;x, y, z&quot; 15.2.3 Subsetting Strings You can extract parts of a string using str_sub(). As well as the string, str_sub() takes start and end arguments which give the (inclusive) position of the substring: x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, 1, 3) ## [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot; # negative numbers count backwards from end str_sub(x, -3, -1) ## [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot; Note that str_sub() won’t fail if the string is too short: it will just return as much as possible: str_sub(&quot;a&quot;, 1, 5) ## [1] &quot;a&quot; You can also use the assignment form of str_sub() to modify strings: str_sub(x, 1, 1) &lt;- str_to_lower(str_sub(x, 1, 1)) x ## [1] &quot;apple&quot; &quot;banana&quot; &quot;pear&quot; 15.2.4 Locales Alternatives to str_to_lower() is srr_to_upper() and str_to_title(). Changing case is a bit more complicated then it first appears Different languages have different rules for changing case # Turkish has two i&#39;s: with and without a dot, and it # has a different rule for capitalising them: str_to_upper(c(&quot;i&quot;, &quot;ı&quot;)) ## [1] &quot;I&quot; &quot;I&quot; str_to_upper(c(&quot;i&quot;, &quot;ı&quot;), locale = &quot;tr&quot;) ## [1] &quot;İ&quot; &quot;I&quot; Locale is specified as a ISO 639 language code, see Wikipedia Sorting and Order are also effected by Locale Base R only applies the system Locale Using {stringr} adds a local= argument x &lt;- c(&quot;apple&quot;, &quot;eggplant&quot;, &quot;banana&quot;) str_sort(x, locale = &quot;en&quot;) # English ## [1] &quot;apple&quot; &quot;banana&quot; &quot;eggplant&quot; str_sort(x, locale = &quot;haw&quot;) # Hawaiian ## [1] &quot;apple&quot; &quot;eggplant&quot; &quot;banana&quot; 15.2.5 Exercises In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA? paste() converts arguments to character strings and concatenates them. paste0() is the same function but slightly more efficent. The {stringr} they are equivelent to are str_c(). The major difference is the use of as.character() at its base versus {stingr}. The paste() and paste0() changes NA values to “NA”. In your own words, describe the difference between the sep and collapse arguments to str_c(). The sep argument treats each combined string as its own output. Whereas the collapse aregument creates one large string object. Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters? str_length() provides the quantity of characters in a string. str_sub() picks out the beginning and end of out of a vector. If the string has an even number of characters, it will only provide the smaller of the string. What does str_wrap() do? When might you want to use it? str_wrap() uses the Knuth-Plass paragraph wrapping algorithm. Knuth-Plass algorithm. This is important when using typesetting services like LaTeX. What does str_trim() do? What’s the opposite of str_trim()? str_trim() removes extra white space between vectorized strings. str_pad() is the opposite which puts characters back into the string. Write a function that turns (e.g.) a vector c(“a”, “b”, “c”) into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2. z &lt;- str_c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;, &quot;) z ## [1] &quot;a, b, c&quot; # Unsure on the second half of hte question. "],["matching-patterns-with-regular-expressions-1.html", "15.3 Matching Patterns with Regular Expressions", " 15.3 Matching Patterns with Regular Expressions To learn regular expressions (regexs) we’ll use str_view() and str_view_all(). RegExplain 15.3.1 Basic Matches The simplest expressions are pattern matching: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;an&quot;) NOTE: If you run this locally, the window that opens looks empty. In truth, it is printed “white” on “white” and therefore hard to read. The next step up in complexity is ., which matches any character (except a newline): str_view(x, &quot;.a.&quot;) The trick here is if “.” matches any character…what if we want to search for “.”? We have to escape the term by using “\\”. Yet…this leads to another problem. Since “\\” is part of a string, we have to escape it twice. Therefore, it looks like this: “\\\\.”. # To create the regular expression, we need \\\\ dot &lt;- &quot;\\\\.&quot; # But the expression itself only contains one: writeLines(dot) ## \\. #&gt; \\. # And this tells R to look for an explicit . str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;), &quot;a\\\\.c&quot;) Good, we figured out how to search for periods (.) by using the escape character \\. Ok, but what if we want to search for \\? Hmmmm….we need to “escape the escape”. HA! Therefore, we need four backslashes! “\\\\\\\\”. x &lt;- &quot;a\\\\b&quot; writeLines(x) ## a\\b #&gt; a\\b str_view(x, &quot;\\\\\\\\&quot;) 15.3.1.1 Exercises Explain why each of these strings don’t match a \\: \"\\\", \"\\\\\", \"\\\\\\\". \\ doesn’t escape anything \"\\\" again, is a string and doesn’t escape anything \"\\\\\" escapes the escape, but doesn’t have any pattern to search for \"\\\\\\\" escapes the escape, but doesn’t finish the expression How would you match the sequence \"'\\? Unanswered What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string? Unanswered 15.3.2 Anchors By default, regular expressions will match anywhere in a string. However, if you want the beginning or end of a string, you can “anchor” the regular expression. Lets see how this works: # The following matches anywhere &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a&quot;) Intesting, I thought when searching for “a”, it would highlight every insteance of “a”. So “banana” would hit three times. Nevermind…str_view_all() is required to list ALL instances of a search term. # The following matches only the beginning of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) # The following matches only the end of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) To remember which pattern to use, remember the mnemonic “if you begin with power (^), you end up with money ($). Evan Misshula x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;apple&quot;) str_view(x, &quot;^apple$&quot;) 15.3.2.1 Exercise (Unanswered) How would you match the literal string “$^$”? Given the corpus of common words in stringr::words, create regular expressions that find all words that: Start with “y”. End with “x” Are exactly three letters long. (Don’t cheat by using str_length()!) Have seven letters or more. Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words. 15.3.3 Character Classes and Alternatives There are a number of special patterns that match more than one character. - \\d: matches any digit. - \\s: matches any whitespace (e.g. space, tab, newline). - [abc]: matches a, b, or c. - [^abc]: matches anything except a, b, or c. Remember, to create a regular expression containing \\d or \\s, you’ll need to escape the \\ for the string, so you’ll type “\\\\d” or “\\\\s”. # Look for a literal character that normally has special meaning in a regex str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[.]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;.[*]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[ ]&quot;) This works for most (but not all) regex metacharacters: $ . | ? * + ( ) [ {. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: ] \\ ^ and -. You can also use alternation to pick between one or more alternative patterns. If precedence ever gets confusing, use parentheses to make it clear what you want: str_view(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr(e|a)y&quot;) 15.3.3.1 Exercise (Unanswered) Create regular expressions to find all words that: Start with a vowel. That only contain consonants. (Hint: thinking about matching “not”-vowels.) End with ed, but not with eed. End with ing or ise. Empirically verify the rule “i before e except after c”. Is “q” always followed by a “u”? Write a regular expression that matches a word if it’s probably written in British English, not American English. Create a regular expression that will match telephone numbers as commonly written in your country. 15.3.4 Repetition Controlling how many time a pattern iterates is the next sequence of control. This can be accomplished with the following operators: ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;1888 is the longest year in Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;CC+&quot;) str_view(x, &#39;C[LX]+&#39;) The precedence of these operators is high which means most uses will need parentheses, like bana(na)+. You can also specify the number of matches precisely: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) By default, these form of searches are greedy, which matches the longest string possible. To make them lazy (searching for the shortest string), you can add ? at the end. str_view(x, &#39;C{2,3}?&#39;) str_view(x, &#39;C[LX]+?&#39;) 15.3.4.1 Exercises (Unanswered) Describe the equivalents of ?, +, * in {m,n} form. Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.) ^.*$ \"\\\\{.+\\\\}\" \\d{4}-\\d{2}-\\d{2} \"\\\\\\\\{4}\" Create regular expressions to find all words that: Start with three consonants. Have three or more vowels in a row. c.. Have two or more vowel-consonant pairs in a row. Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner. 15.3.5 Grouping and Backreferences Parentheses also create a numbered capturing group. A capturing group stores the part of the string matched by the part of the regular expression inside the parentheses -You can refer to the same text as previously matched by a capturing group with backreferences For example, the following regular expression finds all fruits that have a repeated pair of letters. str_view(fruit, &quot;(..)\\\\1&quot;, match = TRUE) Dumb question…how does the R Environment know the object fruit? Use the command data() in Console to see all listed datasets in BaseR as well as those included in your loaded packages. For example, fruit is a dataset included with {stringr}. 15.3.5.1 Exercises (Unanswered) Describe, in words, what these expressions will match: (.)\\1\\1 \"(.)(.)\\\\2\\\\1\" (..)\\1 \"(.).\\\\1.\\\\1\" \"(.)(.)(.).*\\\\3\\\\2\\\\1\" Construct regular expressions to match words that: Start and end with the same character. Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.) Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.) "],["tools-1.html", "15.4 Tools", " 15.4 Tools In this section you’ll learn a wide array of stringr functions that let you: Determine which strings match a pattern Find the positions of matches Extract the content of matches Replace matches with new values Split a string based on a match A word of caution before we continue: because regular expressions are so powerful, it’s easy to try and solve every problem with a single regular expression. In the words of Jamie Zawinski: Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. Exluded unbelievable long expression from presentation! Instead of creating one complex regular expression, it’s often easier to write a series of simpler regexs Quick story: I use regex at work to grep HTML for particular tags. Although I can do ctrl+f…I’d have to do it 1000s of times. Instead, I pass a recursive tag and iterate through the entire project. The process saves me HOURS! Break the problem down to smaller manageable chunks. Use a visual drawing if it helps to write out your expression. The point…don’t start from difficulty first! 15.4.1 Detect Matches To determine if a character vector matches a pattern, use str_detect(). It returns a logical vector the same length as the input: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;e&quot;) ## [1] TRUE FALSE TRUE The use of a boolean output (True/False) means, we can count them! TRUE = 1 FALSE = 0 Makind functions like sum() and mean() useful. # How many common words start with t? sum(str_detect(words, &quot;^t&quot;)) ## [1] 65 # What proportion of common words end with a vowel? mean(str_detect(words, &quot;[aeiou]$&quot;)) ## [1] 0.2765306 When you create large logical conditions, you may be able to break them down to simpler search terms and then combine them together. Always try to start simple. # Find all words containing at least one vowel, and negate no_vowels_1 &lt;- !str_detect(words, &quot;[aeiou]&quot;) # Find all words consisting only of consonants (non-vowels) no_vowels_2 &lt;- str_detect(words, &quot;^[^aeiou]+$&quot;) identical(no_vowels_1, no_vowels_2) ## [1] TRUE A common use of str_detect() is to match a pattern. You can do this with logical sub-setting or the convenient str_subset() wrapper: words[str_detect(words, &quot;x$&quot;)] ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; str_subset(words, &quot;x$&quot;) ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; NOTE, the first example’s syntax is foreign to me. Would any member like to express what is happening? Filter is another tool that can make string detection easier. df &lt;- tibble( word = words, i = seq_along(word) ) df %&gt;% filter(str_detect(word, &quot;x$&quot;)) ## # A tibble: 4 × 2 ## word i ## &lt;chr&gt; &lt;int&gt; ## 1 box 108 ## 2 sex 747 ## 3 six 772 ## 4 tax 841 A variation on str_detect() is str_count(): rather than a simple yes or no, it tells you how many matches there are in a string: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_count(x, &quot;a&quot;) ## [1] 1 3 1 # On average, how many vowels per word? mean(str_count(words, &quot;[aeiou]&quot;)) ## [1] 1.991837 It’s natural to use str_count() with mutate(): df %&gt;% mutate( vowels = str_count(word, &quot;[aeiou]&quot;), consonants = str_count(word, &quot;[^aeiou]&quot;) ) ## # A tibble: 980 × 4 ## word i vowels consonants ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 1 0 ## 2 able 2 2 2 ## 3 about 3 3 2 ## 4 absolute 4 4 4 ## 5 accept 5 2 4 ## 6 account 6 3 4 ## 7 achieve 7 4 3 ## 8 across 8 2 4 ## 9 act 9 1 2 ## 10 active 10 3 3 ## # … with 970 more rows Note that matches never overlap. For example, in “abababa”, how many times will the pattern “aba” match? Regular expressions say two, not three: str_count(&quot;abababa&quot;, &quot;aba&quot;) ## [1] 2 str_view_all(&quot;abababa&quot;, &quot;aba&quot;) Note the use of str_view_all(). As you’ll shortly learn, many stringr functions come in pairs: one function works with a single match, and the other works with all matches. The second function will have the suffix _all. 15.4.1.1 Exercises (Unanswered) For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls. Find all words that start or end with x. Find all words that start with a vowel and end with a consonant. Are there any words that contain at least one of each different vowel? What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?) 15.4.2 Extract Matches Use str_extract() to extract the actual text of a match Harvard Sentences length(sentences) ## [1] 720 head(sentences) ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; ## [6] &quot;The juice of lemons makes fine punch.&quot; Imagine we want to find all sentences that contain a color. Note…I’m changing this section from the British English form colour to the American English form. Create a vector of color names Then turn it into a single regular expression colors &lt;- c(&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;) color_match &lt;- str_c(colors, collapse = &quot;|&quot;) color_match ## [1] &quot;red|orange|yellow|green|blue|purple&quot; Select the sentences that contain a color Extract the color to figure out which one it is has_color &lt;- str_subset(sentences, color_match) matches &lt;- str_extract(has_color, color_match) head(matches) ## [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; Note that str_extract() only extracts the first match. more &lt;- sentences[str_count(sentences, color_match) &gt; 1] str_view_all(more, color_match) str_extract(more, color_match) ## [1] &quot;blue&quot; &quot;green&quot; &quot;orange&quot; To get all matches, use str_extract_all(). str_extract_all(more, color_match) ## [[1]] ## [1] &quot;blue&quot; &quot;red&quot; ## ## [[2]] ## [1] &quot;green&quot; &quot;red&quot; ## ## [[3]] ## [1] &quot;orange&quot; &quot;red&quot; If you pass the argument simplify = TRUE, str_extract_all() will return a matrix with short matches expanded to the same length as the longest. str_extract_all(more, color_match, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;blue&quot; &quot;red&quot; ## [2,] &quot;green&quot; &quot;red&quot; ## [3,] &quot;orange&quot; &quot;red&quot; x &lt;- c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;) str_extract_all(x, &quot;[a-z]&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;a&quot; &quot;b&quot; &quot;&quot; ## [3,] &quot;a&quot; &quot;b&quot; &quot;c&quot; 15.4.2.1 Exercises (Unanswered) In the previous example, you might have noticed that the regular expression matched “flickered”, which is not a colour. Modify the regex to fix the problem. From the Harvard sentences data, extract: The first word from each sentence. All words ending in ing. All plurals. 15.4.3 Grouped Matches Earlier we discussed using parentheses for clarifying precedence and for backreferences. ou can also use parentheses to extract parts of a complex match. noun &lt;- &quot;(a|the) ([^ ]+)&quot; has_noun &lt;- sentences %&gt;% str_subset(noun) %&gt;% head(10) has_noun %&gt;% str_extract(noun) ## [1] &quot;the smooth&quot; &quot;the sheet&quot; &quot;the depth&quot; &quot;a chicken&quot; &quot;the parked&quot; ## [6] &quot;the sun&quot; &quot;the huge&quot; &quot;the ball&quot; &quot;the woman&quot; &quot;a helps&quot; str_extract() gives us the complete match str_match() gives each individual component has_noun %&gt;% str_match(noun) ## [,1] [,2] [,3] ## [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; ## [2,] &quot;the sheet&quot; &quot;the&quot; &quot;sheet&quot; ## [3,] &quot;the depth&quot; &quot;the&quot; &quot;depth&quot; ## [4,] &quot;a chicken&quot; &quot;a&quot; &quot;chicken&quot; ## [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; ## [6,] &quot;the sun&quot; &quot;the&quot; &quot;sun&quot; ## [7,] &quot;the huge&quot; &quot;the&quot; &quot;huge&quot; ## [8,] &quot;the ball&quot; &quot;the&quot; &quot;ball&quot; ## [9,] &quot;the woman&quot; &quot;the&quot; &quot;woman&quot; ## [10,] &quot;a helps&quot; &quot;a&quot; &quot;helps&quot; (Unsurprisingly, our heuristic for detecting nouns is poor, and also picks up adjectives like smooth and parked.) If your data is in a tibble, it’s often easier to use tidyr::extract(). It works like str_match() but requires you to name the matches, which are then placed in new columns. tibble(sentence = sentences) %&gt;% tidyr::extract( sentence, c(&quot;article&quot;, &quot;noun&quot;), &quot;(a|the) ([^ ]+)&quot;, remove = FALSE ) ## # A tibble: 720 × 3 ## sentence article noun ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 The birch canoe slid on the smooth planks. the smooth ## 2 Glue the sheet to the dark blue background. the sheet ## 3 It&#39;s easy to tell the depth of a well. the depth ## 4 These days a chicken leg is a rare dish. a chicken ## 5 Rice is often served in round bowls. &lt;NA&gt; &lt;NA&gt; ## 6 The juice of lemons makes fine punch. &lt;NA&gt; &lt;NA&gt; ## 7 The box was thrown beside the parked truck. the parked ## 8 The hogs were fed chopped corn and garbage. &lt;NA&gt; &lt;NA&gt; ## 9 Four hours of steady work faced us. &lt;NA&gt; &lt;NA&gt; ## 10 Large size in stockings is hard to sell. &lt;NA&gt; &lt;NA&gt; ## # … with 710 more rows If you want all matches for each string, you’ll need str_match_all() 15.4.3.1 Exercises (Unanswered) Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word. Find all contractions. Separate out the pieces before and after the apostrophe. 15.4.4 Replacing Matches str_replace() and str_replace_all() allow you to replace matches with new strings. x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_replace(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-pple&quot; &quot;p-ar&quot; &quot;b-nana&quot; str_replace_all(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-ppl-&quot; &quot;p--r&quot; &quot;b-n-n-&quot; With str_replace_all() you can perform multiple replacements by supplying a named vector x &lt;- c(&quot;1 house&quot;, &quot;2 cars&quot;, &quot;3 people&quot;) str_replace_all(x, c(&quot;1&quot; = &quot;one&quot;, &quot;2&quot; = &quot;two&quot;, &quot;3&quot; = &quot;three&quot;)) ## [1] &quot;one house&quot; &quot;two cars&quot; &quot;three people&quot; Instead of replacing with a fixed string you can use backreferences to insert components of the match. sentences %&gt;% str_replace(&quot;([^ ]+) ([^ ]+) ([^ ]+)&quot;, &quot;\\\\1 \\\\3 \\\\2&quot;) %&gt;% head(5) ## [1] &quot;The canoe birch slid on the smooth planks.&quot; ## [2] &quot;Glue sheet the to the dark blue background.&quot; ## [3] &quot;It&#39;s to easy tell the depth of a well.&quot; ## [4] &quot;These a days chicken leg is a rare dish.&quot; ## [5] &quot;Rice often is served in round bowls.&quot; 15.4.4.1 Exercises (Unanswered) Replace all forward slashes in a string with backslashes. Implement a simple version of str_to_lower() using replace_all(). Switch the first and last letters in words. Which of those strings are still words? 15.4.5 Splitting Use str_split() to split a string up into pieces. sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; If you’re working with a length-1 vector, the easiest thing is to just extract the first element of the list. &quot;a|b|c|d&quot; %&gt;% str_split(&quot;\\\\|&quot;) %&gt;% .[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; You can use simplify = TRUE to return a matrix: sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; &quot;planks.&quot; ## [2,] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## [3,] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; ## [4,] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; &quot;rare&quot; ## [5,] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; &quot;&quot; ## [,9] ## [1,] &quot;&quot; ## [2,] &quot;&quot; ## [3,] &quot;well.&quot; ## [4,] &quot;dish.&quot; ## [5,] &quot;&quot; You can also request a maximum number of pieces fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;, n = 2, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Instead of splitting up strings by patterns, you can also split up by character, line, sentence and word boundary()s. x &lt;- &quot;This is a sentence. This is another sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_split(x, &quot; &quot;)[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence.&quot; &quot;&quot; &quot;This&quot; ## [7] &quot;is&quot; &quot;another&quot; &quot;sentence.&quot; str_split(x, boundary(&quot;word&quot;))[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; &quot;This&quot; &quot;is&quot; &quot;another&quot; ## [8] &quot;sentence&quot; 15.4.5.1 Exercises (Unanswered) Split up a string like \"apples, pears, and bananas\" into individual components. Why is it better to split up by boundary(\"word\") than \" \"? What does splitting with an empty string (\"\") do? Experiment, and then read the documentation. 15.4.6 Find Matches str_locate() and str_locate_all() give you the starting and ending positions of each match. You can use str_locate() to find the matching pattern, str_sub() to extract and/or modify them. "],["other-types-of-pattern-1.html", "15.5 Other types of Pattern", " 15.5 Other types of Pattern When you use a pattern that’s a string, it’s automatically wrapped into a call to regex(). # The regular call: str_view(fruit, &quot;nana&quot;) # Is shorthand for str_view(fruit, regex(&quot;nana&quot;)) You can use the other arguments of regex() to control details of the match: ignore_case = TRUE allows characters to match either their uppercase or lowercase forms. This always uses the current locale. bananas &lt;- c(&quot;banana&quot;, &quot;Banana&quot;, &quot;BANANA&quot;) str_view(bananas, &quot;banana&quot;) str_view(bananas, regex(&quot;banana&quot;, ignore_case = TRUE)) multiline = TRUE allows ^ and $ to match the start and end of each line rather than the start and end of the complete string. x &lt;- &quot;Line 1\\nLine 2\\nLine 3&quot; str_extract_all(x, &quot;^Line&quot;)[[1]] ## [1] &quot;Line&quot; str_extract_all(x, regex(&quot;^Line&quot;, multiline = TRUE))[[1]] ## [1] &quot;Line&quot; &quot;Line&quot; &quot;Line&quot; comments = TRUE allows you to use comments and white space to make complex regular expressions more understandable. Spaces are ignored, as is everything after #. To match a literal space, you’ll need to escape it: \"\\\\ \". phone &lt;- regex(&quot; \\\\(? # optional opening parens (\\\\d{3}) # area code [) -]? # optional closing parens, space, or dash (\\\\d{3}) # another three numbers [ -]? # optional space or dash (\\\\d{3}) # three more numbers &quot;, comments = TRUE) str_match(&quot;514-791-8141&quot;, phone) ## [,1] [,2] [,3] [,4] ## [1,] &quot;514-791-814&quot; &quot;514&quot; &quot;791&quot; &quot;814&quot; dotall = TRUE allows . to match everything, including \\n. There are three other functions you can use instead of regex(): fixed(): matches exactly the specified sequence of bytes. It ignores all special regular expressions and operates at a very low level. This allows you to avoid complex escaping and can be much faster than regular expressions. Note, I had to install the microbenchmark package before running the next code snippet. #install.packages(&quot;microbenchmark&quot;) library(microbenchmark) microbenchmark::microbenchmark( fixed = str_detect(sentences, fixed(&quot;the&quot;)), regex = str_detect(sentences, &quot;the&quot;), times = 20 ) ## Unit: microseconds ## expr min lq mean median uq max neval ## fixed 57.7 60.2 75.70 73.40 82.85 145.5 20 ## regex 287.4 289.9 321.76 295.35 302.20 795.5 20 Beware using fixed() with non-English data. It is problematic because there are often multiple ways of representing the same character. For example, there are two ways to define “á”: either as a single character or as an “a” plus an accent: a1 &lt;- &quot;\\u00e1&quot; a2 &lt;- &quot;a\\u0301&quot; c(a1, a2) ## [1] &quot;á&quot; &quot;á&quot; a1 == a2 ## [1] FALSE They render identically, but because they’re defined differently, fixed() doesn’t find a match. Instead, you can use coll(), defined next, to respect human character comparison rules: str_detect(a1, fixed(a2)) ## [1] FALSE str_detect(a1, coll(a2)) ## [1] TRUE coll(): compare strings using standard collation rules. This is useful for doing case insensitive matching. Note that coll() takes a locale parameter that controls which rules are used for comparing characters. Unfortunately different parts of the world use different rules! # That means you also need to be aware of the difference # when doing case insensitive matches: i &lt;- c(&quot;I&quot;, &quot;İ&quot;, &quot;i&quot;, &quot;ı&quot;) i ## [1] &quot;I&quot; &quot;İ&quot; &quot;i&quot; &quot;ı&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE)) ## [1] &quot;I&quot; &quot;i&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE, locale = &quot;tr&quot;)) ## [1] &quot;İ&quot; &quot;i&quot; Both fixed() and regex() have ignore_case arguments, but they do not allow you to pick the locale: they always use the default locale. stringi::stri_locale_info() ## $Language ## [1] &quot;c&quot; ## ## $Country ## [1] &quot;&quot; ## ## $Variant ## [1] &quot;&quot; ## ## $Name ## [1] &quot;c&quot; The downside of coll() is speed; because the rules for recognising which characters are the same are complicated, coll() is relatively slow compared to regex() and fixed(). As you saw with str_split() you can use boundary() to match boundaries. You can also use it with the other functions: x &lt;- &quot;This is a sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_extract_all(x, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; 15.5.1 Exercises (Unanswered) How would you find all strings containing \\ with regex() vs. with fixed()? What are the five most common words in sentences? "],["other-uses-of-regular-expressions-1.html", "15.6 Other uses of regular expressions", " 15.6 Other uses of regular expressions There are two useful function in base R that also use regular expressions: apropos() searches all objects available from the global environment. This is useful if you can’t quite remember the name of the function. apropos(&quot;replace&quot;) ## [1] &quot;%+replace%&quot; &quot;replace&quot; &quot;replace_na&quot; &quot;setReplaceMethod&quot; ## [5] &quot;str_replace&quot; &quot;str_replace_all&quot; &quot;str_replace_na&quot; &quot;theme_replace&quot; dir() lists all the files in a directory. The pattern argument takes a regular expression and only returns file names that match the pattern. head(dir(pattern = &quot;\\\\.Rmd$&quot;)) ## [1] &quot;01-introduction.Rmd&quot; &quot;02--whole_game.Rmd&quot; ## [3] &quot;02-data_visualisation.Rmd&quot; &quot;03-workflow_basics.Rmd&quot; ## [5] &quot;04-data_transformation.Rmd&quot; &quot;05-workflow_pipes.Rmd&quot; If you’re more comfortable with “globs” like *.Rmd, you can convert them to regular expressions with glob2rx() "],["stringi-1.html", "15.7 stringi", " 15.7 stringi stringr is built on top of the stringi package. stringr is useful when you’re learning because it exposes a minimal set of functions, which have been carefully picked to handle the most common string manipulation functions. stringi, on the other hand, is designed to be comprehensive. It contains almost every function you might ever need: stringi has 250 functions to stringr’s 49. If you find yourself struggling to do something in stringr, it’s worth taking a look at stringi. The packages work very similarly, so you should be able to translate your stringr knowledge in a natural way. The main difference is the prefix: str_ vs. stri_. 15.7.1 Exercises Find the stringi functions that: Count the number of words. Find duplicated strings. 3.Generate random text. How do you control the language that stri_sort() uses for sorting? "],["meeting-videos-14.html", "15.8 Meeting Videos", " 15.8 Meeting Videos 15.8.1 Cohort 5 Meeting chat log 00:10:10 Njoki Njuki Lucy: Hi everyone! 00:10:24 Federica Gazzelloni: Hello! 00:10:31 Sandra Muroy: hi! 00:11:09 Federica Gazzelloni: Hi Sandra! 00:11:27 Sandra Muroy: Hi Federica :D 00:11:43 Sandra Muroy: Hi Lucy! 00:19:20 Jon Harmon (jonthegeek): https://xkcd.com/208/ 00:20:10 Jon Harmon (jonthegeek): https://smltar.com/ is the new book by Julia Silge and Emil Hvitfeldt. 00:20:42 Jon Harmon (jonthegeek): https://www.tidytextmining.com/ is the older Tidytext book by Julia Silge and David Robinson. 00:28:15 Njoki Njuki Lucy: do you also load the packages or that&#39;s sufficient for a readable code? 00:28:59 Jon Harmon (jonthegeek): Within an Rmd I tend to put a library() call per package at the top so it&#39;s easy to find, but in my exploration work I rarely library anything other than magrittr. 00:30:11 Njoki Njuki Lucy: okay, thank you 00:39:53 Jon Harmon (jonthegeek): &gt; x &lt;- r&quot;(this treats all characters as ecaped. For example: \\ &quot; &#39;)&quot; &gt; writeLines(x) this treats all characters as ecaped. For example: \\ &quot; &#39; 00:45:30 Jon Harmon (jonthegeek): \\&quot; 00:45:31 Federica Gazzelloni: textutils: https://github.com/enricoschumann/textutils 00:45:42 Jon Harmon (jonthegeek): &quot;\\&quot;&quot; 00:46:00 Jon Harmon (jonthegeek): &quot;&quot;&quot; 00:46:19 Jon Harmon (jonthegeek): &quot;\\\\&quot; 00:49:07 Jon Harmon (jonthegeek): &gt; &quot;\\&quot; + 00:50:06 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\ttab&quot;) this tab 00:50:21 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\nnewline&quot;) this newline 00:50:40 Jon Harmon (jonthegeek): &gt; cat(&quot;this\\something&quot; Error: &#39;\\s&#39; is an unrecognized escape in character string starting &quot;&quot;this\\s&quot; 00:51:20 Njoki Njuki Lucy: did I get it right that the character after \\ is escaped not printed? 00:51:30 Jon Harmon (jonthegeek): correct 00:51:41 Jon Harmon (jonthegeek): https://regexr.com/ 00:59:49 Jon Harmon (jonthegeek): &gt; str_c(rep(&quot;prefix&quot;, 3), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), rep(&quot;suffix&quot;, 3), sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 01:00:25 Jon Harmon (jonthegeek): &gt; str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 01:01:26 Jon Harmon (jonthegeek): &gt; str_c(c(&quot;prefix&quot;, &quot;other&quot;, &quot;another&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;other-b-suffix&quot; &quot;another-c-suffix&quot; 01:02:02 Jon Harmon (jonthegeek): &gt; str_c(c(&quot;prefix&quot;, &quot;other&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) [1] &quot;prefix-a-suffix&quot; &quot;other-b-suffix&quot; &quot;prefix-c-suffix&quot; Warning message: In stri_c(..., sep = sep, collapse = collapse, ignore_null = TRUE) : longer object length is not a multiple of shorter object length 01:04:54 Jon Harmon (jonthegeek): &gt; str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;, collapse = &quot;|&quot;) [1] &quot;prefix-a-suffix|prefix-b-suffix|prefix-c-suffix&quot; 01:09:51 Njoki Njuki Lucy: thank you so much Ryan and Jon, strings are starting to make sense now! 01:09:53 Sandra Muroy: thanks so much Ryna! 01:09:56 Sandra Muroy: Ryan! Meeting chat log 00:07:40 Jon Harmon (jonthegeek): statlearning.com 00:23:39 Jon Harmon (jonthegeek): ^ = start of text $ = end of text 00:31:17 Jon Harmon (jonthegeek): Notes are finally updated on our site if you want to follow along or review: https://r4ds.github.io/bookclub-r4ds/strings.html 00:31:37 Sandra Muroy: thanks Jon! 00:37:56 Jon Harmon (jonthegeek): https://en.wikipedia.org/wiki/Harvard_sentences 00:42:35 Jon Harmon (jonthegeek): sum(stringr::str_detect(sentences, str_c(words, collapse = &quot;|&quot;), negate = TRUE)) 00:45:50 Jon Harmon (jonthegeek): 1 %in% 1:10 00:46:02 Jon Harmon (jonthegeek): &quot;a&quot; %in% &quot;ab&quot; 00:46:08 Jon Harmon (jonthegeek): &quot;a&quot; 00:46:10 Jon Harmon (jonthegeek): &quot;ab&quot; 00:46:18 Jon Harmon (jonthegeek): &quot;a&quot; %in% c(&quot;a&quot;, &quot;b&quot;) 01:02:39 Jon Harmon (jonthegeek): regexr.com 15.8.2 Cohort 6 Meeting chat log 00:09:53 Daniel Adereti: We will kick off in 1 min 00:14:55 Shannon: https://r4ds.github.io/bookclub-r4ds/string-basics.html 00:18:48 Shannon: https://stringr.tidyverse.org/ 00:19:06 Shannon: https://github.com/rstudio/cheatsheets/blob/main/strings.pdf 00:21:02 Daniel Adereti: For new members, we have this sheet where we volunteer to take classes each week, you are welcome to fill in your names. Thanks! https://docs.google.com/spreadsheets/d/1zy2nXNkvcdqWuF8rQ5ApWRkVQG_UJt0azu3h_mEnY2E/edit?usp=drive_web&amp;ouid=115626840160043101981 00:26:49 Shannon: https://en.wikipedia.org/wiki/List_of_Unicode_characters 01:05:02 Daniel Adereti: That&#39;s fine! 01:05:13 Daniel Adereti: We can pick up next week 01:05:37 Adeyemi Olusola: Thank you! 01:05:45 Folashade Bayode: Thank you 😊 Meeting chat log 00:15:15 Daniel Adereti: We have this nice book that solves the exercises, if you are interested: https://jrnold.github.io/r4ds-exercise-solutions/strings.html 00:15:35 Marielena Soilemezidi: awesome, thanks Daniel! :) 00:22:13 Marielena Soilemezidi: the book has the same solution for this, so you did great actually! :) 00:36:42 Shannon: https://regexcrossword.com/challenges/beginner 00:37:04 Marielena Soilemezidi: ooh cool! 00:37:10 Marielena Soilemezidi: thanks Shannon! 00:43:17 Marielena Soilemezidi: 0.0 00:43:26 Marielena Soilemezidi: who thought of this example?! 00:52:47 Daniel Adereti: Hey Marielena, if you want to volunteer for a class, you can fill in your name here: https://docs.google.com/spreadsheets/d/1zy2nXNkvcdqWuF8rQ5ApWRkVQG_UJt0azu3h_mEnY2E/edit#gid=0 00:55:10 Marielena Soilemezidi: Thanks, Daniel! I&#39;ll check the next available chapters :) Meeting chat log 00:03:15 Adeyemi Olusola: Good day! 00:04:23 Adeyemi Olusola: That sounds perfect 00:48:27 Adeyemi Olusola: I have to drop off now. Thanks Shannon for the wonderful presentation! 00:49:28 Marielena Soilemezidi: oh, cool! :) 00:50:24 Marielena Soilemezidi: haha yaay! 00:51:47 Marielena Soilemezidi: weird! "],["factors-2.html", "Chapter 16 Factors", " Chapter 16 Factors Learning objectives: Create factor() variables. Explore the General Social Survey dataset via forcats::gss_cat. Reorder factor levels. forcats::fct_reorder() forcats::fct_relevel() forcats::fct_reorder2() forcats::fct_infreq() forcats::fct_rev() Modify factor levels. forcats::fct_recode() forcats::fct_collapse() forcats::fct_lump() "],["slide-1.html", "16.1 Slide 1", " 16.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2.html", "16.2 Slide 2", " 16.2 Slide 2 Slide contents. "],["meeting-videos-15.html", "16.3 Meeting Videos", " 16.3 Meeting Videos 16.3.1 Cohort 5 Meeting chat log 00:05:04 Federica Gazzelloni: Hello 00:23:34 Jon Harmon (jonthegeek): Useful: R has month.name and month.abb character vectors built in. So you can do things like y3 &lt;- factor(month.abb, levels = month.abb) 00:35:46 Ryan Metcalf: Open ended question for the team. If Factors are a built-in enumeration in categorical data….what if the data in review has a dictionary and the variable (column) of each record is entered as a numeral. Would a best practice to use a join or mutate to enter the text instead of a numeral. 01:00:25 Ryan Metcalf: I’m not finding a direct definition of “level” in the Forecats text. Would it be appropriate to state a “level” in this Factor chapter is the “quantity of a given category?” 01:05:05 Jon Harmon (jonthegeek): state.abb 16.3.2 Cohort 6 Meeting chat log 00:12:43 Daniel Adereti: https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography/ 00:13:46 Adeyemi Olusola: Its freezing but I don’t know if it’s from my end 00:15:05 Shannon: Yes, Adeyemi, it&#39;s freezing a bit...cleared up for now 00:19:52 Adeyemi Olusola: I guess as.factor( ) does the same without aorting 01:01:46 Marielena Soilemezidi: thank you Daniel! 01:01:52 Adeyemi Olusola: Thank you Daniel 01:02:34 Marielena Soilemezidi: bye all! 01:02:40 Daniel Adereti: Bye! "],["dates-and-times.html", "Chapter 17 Dates and times", " Chapter 17 Dates and times Learning objectives: Create date and datetime objects. Create dates and datetimes from strings. Create dates and datetimes from individual components. Create dates and datetimes from each other. Work with datetime components. Extract components from datetimes. Round datetime components. Set individual datetime components. Perform arithmetic on timespans. Use durations to measure exact seconds. Use periods to measure human units like weeks and months. Use intervals to represent timespans with exact start and end datetimes. Recognize ways to deal with timezones in R. "],["create-date-and-date-time-objects.html", "17.1 Create date and date-time objects", " 17.1 Create date and date-time objects From strings: Date: use ‘y’ ‘m’ ‘d’ in whatever order eg. ymd() Date-time: add ‘h’ ‘m’ ‘s’ after an underscore eg. ymd_hms() From individual components: make_date() make_datetime() From an existing object: as_datetime() as_date() "],["work-with-date-time-components.html", "17.2 Work with date-time components", " 17.2 Work with date-time components Extract components from datetimes year() month() yday() mday() wday() hour() minute() second() Round datetime components floor_date() rounds down ceiling_date() rounds up round_date() rounds to Set individual datetime components Use create functions (ymd_hms) or update() "],["perform-arithmetic-on-timespans.html", "17.3 Perform arithmetic on timespans", " 17.3 Perform arithmetic on timespans Use durations to measure timespans Durations measure seconds, be aware conversions happen at a standard rate dseconds() dminutes() dhours() ddays() dwekks() dyears() These can be added, subtracted and divided in some cases, also multiplied by numbers. Use periods to measure human units like weeks or months These work like durations, but take into account things like DST seconds() minutes() hours() days() weeks() months() years() These can be added, subtracted and divided in some cases, also multiplied by numbers. Use intervals to represent timespans with exact start and end datetimes Intervals are way to do arithmetic with durations and periods? syntax??? "],["time-zones.html", "17.4 Time zones", " 17.4 Time zones Names R uses IANA (Internet Assigned Numbers Authority) for time zone names. Get a complete list with OlsonNames() Change the displayed time zone The time zone attribute of a datetime is only displayed. UTC is the default (and doesn’t have DST, which makes computing easier) with_tz() Change the underlying time zone force_tz() "],["meeting-videos-16.html", "17.5 Meeting Videos", " 17.5 Meeting Videos 17.5.1 Cohort 5 Meeting chat log 00:17:21 Sandra Muroy: Hi Lucus! 00:17:52 lucus w: Hi Sandra 00:27:34 Ryan Metcalf: The “Visual Markdown Editor” icon Becki mentioned is intended to provide a similar experience to Jupyter Notebooks. 00:41:39 Federica Gazzelloni: round_date:: https://lubridate.tidyverse.org/reference/round_date.html 00:51:22 lucus w: Dates and time are HARD 00:51:40 Sandra Muroy: agree! 00:52:21 Ryan Metcalf: For a list of timezone abbreviations in R, run `OlsonNames(tzdir = NULL)` 00:53:16 Sandra Muroy: thanks Ryan! 00:58:51 Ryan Metcalf: I learned a trick from Federica….for syntax questions, use “?`&lt;the character in question&gt;`” Note the back ticks to highlight the sequence of character. 01:06:13 lucus w: “?” -- aka “what the” 01:07:42 Federica Gazzelloni: ?`%--%` 01:08:42 Federica Gazzelloni: start %--% end 01:10:08 Becki R. (she/her): Thanks, Federica! The easiest answer is the best. 01:10:54 lucus w: In healthcare there’s a tendency to deidentify date time objects as it’s considered patient identified information. Masking those date time randomly is a huge challenge 01:11:19 Sandra Muroy: interesting 01:13:57 Sandra Muroy: happy holidays everyone! 17.5.2 Cohort 6 Meeting chat log LOG "],["missing-values-4.html", "Chapter 18 Missing values", " Chapter 18 Missing values Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-5.html", "18.1 SLIDE TITLE", " 18.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-17.html", "18.2 Meeting Videos", " 18.2 Meeting Videos 18.2.1 Cohort 7 Meeting chat log LOG 18.2.2 Cohort 8 Meeting chat log LOG "],["joins.html", "Chapter 19 Joins", " Chapter 19 Joins Learning objectives: Recognize the families of verbs for working with relational data. Use keys (primary, foreign, and surrogate) to identify relations between tables. Use mutating joins to combine related tables. Use filtering joins to remove observations from a table. Recognize common problems with joins. Use set operations to combine or filter tables. "],["introduction-7.html", "19.1 Introduction", " 19.1 Introduction Multiple tables of data are called relational data. The basic idea is that relations are defined between a pair of tables. Multiple tables are put in relation starting from this basic idea. There are three families of verbs designed to work with relational data: Mutating joins, which add new variables to one data frame from matching observations in another. Filtering joins, which filter observations from one data frame based on whether or not they match an observation in the other table. Set operations, which treat observations as if they were set elements. "],["nycflights13-1.html", "19.2 nycflights13", " 19.2 nycflights13 How to make a custom table with different data sets nycflights13::airlines nycflights13::airports nycflights13::flights nycflights13::planes nycflights13::weather Relations: flights connects to planes via a single variable, tailnum. flights connects to airlines through the carrier variable. flights connects to airports in two ways: via the origin and dest variables. flights connects to weather via origin (the location), and year, month, day and hour (the time). Figure 19.1: nycfilghts13 package Exercises and solutions "],["keys.html", "19.3 Keys", " 19.3 Keys What is a key? A key is a variable (or set of variables) that uniquely identifies an observation. What is a relation? It is when a primary key and the corresponding foreign key in another table form a relation. What are the types of keys: A primary key uniquely identifies an observation in its own table. primary key: each row is an observation For example, planes$tailnum is a primary key because it uniquely identifies each plane in the planes table. A foreign key uniquely identifies an observation in another table. For example, flights$tailnum is a foreign key for the planes table because it appears in the flights table where it matches each flight to a unique plane. A surrogate key is a custom made key where it is possible to identify unique information, such as the number of rows in a table, and it is made if a table lacks a primary key. For example, flights$filghts_id is a surrogate key because it is custom made and uniquely identifies each observation in the flights table. Type of data relations 1-to-many: flight has one plane, but each plane has many flights Many-to-many: between airlines and airports, each airline flies to many airports; each airport hosts many airlines Special cases are: 1-to-1 and Many-to-1 "],["mutating-joins.html", "19.4 Mutating joins", " 19.4 Mutating joins To combine variables from two tables We have seen the inner_join() function operating now we see the other three outer joins: left_join() keeps all observations in x right_join() keeps all observations in y full_join() keeps all observations in x and y 19.4.1 Understanding joins Figure 19.2: Venn diagram Suppose we have two tables with two variables: id and the observations Figure 19.3: Two tables 19.4.2 Inner join flights %&gt;% slice(1:100) %&gt;% select(origin,year,month) %&gt;% inner_join(select(weather,origin,temp,wind_dir),by = &quot;origin&quot;) ## # A tibble: 870,507 × 5 ## origin year month temp wind_dir ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 2013 1 39.0 270 ## 2 EWR 2013 1 39.0 250 ## 3 EWR 2013 1 39.0 240 ## 4 EWR 2013 1 39.9 250 ## 5 EWR 2013 1 39.0 260 ## 6 EWR 2013 1 37.9 240 ## 7 EWR 2013 1 39.0 240 ## 8 EWR 2013 1 39.9 250 ## 9 EWR 2013 1 39.9 260 ## 10 EWR 2013 1 41 260 ## # … with 870,497 more rows Figure 19.4: inner join 19.4.3 Outer joins A left join keeps all observations in x A right join keeps all observations in y A full join keeps all observations in x and y Figure 19.5: Outer joins left_join flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) %&gt;% select(-origin, -dest) %&gt;% left_join(airlines, by = &quot;carrier&quot;) ## # A tibble: 336,776 × 7 ## year month day hour tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 N619AA AA American Airlines Inc. ## 4 2013 1 1 5 N804JB B6 JetBlue Airways ## 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 N516JB B6 JetBlue Airways ## 8 2013 1 1 6 N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 N593JB B6 JetBlue Airways ## 10 2013 1 1 6 N3ALAA AA American Airlines Inc. ## # … with 336,766 more rows same thing with mutate() flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) %&gt;% select(-origin, -dest) %&gt;% mutate(name = airlines$name[match(carrier, airlines$carrier)]) ## # A tibble: 336,776 × 7 ## year month day hour tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 N619AA AA American Airlines Inc. ## 4 2013 1 1 5 N804JB B6 JetBlue Airways ## 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 N516JB B6 JetBlue Airways ## 8 2013 1 1 6 N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 N593JB B6 JetBlue Airways ## 10 2013 1 1 6 N3ALAA AA American Airlines Inc. ## # … with 336,766 more rows right_join weather %&gt;% select(origin,temp, humid, wind_dir, precip) %&gt;% right_join(airports, by = c(&quot;origin&quot; = &quot;faa&quot;)) ## # A tibble: 27,570 × 12 ## origin temp humid wind_dir precip name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 EWR 39.0 59.4 270 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 2 EWR 39.0 61.6 250 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 3 EWR 39.0 64.4 240 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 4 EWR 39.9 62.2 250 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 5 EWR 39.0 64.4 260 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 6 EWR 37.9 67.2 240 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 7 EWR 39.0 64.4 240 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 8 EWR 39.9 62.2 250 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 9 EWR 39.9 62.2 260 0 Newar… 40.7 -74.2 18 -5 A Amer… ## 10 EWR 41 59.6 260 0 Newar… 40.7 -74.2 18 -5 A Amer… ## # … with 27,560 more rows full_join airports %&gt;% select(name,lat,lon) %&gt;% full_join(airlines,by = &quot;name&quot;) ## # A tibble: 1,474 × 4 ## name lat lon carrier ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Lansdowne Airport 41.1 -80.6 &lt;NA&gt; ## 2 Moton Field Municipal Airport 32.5 -85.7 &lt;NA&gt; ## 3 Schaumburg Regional 42.0 -88.1 &lt;NA&gt; ## 4 Randall Airport 41.4 -74.4 &lt;NA&gt; ## 5 Jekyll Island Airport 31.1 -81.4 &lt;NA&gt; ## 6 Elizabethton Municipal Airport 36.4 -82.2 &lt;NA&gt; ## 7 Williams County Airport 41.5 -84.5 &lt;NA&gt; ## 8 Finger Lakes Regional Airport 42.9 -76.8 &lt;NA&gt; ## 9 Shoestring Aviation Airfield 39.8 -76.6 &lt;NA&gt; ## 10 Jefferson County Intl 48.1 -123. &lt;NA&gt; ## # … with 1,464 more rows 19.4.4 Duplicate keys What happens when the keys are not unique? Table with duplicates Figure 19.6: Duplicates Both tables have duplicate keys Figure 19.7: Duplicates 19.4.4.1 Defining the key columns by = \"key\" can be customized: by = NULL, uses all variables that appear in both tables (natural join) by = \"x\", uses only one specific variable by = c(\"a\" = \"b\"), uses a named character vector Exercises and solutions 19.4.4.2 Other implementations The base::merge() function can perform all four types of mutating join. The difference between the joins and merge() is really important. dplyr’s joins are considerably faster and don’t mess with the order of the rows. Figure 19.8: Implementations SQL is the inspiration for dplyr’s conventions Figure 19.9: Implementation Example of dplyr’s joins and SQL syntax: inner_join(x, y, by = c(&quot;a&quot; = &quot;b&quot;)) It uses a slightly different syntax in SQL: SELECT * FROM x INNER JOIN y ON x.a = y.b "],["filtering-joins.html", "19.5 Filtering joins", " 19.5 Filtering joins semi_join(x, y) keeps all observations in x that have a match in y. anti_join(x, y) drops all observations in x that have a match in y. Semi-join: semi_join() Figure 19.10: Semi-join top_dest &lt;- flights %&gt;% count(dest, sort = TRUE) %&gt;% head(10) flights %&gt;% semi_join(top_dest) # keeps all observations in x that have a match in y ## # A tibble: 141,145 × 19 ## year month day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 1 1 542 540 2 923 850 33 AA ## 2 2013 1 1 554 600 -6 812 837 -25 DL ## 3 2013 1 1 554 558 -4 740 728 12 UA ## 4 2013 1 1 555 600 -5 913 854 19 B6 ## 5 2013 1 1 557 600 -3 838 846 -8 B6 ## 6 2013 1 1 558 600 -2 753 745 8 AA ## 7 2013 1 1 558 600 -2 924 917 7 UA ## 8 2013 1 1 558 600 -2 923 937 -14 UA ## 9 2013 1 1 559 559 0 702 706 -4 B6 ## 10 2013 1 1 600 600 0 851 858 -7 B6 ## # … with 141,135 more rows, 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, and abbreviated variable names ## # ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay Filtering joins never duplicate rows like mutating joins do: Figure 19.11: Semi-join The inverse of a semi-join is an anti-join: anti_join() flights %&gt;% anti_join(planes, by = &quot;tailnum&quot;) %&gt;% count(tailnum, sort = TRUE) # keeps the rows that don’t have a match ## # A tibble: 722 × 2 ## tailnum n ## &lt;chr&gt; &lt;int&gt; ## 1 &lt;NA&gt; 2512 ## 2 N725MQ 575 ## 3 N722MQ 513 ## 4 N723MQ 507 ## 5 N713MQ 483 ## 6 N735MQ 396 ## 7 N0EGMQ 371 ## 8 N534MQ 364 ## 9 N542MQ 363 ## 10 N531MQ 349 ## # … with 712 more rows Figure 19.12: Anti-join Exercises "],["some-more-things-to-consider.html", "19.6 Some more things to consider", " 19.6 Some more things to consider 19.6.1 Join problems Be aware that simply checking the number of rows before and after the join is not sufficient to ensure that your join has gone smoothly. Identifying the variables that form the primary key in each table Check for missing values Check that your foreign keys match primary keys in another table (using anti_join()`) 19.6.2 Set operations These are type of two-table verb set operations: intersect(x, y): return only observations in both x and y union(x, y): return unique observations in x and y setdiff(x, y): return observations in x, but not in y "],["meeting-videos-18.html", "19.7 Meeting Videos", " 19.7 Meeting Videos 19.7.1 Cohort 5 Meeting chat log 00:08:43 Ryan Metcalf: So sorry for my delay. Aerating the lawn! Fun! 00:10:36 Becki R. (she/her): Hello! 00:22:56 Becki R. (she/her): That&#39;s a good idea! It would be a nice reference. 00:24:30 Jon Harmon (jonthegeek): https://cran.r-project.org/web/packages/DiagrammeR/index.html 00:24:33 Sandra Muroy: diagramR? 00:25:12 Jon Harmon (jonthegeek): I guess the sharable link is supposed to be: https://cran.r-project.org/package=DiagrammeR 00:26:06 Becki R. (she/her): That&#39;s a good reminder, thanks. 00:56:06 Ryan Metcalf: Another way to notate Venn diagrams and/or discrete mathematics is to use LaTeX. This is not intended to deter you learning of R but may be useful when working with a larger team (especially DB admins!) https://www.purplemath.com/modules/venndiag2.htm 01:04:20 Jon Harmon (jonthegeek): ggplot2::diamonds %&gt;% dplyr::count(carat, cut, color, clarity, depth, table, price, x, y, z, sort = TRUE) 01:08:49 Ryan Metcalf: Great Job Federica! Looking forward to next week! Meeting chat log 00:22:57 Jon Harmon (jonthegeek): Try this to see a quick example. You&#39;re right that the order of the columns is left then right either way, but the rows to keep changes. library(dplyr) band_members %&gt;% left_join(band_instruments) band_members %&gt;% right_join(band_instruments) 00:29:17 Jon Harmon (jonthegeek): band_instruments %&gt;% left_join(band_members) 00:39:07 lucus w: Seems like setdiff() is similar to dplyr::anti_join()… they maybe differ by how they prints? 00:40:45 Jon Harmon (jonthegeek): anti_join only needs to match on one key column to exclude; setdiff is looking for the entire observations to be repeated. 00:41:29 lucus w: Interesting.. thanks! 00:52:28 Njoki Njuki Lucy: I don&#39;t understand what&#39;s happening exactly, if age is greater than 25, have it as 25L(int) otherwise its age? 00:53:56 Njoki Njuki Lucy: okay, thanks 00:54:28 Federica Gazzelloni: sorry my connection 01:05:28 Njoki Njuki Lucy: thank you :) 01:05:33 lucus w: Thanks y&#39;all 19.7.2 Cohort 6 Meeting chat log LOG There are no separate learning objectives for this introduction. "],["parsing.html", "Chapter 20 Parsing", " Chapter 20 Parsing Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-6.html", "20.1 SLIDE TITLE", " 20.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-19.html", "20.2 Meeting Videos", " 20.2 Meeting Videos 20.2.1 Cohort 7 Meeting chat log LOG 20.2.2 Cohort 8 Meeting chat log LOG "],["spreadsheets.html", "Chapter 21 Spreadsheets", " Chapter 21 Spreadsheets Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-7.html", "21.1 SLIDE TITLE", " 21.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-20.html", "21.2 Meeting Videos", " 21.2 Meeting Videos 21.2.1 Cohort 7 Meeting chat log LOG 21.2.2 Cohort 8 Meeting chat log LOG "],["databases.html", "Chapter 22 Databases", " Chapter 22 Databases Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-8.html", "22.1 SLIDE TITLE", " 22.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-21.html", "22.2 Meeting Videos", " 22.2 Meeting Videos 22.2.1 Cohort 7 Meeting chat log LOG 22.2.2 Cohort 8 Meeting chat log LOG "],["data-rectangling.html", "Chapter 23 Data rectangling", " Chapter 23 Data rectangling Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-9.html", "23.1 SLIDE TITLE", " 23.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-22.html", "23.2 Meeting Videos", " 23.2 Meeting Videos 23.2.1 Cohort 7 Meeting chat log LOG 23.2.2 Cohort 8 Meeting chat log LOG "],["web-scraping.html", "Chapter 24 Web scraping", " Chapter 24 Web scraping Learning objectives: ADD ABOUT ONE THING PER SECTION DESCRIBING WHAT YOU LEARN IN THIS CHAPTER. "],["slide-title-10.html", "24.1 SLIDE TITLE", " 24.1 SLIDE TITLE ADD NEW SLIDES USING ##. TRY TO KEEP THE FEEL SLIDE-LIKE BULLETED LISTS, NOT PARAGRAPHS "],["meeting-videos-23.html", "24.2 Meeting Videos", " 24.2 Meeting Videos 24.2.1 Cohort 7 Meeting chat log LOG 24.2.2 Cohort 8 Meeting chat log LOG Recognize that code is a vehicle for communication. "],["functions-2.html", "Chapter 25 Functions", " Chapter 25 Functions Learning objectives: Write functions to automate common tasks in R. Name R functions using consistent rules. Effectively use comments in R functions to explain the “why” of your code. Conditionally execute code in R functions. Use if and else statements to conditionally execute R code. Use switch statements to conditionally execute R code. Use cut to discretize continuous variables. Use consistent arguments for R functions. Give default values to arguments in R functions. Check values of arguments to make safer functions in R. Use ... arguments in R functions. Return values from R functions. Use explicit returns to return early from an R function. Use invisible to invisibly return values from R functions. Recognize how R utilizes environments and lexical scoping to find the value associated with a name. "],["introduction-8.html", "25.1 Introduction", " 25.1 Introduction Functions are handy because: they automate repetitive tasks. have a name that makes the purpose very clear you only need to update the code in one place as things change it’s safer than copy and paste - you won’t replicate errors The common theme for functions is to be consistent. "],["when-and-how-to-write-a-function.html", "25.2 When and how to write a function", " 25.2 When and how to write a function Have you copy and pasted code more than 2x? Consider a function! Key steps in creating a function: Pick a name than makes it clear what the function does Arguments, or inputs, go inside function, like so function(arguments). The code goes inside curly braces { }, after function(). Check your function with a few inputs to make sure it’s working. "],["functions-are-for-computers-and-humans.html", "25.3 Functions are for computers and humans", " 25.3 Functions are for computers and humans Be consistent in you naming and coding of functions Names: Functions should be verbs (action, state, or occurrence), arguments should be nouns (people places or things). Be consistent in using snake_case or camelCase. For sets of functions, use a common prefix Don’t overwrite existing function Comments: Use comments to explain the ‘why’ of the code Use lines of - or = to break up code into sections "],["conditional-execution.html", "25.4 Conditional execution", " 25.4 Conditional execution if statements conditionally execute code. The condition must evaluate to TRUE or FALSE. Be careful: == is vectorised. Use || (OR) and &amp;&amp; (AND) to combine multiple logical expressions. You can string multiple if statements together: if, else if, else For a long series of chained if statements, use switch() Use cut() to ‘discretise continuous variables’ Format: Your function or if statement followed by a curly brace New line, indent 2 spaces. Ending brace on its own line, unless followed by else. "],["function-arguments.html", "25.5 Function arguments", " 25.5 Function arguments One set supplies the data to compute on One set supplies arguments that control the details of the computation. Generally, data comes first, and details go on the end and usually have default values. Choose names that are longer and descriptive or use common ones: x, y, z: vectors w: a vector of weights df: a data frame i, j: numeric indices (rows/columns) n: length, or number of rows p: number of columns Put checks in your functions to make constraints explicit. Use . as an argument that takes an arbitrary number of values Lazy evaluation - arguments in R are not computed until they’re needed. "],["return-values.html", "25.6 Return values", " 25.6 Return values Two things to consider when returning a value: Does returning early make your function easier to read? R, by default, returns the last value of a function. You can return a value with or without an explicit return statement. Can you make your function pipeable? There are two basic types of pipeable functions: With transformations, an object is passed to the function’s first argument and a modified object is returned. With side-effects, the passed object is not transformed. Instead, the function performs an action on the object, like drawing a plot or saving a file. "],["environment.html", "25.7 Environment", " 25.7 Environment Lexical scoping - R will look outside the function, in the environment, for definitions of variables, if it is not defined within. "],["meeting-videos-24.html", "25.8 Meeting Videos", " 25.8 Meeting Videos 25.8.1 Cohort 5 Meeting chat log 00:24:22 Jon Harmon (jonthegeek): Famous computer science quote: There are only two hard things in Computer Science: cache invalidation and naming things. -- Phil Karlton 00:32:31 Jon Harmon (jonthegeek): &gt; identical(1.0, 1L) [1] FALSE 00:32:50 Jon Harmon (jonthegeek): &gt; 1.0 == 1L [1] TRUE 00:33:31 Jon Harmon (jonthegeek): identical(as.integer(1.0), 1L) 00:33:49 Jon Harmon (jonthegeek): identical(1.0, as.double(1L)) 00:38:39 Njoki Njuki Lucy: is there a difference between ifelse() and if, else function? 00:39:32 Jon Harmon (jonthegeek): ifelse() if … else if … else 00:40:15 Jon Harmon (jonthegeek): ifelse(c(TRUE, FALSE, TRUE), &quot;yes&quot;, &quot;no&quot;) 00:40:28 Jon Harmon (jonthegeek): &gt; ifelse(c(TRUE, FALSE, TRUE), &quot;yes&quot;, &quot;no&quot;) [1] &quot;yes&quot; &quot;no&quot; &quot;yes&quot; 00:40:52 Jon Harmon (jonthegeek): &gt; ifelse(1:10 == 8, &quot;it&#39;s 8&quot;, &quot;it isn&#39;t&quot;) [1] &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; [8] &quot;it&#39;s 8&quot; &quot;it isn&#39;t&quot; &quot;it isn&#39;t&quot; 00:41:12 Jon Harmon (jonthegeek): &gt; ifelse(1:10 == 8, 8, NA) [1] NA NA NA NA NA NA NA 8 NA NA 00:42:13 Ryan Metcalf: Possible Reference, Section 7.4, Missing Values. It makes a reference to `ifelse()` function: https://r4ds.had.co.nz/exploratory-data-analysis.html?q=ifelse()#missing-values-2 00:43:01 Jon Harmon (jonthegeek): if else ifelse if_else 00:43:17 Njoki Njuki Lucy: thank you! 00:43:22 Njoki Njuki Lucy: big time:) 00:50:35 Njoki Njuki Lucy: what exactly is the trim doing? I didn&#39;t understand 00:52:05 Jon Harmon (jonthegeek): &gt; mean(c(1, 90:100), trim = 0) [1] 87.16667 &gt; mean(c(1, 90:100), trim = 0.1) [1] 94.5 &gt; mean(c(1, 90:100), trim = 0.5) [1] 94.5 00:52:46 Jon Harmon (jonthegeek): &gt; mean(1:10, trim = 0.5) [1] 5.5 00:54:10 Njoki Njuki Lucy: okay, understood. thanks! 00:58:15 Jon Harmon (jonthegeek): myfun &lt;- function(x, ...) { mean(x, ...) } 00:58:47 Jon Harmon (jonthegeek): &gt; myfun(1:10, trim = 0.1) [1] 5.5 00:59:13 Jon Harmon (jonthegeek): &gt; myfun(1:10, trim = 0.1) Error in myfun(1:10, trim = 0.1) : unused argument (trim = 0.1) 01:01:34 Jon Harmon (jonthegeek): myfun &lt;- function(x, funname, ...) { if (funname == &quot;mean&quot;) { mean(x, ...) } else { log(x, ...) } } 01:04:11 Jon Harmon (jonthegeek): myfun &lt;- function(...) { dots &lt;- list(...) names(dots) } myfun(a = 1) 01:05:28 Jon Harmon (jonthegeek): [1] &quot;a&quot; 01:05:49 Jon Harmon (jonthegeek): dots &lt;- list(a = 1) 01:09:32 Jon Harmon (jonthegeek): myfun &lt;- function(a, b) { a } myfun(1:10, Sys.sleep(60)) Meeting chat log See Chapter 20 for the part of the log that&#39;s relevant to that chapter. 25.8.2 Cohort 6 Meeting chat log 00:23:48 Daniel Adereti: Range() function in R returns the maximum and minimum value of the vector and column of the dataframe in R. range() function of the column of dataframe 00:45:42 Daniel Adereti: My guess for the inf, -inf is just to assign the respective 1 and 0 to the inf and -inf 00:46:26 Daniel Adereti: and to rescale the x vector expressing all variables with inf as 1 and -inf as 0 00:58:38 Adeyemi Olusola: Thanks for the wonderful talk. Sorry, I have to drop off now. Thanks 00:58:41 Daniel Adereti: it might make sense to stop at 19.2 Meeting chat log 00:03:15 Marielena Soilemezidi: Hello there! :) 00:03:51 Daniel: Hello! 00:32:16 Daniel: I think it aim to check if any of the vector characters == 8, if yes, it returns 8, if no, it returns &quot;Not available&quot; 00:44:24 Daniel: Hello all, please remember we need volunteers for next week&#39;s class: Vectors "],["vectors.html", "Chapter 26 Vectors", " Chapter 26 Vectors Note: Since these slides were made, this chapter has been split into multiple chapters. After you edit these slides, remove this note. Learning objectives: Compare and contrast atomic vectors and lists. Recognize the six types of atomic vectors. Determine the key properties (typeof and length) of vectors. Recognize the three important types of augmented vectors. Construct logical vectors. Construct numeric vectors. Differentiate between the two types of numeric vectors, double and integer. Construct character vectors. Recognize the different types of missing values. Coerce vectors between different types. Test whether a vector has a given type. Recognize when a vector will be recycled to match the length of another vector, and when it will not. Name the elements of vectors. Subset vectors. Construct lists. Differentiate between [, [[, and $ for subsetting lists. Use attributes to provide additional information about vectors. Recognize the S3 object-oriented system. Construct factors. Construct dates and date-times. Recognize that tibbles are augmented lists. "],["introduction-9.html", "26.1 Introduction", " 26.1 Introduction Since we have already learnt about tibbles, in this chapter we will study vectors that underlie them. 26.1.1 Prerequisites Here we focus on base R data structures, hence no need to load any packages. But we will a couple of functions from purrr package to avoid some inconsistencies in base R. library(tidyverse) "],["vector-basics-2.html", "26.2 Vector basics", " 26.2 Vector basics There are two types of vectors: Atomic vectors, of which there are six types: logical integer double character complex raw Integer and double vectors are collectively called numeric vectors. Lists, at times, are called recursive vectors because lists can contain other lists. The main difference between vectors and lists: Atomic vectors are homogeneous i.e., contain only one type (in my understanding). Lists are heterogeneous i.e., can have different types. Another related object: NULL. It is often used to represent the absence of a vector (unlike NA which is used to represent the absence of a value). NULL typically acts as a vector of length 0. Figure 20.1: The hierarchy of R’s vector types: Two key properties for each vector: Its type, which can be determined with typeof(). typeof(letters) typeof(1:10) Its length, which can be determined with length(). x1 &lt;- list(&quot;a&quot;, &quot;b&quot;, 1:10); length(x1) x2 &lt;- c(&quot;a&quot;, &quot;b&quot;); length(x2) Qn: does this imply that the length of a list is the # of elements in a list for example (x1)? Vectors can also contain arbitrary additional metadata in the form of attributes. Which are then used to create augmented vectors which build on additional behaviour. There are three important types of augmented vectors: Factors are built on top of integer vectors. Dates and date-times are built on top of numeric vectors. Data frames and tibbles are built on top of lists. "],["important-types-of-atomic-vector-2.html", "26.3 Important types of atomic vector", " 26.3 Important types of atomic vector The four most important types of atomic vectors: logical, integer, double, and character. Note: Raw and complex are rarely used during a data analysis, hence not part of this of discussion. 26.3.1 Logical Simplest type of atomic vector –&gt; can take only three possible values: FALSE, TRUE, and NA. They are constructed with comparison operators. OR, can create them by hand with c(): 1:10 %% 3 == 0 c(TRUE, TRUE, FALSE, NA) Qn: what exactly is %% doing here? I understand is x modulus y… 26.3.2 Numeric As learnt, integer and double are known collectively as numeric vectors. In R, numbers are doubles by default. To create an integer, place L after the number. typeof(1) typeof(1L) 1.5L Note: the warning after running 1.5L is because that integers only take whole numbers. I think. Two important differences between doubles and integers: Doubles are approximations. They represent floating point numbers that can’t be precisely represented with a fixed amount of memory. Therefore, we should consider all doubles as approximations. E.g., the square root of two: (x3 &lt;- sqrt(2) ^ 2) options(scipen = 999) x3 - 2 Side note: options(scipen = 999) to remove the scientific numbers as I often confuse reading e- or e+. When working with floating point numbers, it is common that the calculations include some approximation. Hence, when we compare floating point numbers we should use dplyr::near() instead of == as it allows for some numerical tolerance. (what does this mean?) dplyr::near(1.745, 2) # compares if 1.745 is the same as 2 # FALSE Integers have one special value: NA while doubles have four: NA, NaN, Inf and -Inf. NaN, Inf and -Inf can arise during division: c(-1, 0, 1) / 0 To check for these special values, let’s use the helper functions is.finite(), is.infinite(), and is.nan() instead of using ==. is.finite(c(-1, 0, 1) / 0) is.infinite(c(-1, 0, 1) / 0) is.na(c(-1, 0, 1) / 0) is.nan(c(-1, 0, 1) / 0) 26.3.3 Character Most complex atomic vector because each element of a character vector is a string, and a string contains an arbitrary amount of data. R uses a global string pool. Implying that each unique string is only stored in memory once. And every use of the string points to that representation. This reduces the amount of memory needed by duplicated strings. To see this, let’s use pryr::object_size(): x &lt;- &quot;This is a reasonably long string.&quot; pryr::object_size(x) y &lt;- rep(x, 1000) pryr::object_size(y) y doesn’t take up 1,000x as much memory as x, because each element of y is just a pointer to that same string. A pointer is 8 bytes, so 1000 pointers to a 152 B string is 8 * 1000 + 152 = 8.14 kB. 26.3.4 Missing values Each atomic vector has its own missing value: NA # logical NA_integer_ # integer NA_real_ # double NA_character_ # character But we don’t need to know about these different types since we can always use NA and it’ll be converted to the correct type using the implicit coercion rules. However, there are some functions that are strict about their inputs, so it’s useful to have this knowledge sitting in your back pocket so you can be specific when needed. 26.3.5 Exercises Describe the difference between is.finite(x) and !is.infinite(x). (x &lt;- c(-1/0, 0/0, 1/0, 5, 5L, NA)) is.finite(x) is.infinite(x) !is.infinite(x) is.finite() function does consider non-missing numeric values to be finite, and -Inf, NaN, Inf are considered not to be finite. is.infinite() considers only -Inf and Inf as infinite. Hence, !is.infinite() considers -Inf and Inf to be finite while non-missing numeric values, NaN, and NA not to be infinite. Read the source code for dplyr::near() (Hint: to see the source code, drop the ()). How does it work? dplyr::near() It doesn’t check equality as I first thought, but it checks if two numbers are within a certain tolerance (tol), usually given as .Machine$double.eps^0.5, which is the smallest floating point number that the computer can represent. (Good to know!!) A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research. help(integer) help(double) For integers vectors, R uses a 32-bit representation. I.e., it can represent \\(2^{32}\\) different values with the integers. But one of these values is set aside for NA_integer_. .Machine$integer.max .Machine$integer.max + 1L The range of integers values represented in R is \\(+- 2^{31}-1\\). Hence, the maximum integer is \\(2^{31}-1\\) instead of \\(2^{32}\\) because 1 bit is used to represent the sign \\((+ -)\\) and one value is to represent \\(NA_integer_\\). An integer greater than that value, R will return NA values. For double vectors, R uses a 64-bit representation, i.e., they can hold up to \\(2^{64}\\) values. But, some of those values are assigned to special values: -Inf, Inf, NA_real_, and NaN. .Machine$double.xmax Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise. The difference between conversion of a double to an integer differs in how they deal with the fractional part of the double. Round down, towards \\(-\\infty\\) i.e., taking the floor of a number –&gt; floor(). Round up, towards \\(\\infty\\) i.e., taking the ceiling of a number –&gt; ceiling(). Round towards zero –&gt; trunc() and as.integer(). Round away from zero. Round to the nearest integer. If ties exists, then numbers are defined with a fractional part of 0.5? Round half down, towards \\(-\\infty\\). Round half up, towards \\(\\infty\\) Round half towards zero Round half away from zero Round half towards the even integer –&gt; round(). Round half towards the odd integer. tibble( x = c(1.8, 1.5, 1.2, 0.8, 0.5, 0.2, -0.2, -0.5, -0.8, -1.2, -1.5, -1.8), `Round down` = floor(x), `Round up` = ceiling(x), `Round towards zero` = trunc(x), `Nearest, round half to even` = round(x) # 0.5 is rounded to 0 ) What functions from the readr package allow you to turn a string into logical, integer, and double vector? parse_logical() parses logical values, which can appear as variations of TRUE/FALSE or 1/0. parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;1&quot;, &quot;0&quot;, &quot;true&quot;, &quot;t&quot;, &quot;NA&quot;)) parse_integer() parses integer values. parse_integer(c(&quot;1235&quot;, &quot;0134&quot;, &quot;NA&quot;)) In case of any non-numeric characters in the string such as commas, decimals, parse_integer() will throw an error unlike parse_numeric() which ignores all the non-numeric characters before or after the first number. parse_integer(c(&quot;1000&quot;, &quot;$1,000&quot;, &quot;10.00&quot;)) parse_number(c(&quot;1.0&quot;, &quot;3.5&quot;, &quot;$1,000.00&quot;, &quot;NA&quot;, &quot;ABCD12234.90&quot;, &quot;1234ABC&quot;, &quot;A123B&quot;, &quot;A1B2C&quot;)) "],["using-atomic-vectors-2.html", "26.4 Using atomic vectors", " 26.4 Using atomic vectors Let’s review some of the important tools for working with the different types of atomic vectors: How to convert from one type to another, and when that happens automatically. How to tell if an object is a specific type of vector. What happens when you work with vectors of different lengths. How to name the elements of a vector. How to pull out elements of interest. 26.4.1 Coercion We can coerce or convert one type of vector to another in two ways: Explicit coercion -&gt; call a function like as.logical(), as.integer(), as.double(), or as.character(). Before doing this, check the type of the vector. For example, you may need to tweak your readr col_types specification. Implicit coercion -&gt; use a vector in a specific context that expects a certain type of vector. For example, using a logical vector with a numeric summary function or using a double vector where an integer vector is expected. Our focus here will be implicit coercion as explicit coercion is relatively rarely used in data analysis plus easy to understand. An important type of implicit coercion: using a logical vector in a numeric context. TRUE is converted to 1 and FALSE is converted to 0. Hence, summing the logical vector is the # of trues and the mean of a logical vector is the proportion of trues. x &lt;- sample(20, 100, replace = TRUE) y &lt;- x &gt; 10 sum(y) # how many are greater than 10? mean(y) # what proportion are greater than 10? Or, some code that relies on implicit coercion in the opposite direction, from integer to logical: if (length(x)) { # do something } Here, 0 is converted to FALSE and everything else is converted to TRUE. For easier understanding of the code, let’s be explicit: length(x) &gt; 0. NOTE1: When we create a vector containing multiple types with c(): the most complex type always wins. –&gt; Aha moment! typeof(c(TRUE, 1L)) #integer wins typeof(c(1L, 1.5)) #double wins #why? Thinking here, because integer is created from a double? typeof(c(1.5, &quot;a&quot;)) #character wins NOTE2: An atomic vector can not only have a mix of different types since the type is a property of the complete vector, not the individual elements. For a mix of multiple types in the same vector, use a list. 26.4.2 Test functions Suppose we want to have different things based on the type of vector: One option is to use typeof(). Or, use a test function which returns a TRUE or FALSE. Not recommended: base R functions -&gt; is.vector() and is.atomic(). Instead let’s use the is_* functions provided by purrr , summarised below. 26.4.3 Scalars and recycling rules Not only does R implicitly coerce the types of vectors to be compatible, but it also implicitly coerce the length of vectors. This is called vector recycling because the shorter vector is repeated (or recycled) to the same length as the longer vector. Mostly useful when we are mixing vectors and “scalars”. Note, R doesn’t have scalars instead, a single number is a vector of length 1. Since there are no scalars, most built-in functions are vectorised meaning that they will operate on a vector of numbers. Hence, such a code will work: sample(10) + 100 runif(10) &gt; 0.5 What happens if we add two vectors of different lengths? 1:10 + 1:2 R expands the shortest vector to the same length as the longest –&gt; recycling. But what if the length of the longer is not an integer multiple of the length of the shorter: 1:10 + 1:3 Vector recycling can silently conceal the problem, hence, the vectorised functions in tidyverse will throw errors when recycling anything other than a scalar. We can use rep() to do recycling ourselves. tibble(x = 1:4, y = 1:2) tibble(x = 1:4, y = rep(1:2, 2)) tibble(x = 1:4, y = rep(1:2, each = 2)) 26.4.4 Naming vectors We can name all types of vectors during creation with c(): c(x = 1, y = 2, z = 4) Or, with purrr::set_names(): set_names(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) Why name vectors? Because are useful in subsetting. 26.4.5 Subsetting To filter vectors, we use the subsetting function -&gt; [ and is called like x[a].There are four types of things that you can subset a vector with: A numeric vector containing only integers, and these must either be all positive, all negative, or zero. Subsetting with positive integers keeps the elements at those positions: x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;) x[c(3, 2, 5)] If we repeat a position, we can actually make a longer output than input: x[c(1, 1, 5, 5, 5, 2)] Negative values drop the elements at the specified positions: x[c(-1, -3, -5)] It’s an error to mix positive and negative values: x[c(1, -1)] The error message mentions subsetting with zero, which returns no values: x[0] This is useful if we want to create unusual data structures to functions with. (Jon, please expound!) Subsetting with a logical vector keeps all values corresponding to a TRUE value; often useful in conjunction with the comparison functions. x &lt;- c(10, 3, NA, 5, 8, 1, NA) # All non-missing values of x x[!is.na(x)] # All even (or missing!) values of x x[x %% 2 == 0] If you have a named vector, you can subset it with a character vector: x &lt;- c(abc = 1, def = 2, xyz = 5) x[c(&quot;xyz&quot;, &quot;def&quot;)] We can also use a character vector to duplicate individual entries. x[c(&quot;xyz&quot;, &quot;xyz&quot;, &quot;def&quot;, &quot;def&quot;)] The simplest type of subsetting is nothing, x[], which returns the complete x. This is mostly useful when subsetting matrices (and other high dimensional structures) because we can select all the rows or all the columns, by leaving that index blank. E.g., if x is 2d, x[1, ] selects the first row and all the columns. Learn more about the applications of subsetting: “Subsetting” chapter of Advanced R: http://adv-r.had.co.nz/Subsetting.html#applications. An important difference between [ and [[ -&gt; [[ extracts only a single element, and always drops names. Use it whenever we want to make it clear that we’re extracting a single item, as in a for loop. 26.4.6 Exercises What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))? x &lt;- c(-Inf, -1, 0, 1, Inf, NA, NaN) mean(is.na(x)) sum(!is.finite(x)) mean(is.na(x)) calculates the proprtion of missing (NA) and not-a-number (NaN) values in a vector. The result of 0.286 is equal to 2 / 7 as expected. sum(!is.finite(x)) calculates the number of elements in the vector that are equal to missing (NA), not-a-number (NaN), or infinity (Inf). Carefully read the documentation of is.vector(). What does it actually test for? Why does is.atomic() not agree with the definition of atomic vectors above? is.vector() checks whether an object has no attributes other than names. is.vector(list(a = 1, b = 2)) But any object that has an attribute apart from names is not: x &lt;- 1:10 attr(x, &quot;something&quot;) &lt;- TRUE is.vector(x) is.atomic() explicitly checks whether an object is one of the atomic types (“logical”, “integer”, “numeric”, “complex”, “character”, and “raw”) or NULL. is.atomic(1:10) is.atomic(list(a = 1)) is.atomic() will consider objects to be atomic even if they have extra attributes. is.atomic(x) Compare and contrast setNames() with purrr::set_names(). setNames() takes two arguments, a vector to be named and a vector of names to apply to its elements. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) setNames(nm = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) set_names() has more ways to set names than setNames(). We can specify the names the same way as setNames(): purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The names can also be specified as unnamed arguments: purrr::set_names(1:4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) set_names() will name an object with itself if no nm argument is provided (the opposite of setNames() behavior). purrr::set_names(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) The main difference between set_names() and setNames() is that set_names() allows for using a function or formula to transform the existing names. purrr::set_names(c(a = 1, b = 2, c = 3), toupper) purrr::set_names(c(a = 1, b = 2, c = 3), ~toupper(.)) set_names() function also checks that the length of the names argument is the same length as the vector that is being named, and will raise an error if it is not. purrr::set_names(1:4, c(&quot;a&quot;, &quot;b&quot;)) setNames() function will allow the names to be shorter than the vector being named, and will set the missing names to NA. setNames(1:4, c(&quot;a&quot;, &quot;b&quot;)) Create functions that take a vector as input and returns: The last value. Should you use [ or [[? The elements at even numbered positions. Every element except the last value. Only even numbers (and no missing values). Why is x[-which(x &gt; 0)] not the same as x[x &lt;= 0]? What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist? "],["recursive-vectors-lists-2.html", "26.5 Recursive vectors (lists)", " 26.5 Recursive vectors (lists) Lists can contain other lists implying that are more complex than atomic vectors. Hence, suitable to represent hierarchical or tree-like structures. Use list() to create lists. (xl &lt;- list(1, 2, 3)) We use the function str() to assess the structure. str(xl) dplyr::glimpse(xl) #seems one and the same thing? Lists can be named: xl_named &lt;- list(a = 1, b = 2, c = 3) str(xl_named) list() can contain a mix of objects unlike atomic vectors. yl &lt;- list(&quot;a&quot;, 1L, 1.5, TRUE) str(yl) Lists can contain other lists! zl &lt;- list(list(1, 2), list(3, 4)) str(zl) 26.5.1 Visualising lists Let’s see a visual representation of lists. E.g., x1 &lt;- list(c(1, 2), c(3, 4)) x2 &lt;- list(list(1, 2), list(3, 4)) x3 &lt;- list(1, list(2, list(3))) A visual drawing of the lists: There are three principles: Lists have rounded corners. Atomic vectors have square corners. Children are drawn inside their parent, and have a slightly darker background to make it easier to see the hierarchy. The orientation of the children (i.e. rows or columns) isn’t important, a row or column orientation are picked to either save space or illustrate an important property in the example. ?? 26.5.2 Subsetting We can subset lists using three ways, let’s see the example below. a &lt;- list(a = 1:3, b = &quot;a string&quot;, c = pi, d = list(-1, -5)) [ extracts a sub-list. And the result will always be a list. str(a[1:2]) str(a[4]) We can also subset lists with a logical, integer or character vector as seen in vectors. [[ extracts a single component from a list. It removes a level of hierarchy from the list. str(a[[1]]) str(a[[4]]) $ is a shorthand to extract named elements of a list. It works similarly to [[ except that you don’t need to use quotes. a$a a[[&quot;a&quot;]] Difference between [ and [[ is important for lists: [[ drills down into the list while [ returns a new, smaller list. Let’s compare the code and output above with the visual shown below. 26.5.3 Lists of condiments Let’s discuss an illustration of the difference between [ and [[ to solidify our understanding! :) Below we see an usual pepper shaker, and let it be our list x. x[1] is a pepper shaker containing a single pepper packet: x[2] would look the same, but would contain the second packet. x[1:2] would be a pepper shaker containing two pepper packets. x[[1]] is: x[[1]][[1]] to get the content of the pepper package: 26.5.4 Exercises Draw the following lists as nested sets: list(list(list(list(list(list(a)))))) list(a, b, list(c, d), list(e, f)) To draw pretty a visual diagram, refer to DiagramR R Package to render Graphviz diagrams. But what I have is hand-drawn. Not pretty!! :) For a: For b: 2. What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble? Subsetting a tibble works the same way as a list; a data frame can be thought of as a list of columns. The key difference between a list and a tibble -&gt; all the elements (columns) of a tibble must have the same length (number of rows). Lists can have vectors with different lengths as elements. x &lt;- tibble(a = 1:2, b = 3:4) x[[&quot;a&quot;]] x[&quot;a&quot;] x[1] x[1, ] "],["attributes-2.html", "26.6 Attributes", " 26.6 Attributes Any vector can contain arbitrary additional metadata through its attributes. Can be thought as named list of vectors that can be attached to any object. We can get and set individual attribute values with attr() or see them all at once with attributes(). x &lt;- 1:10 attr(x, &quot;greeting&quot;) attr(x, &quot;greeting&quot;) &lt;- &quot;Hi!&quot; attr(x, &quot;farewell&quot;) &lt;- &quot;Bye!&quot; attributes(x) Three very important attributes that used to implement fundamental parts of R: Names are used to name the elements of a vector. Dimensions (dims, for short) make a vector behave like a matrix or array. Class is used to implement the S3 object oriented system. Note: We have learnt of the names, and we won’t discuss matrices in this discussion as matrices aren;t used in this book! Class controls how generic functions work. Generic functions are key to object programming since they make functions behave differently for different classes of input. The discussion of object programming is covered in details in Advanced R: http://adv-r.had.co.nz/OO-essentials.html#s3 An example of generic function: as.Date The call to “UseMethod” means that this is a generic function, and it calls a specific method, a function, based on the class of the first argument. Note: All methods are functions; not all functions are methods. To list all the methods for a generic, use methods(): methods(&quot;as.Date&quot;) For example, if x is a character vector, as.Date() will call as.Date.character(); if it’s a factor, it’ll call as.Date.factor(). We can see the specific implementation of a method with getS3method(): getS3method(&quot;as.Date&quot;, &quot;default&quot;) getS3method(&quot;as.Date&quot;, &quot;numeric&quot;) The most important S3 generic is print() -&gt; controls how the object is printed when we type its name at the console. Subsetting functions: [, [[ and $ are other important generics. "],["augmented-vectors-2.html", "26.7 Augmented vectors", " 26.7 Augmented vectors Atomics vectors and lists are building blocks for other important vector types like factors and dates. These are called augmented vectors because they are vectors with additional attributes, including class. Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. Here, we will discuss four important augmented vectors: Factors Dates Date-times Tibbles 26.7.1 Factors They are designed to represent categorical data that can take a fixed set of possible values. They are built on top of integers and have a levels attribute: x_factor &lt;- factor(c(&quot;ab&quot;, &quot;cd&quot;, &quot;ab&quot;), levels = c(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;)) typeof(x_factor) attributes(x_factor) 26.7.2 Dates and date-times In R, dates are numeric vectors that represent the number of days since 1 January 1970. x_date &lt;- as.Date(&quot;1971-01-01&quot;) unclass(x_date) typeof(x_date) attributes(x_date) Dates-times are numeric vectors with class POSIXct that represent the # of seconds since 1 January 1970. Note: “POSIXct” stands for “Portable Operating System Interface”, calendar time. x_date_time &lt;- lubridate::ymd_hm(&quot;1970-01-01 01:00&quot;) unclass(x_date_time) typeof(x_date_time) attributes(x_date_time) The tzone attribute is optional–&gt; controls how the time is printed, not what absolute time it refers to. attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Pacific&quot; x_date_time attr(x_date_time, &quot;tzone&quot;) &lt;- &quot;US/Eastern&quot; x_date_time Qn: how to find the other time zones? Another type of date-times called POSIXlt which are built on top of named lists: y_date_time &lt;- as.POSIXlt(x_date_time) typeof(y_date_time) attributes(y_date_time) POSIXlts are rare inside the tidyverse. But pop up in base R, because they are needed to extract specific components of a date, like the year or month. Since lubridate provides helpers for us to do this instead, we don’t need them. POSIXct’s are always easier to work with, so if we have a POSIXlt, we should always convert it to a regular data time lubridate::as_date_time(). 26.7.3 Tibbles Tibbles are augmented lists. They have class “tbl_df” + “tbl” + “data.frame”, and names (column) and row.names attributes: tb &lt;- tibble::tibble(x = 1:5, y = 5:1) typeof(tb) attributes(tb) The difference between a tibble and a list: All the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint. Traditional data.frames have a very similar structure: df &lt;- data.frame(x = 1:5, y = 5:1) typeof(df) attributes(df) The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default. 26.7.4 Exercises What does hms::hms(3600) return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use? (x &lt;- hms::hms(3600)) class(x) attributes(x) hms::hms returns an object of class, and prints the time in “%H:%M:%S” format. The attributes it uses are units and class Try and make a tibble that has columns with different lengths. What happens? tibble(x = 1, y = 1:5) The “scalar” 1 is recycled to the length of the longer vector. tibble(x = 1:3, y = 1:4) Creating a tibble with two vectors of different lengths will give an error. Based on the definition above, is it ok to have a list as a column of a tibble? tibble(x = 1:3, y = list(&quot;a&quot;, 1, list(1:3))) Tibbles can have atomic vectors (with additional attributes)of different types: doubles, character, integers, logical, factor, date. Hence, they can have a list vector as long as its the same length! "],["meeting-videos-25.html", "26.8 Meeting Videos", " 26.8 Meeting Videos 26.8.1 Cohort 5 Meeting chat log 00:39:35 Jon Harmon (jonthegeek): .Machine$double.eps 00:40:36 Jon Harmon (jonthegeek): &gt; .Machine$integer.max [1] 2147483647 00:41:23 Federica Gazzelloni: ?`.Machine` 00:42:11 Ryan Metcalf: Some really fun reading about CPU “inner” workings: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/ 00:42:35 Jon Harmon (jonthegeek): &gt; typeof(.Machine$integer.max + 1) [1] &quot;double&quot; 00:42:55 Jon Harmon (jonthegeek): &gt; .Machine$integer.max + 1L [1] NA Warning message: In .Machine$integer.max + 1L : NAs produced by integer overflow 00:43:52 Becki R. (she/her): thanks for the link, Ryan! 00:44:44 Jon Harmon (jonthegeek): &gt; sqrt(2)**2 == 2 [1] FALSE 00:45:16 Jon Harmon (jonthegeek): &gt; dplyr::near(sqrt(2)**2, 2) [1] TRUE 00:57:52 Ryan Metcalf: Not directly related to Cache or RAM….But similar. It is where you get FAT, FAT32, NTFS, ExFat, EXT, EXT3, etc…etc… there are hundreds of file allocation. 00:59:29 Sandra Muroy: thanks Ryan! 01:02:08 Becki R. (she/her): I&#39;m finding the info on computer architecture (?) fascinating so I appreciate the detour. 01:03:05 Sandra Muroy: I&#39;m glad :) 01:10:01 Ryan Metcalf: I think I just had an epiphany!!! Is this were the “Big Endian” and “Little Endian” comes in? The leading bit representing positive and negative? 01:10:27 Jon Harmon (jonthegeek): &gt; typeof(0L) [1] &quot;integer&quot; 01:12:42 Jon Harmon (jonthegeek): &gt; .Machine$double.xmax [1] 1.797693e+308 01:15:53 Jon Harmon (jonthegeek): &gt; 1:10 + 1 [1] 2 3 4 5 6 7 8 9 10 11 01:16:19 Jon Harmon (jonthegeek): &gt; 1:10 + 2:11 [1] 3 5 7 9 11 13 15 17 19 21 Meeting chat log 00:03:09 Becki R. (she/her): I have a buzz in my audio so I&#39;m staying muted. 00:30:48 Federica Gazzelloni: http://adv-r.had.co.nz/Subsetting.html 00:33:31 Jon Harmon (jonthegeek): mtcars[&quot;mpg&quot;] mtcars[[&quot;mpg&quot;]] 00:35:19 Jon Harmon (jonthegeek): months &lt;- purrr::set_names(month.name, month.abb) 00:35:40 Jon Harmon (jonthegeek): months[&quot;Jan&quot;] 00:35:46 Jon Harmon (jonthegeek): Jan &quot;January&quot; 00:36:10 Jon Harmon (jonthegeek): &gt; months[[&quot;Jan&quot;]] [1] &quot;January&quot; 00:38:28 Federica Gazzelloni: it acts like unlist() 00:38:48 Jon Harmon (jonthegeek): &gt; unlist(mtcars[&quot;mpg&quot;]) mpg1 mpg2 mpg3 mpg4 mpg5 mpg6 mpg7 mpg8 mpg9 mpg10 mpg11 mpg12 mpg13 mpg14 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 mpg15 mpg16 mpg17 mpg18 mpg19 mpg20 mpg21 mpg22 mpg23 mpg24 mpg25 mpg26 mpg27 mpg28 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 mpg29 mpg30 mpg31 mpg32 15.8 19.7 15.0 21.4 00:39:13 Jon Harmon (jonthegeek): &gt; unname(unlist(mtcars[&quot;mpg&quot;])) [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:39:29 Jon Harmon (jonthegeek): single &lt;- mtcars[&quot;mpg&quot;] 00:39:50 Jon Harmon (jonthegeek): &gt; attributes(single) &lt;- NULL &gt; single [[1]] [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 [17] 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4 00:42:51 Jon Harmon (jonthegeek): &gt; str(months[[1]]) chr &quot;January&quot; &gt; str(months[1]) Named chr &quot;January&quot; - attr(*, &quot;names&quot;)= chr &quot;Jan&quot; 00:43:41 Jon Harmon (jonthegeek): ?`[` 00:44:15 Jon Harmon (jonthegeek): The most important distinction between [, [[ and $ is that the [ can select more than one element whereas the other two select a single element. 00:47:28 Ryan Metcalf: BRB 00:56:31 Jon Harmon (jonthegeek): The tangent I obsessed on just now: &gt; pillar:::glimpse.default function (x, width = NULL, max.level = 3, ...) { str(x, width = get_width_glimpse(width), max.level = max.level, ...) invisible(x) } (huh, &quot;glimpse&quot; technically comes from the {pillar} package) 01:12:09 Jon Harmon (jonthegeek): &gt; round(c(1.5, 2.5, 3.5, 4.5)) [1] 2 2 4 4 01:14:08 Jon Harmon (jonthegeek): Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2. However, this is dependent on OS services and on representation error (since e.g. 0.15 is not represented exactly, the rounding rule applies to the represented number and not to the printed number, and so round(0.15, 1) could be either 0.1 or 0.2). 26.8.2 Cohort 6 Meeting chat log 00:36:56 Daniel Adereti: Lucky I am not a python user. lol 00:37:05 Marielena Soilemezidi: 😂 00:38:03 Marielena Soilemezidi: python will come and get you too, Daniel! 00:38:18 Daniel Adereti: lol! can&#39;t avoid it! 00:42:11 Daniel Adereti: Unfortunately, we have a strict 18 mins to end the lessons, let&#39;s see where we end up. Thanks "],["tibbles-3.html", "Chapter 27 Tibbles", " Chapter 27 Tibbles Learning objectives: Create tibbles in various ways. Compare and contrast tibbles with base R data.frames. Convert a tibble back to a data.frame, when needed. "],["slide-1-1.html", "27.1 Slide 1", " 27.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-1.html", "27.2 Slide 2", " 27.2 Slide 2 Slide contents. "],["meeting-videos-26.html", "27.3 Meeting Videos", " 27.3 Meeting Videos 27.3.1 Cohort 5 Meeting chat log 00:04:33 Susan Neilson: Yes! 00:27:11 shamsuddeen: https://stackoverflow.com/questions/51901398/what-does-a-tilde-in-front-of-a-single-variable-mean-facet-wrap/53835451#53835451 00:27:30 Federica Gazzelloni: https://www.rdocumentation.org/packages/tibble/versions/3.1.2/topics/tribble 00:27:54 shamsuddeen: http://uc-r.github.io/integer_double/ 00:28:15 shamsuddeen: 1L, 2L 00:28:50 Federica Gazzelloni: tribble() creates tibbles using an easier to read row-by-row layout. 00:37:49 Becki R. (she/her): the audio is out 01:08:20 Susie N.: I have to head out everyone - thank you all so much for an excellent class and discussion! 01:08:32 Federica Gazzelloni: info for lealeft: https://rstudio.github.io/leaflet/map_widget.html 01:09:32 Federica Gazzelloni: the documentation says: ~ x means the variable x in the data object 01:10:21 shamsuddeen: https://dplyr.tidyverse.org/reference/pull.html 01:10:44 Njoki Njuki Lucy: thanks you 01:10:51 Njoki Njuki Lucy: thank* 01:12:24 shamsuddeen: Strings 01:12:35 shamsuddeen: Chapter 01:12:38 Federica Gazzelloni: thanks 01:12:40 shamsuddeen: I can do "],["iteration.html", "Chapter 28 Iteration", " Chapter 28 Iteration Learning objectives: Reduce duplication in code by iterating over a pattern using a for loop. Modify an object using a for loop. Recognize the three basic ways to loop over a vector using a for loop. Handle unknown output lengths by using a more complex result and then combining the result after the for loop. Handle unknown sequence lengths with a while loop. Reduce duplication in code by passing a function as an argument to a function (functional programming). Make iteration code easier to read with the map family of functions from {purrr}. Make map code faster to type with shortcuts. Compare the map family of functions to the base R apply family. Deal with errors and other output using the {purrr} adverbs: safely, possibly, and quietly. Map over multiple arguments with the map2 family and the pmap family from {purrr}. Map over multiple functions with the invoke_map family from {purrr} and its replacements (see ?purrr::invoke_map, “Life cycle”). Call a function for its side effects using the walk family of functions from {purrr}. Recognize the other iteration functions from {purrr}. "],["intro.html", "28.1 Intro", " 28.1 Intro Good iteration - Pre-allocate the shape/structure and then fill in the data. Imperative programming - for loops and while loops make iteration very explicit. Functional programming - common for loop patterns get their own functions, so you can streamline your code even more. Packages: library(tidyverse), library(purrr) "],["for-loops.html", "28.2 For loops", " 28.2 For loops Each loop has three components: output - Allocate enough space for your for loop. A loop that grows at each iteration will be very “slow”. sequence - What to loop over. seq_along() is a safe version of the familiar 1:length(x): if you have a zero-length vector, it will tell you. body - This is the code that does the work. "],["for-loop-variations.html", "28.3 For loop variations", " 28.3 For loop variations There are four variations on the basic theme of the for loop: Modifying an existing object, instead of creating a new object. Looping over names or values, instead of indices. There are three basic ways to loop over a vector. for (i in seq_along(df)) for (x in xs) - good for side-effects for (nm in names(xs)) - creates name to access value with x[[nm]] Handling outputs of unknown length. unlist() flattens a list of vectors into a single vector, purrr::flatten_dbl() is stricter — it will throw an error if the input isn’t a list of doubles. Handling sequences of unknown length. Use a while loop. "],["for-loops-vs.-functionals.html", "28.4 For loops vs. functionals", " 28.4 For loops vs. functionals For loops are not as important in R as they are in other languages because R is a functional programming language. This means that it’s possible to put for loops in a function, and call that function instead of using the for loop directly. Base R and the purrr package have functions for many common loops. "],["the-map-functions.html", "28.5 The map functions", " 28.5 The map functions map(.x, .f, ...) makes a list. map_lgl(.x, .f, ...) makes a logical vector. map_int(.x, .f, ...) makes an integer vector. map_dbl(.x, .f, ...) makes a double vector. map_chr(.x, .f, ...) makes a character vector. Shortcuts with purrr: a one-sided formula creates an anonymous function use a string to extract named components Use an integer to select elements by position Base R: lapply(X, FUN, ...) makes a list (map is more consistent) sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) wrapper around lapply vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) safe alternative to sapply, can make a matix "],["dealing-with-failure.html", "28.6 Dealing with failure", " 28.6 Dealing with failure safely() - designed to work with map result is the original result. If there was an error, this will be NULL. error is an error object. If the operation was successful, this will be NULL. possibly() - you give it a default value to return when there is an error. quietly() - instead of capturing errors, it captures printed output, messages, and warnings. "],["mapping-over-multiple-arguments.html", "28.7 Mapping over multiple arguments", " 28.7 Mapping over multiple arguments map2() and pmap() functions are for multiple related inputs that you need iterate along in parallel. Invoking different functions Read the help in purrr on these functons. If you need to do this read Advanced R. invoke_map is retired. "],["walk.html", "28.8 Walk", " 28.8 Walk walk() is an alternative to map() that you use when you want to call a function for its side effects, rather than for its return value. walk2 and pwalk - more useful than walk. "],["other-patterns-of-for-loops.html", "28.9 Other patterns of for loops", " 28.9 Other patterns of for loops Predicate functions - return TRUE or FALSE keep and discard - keep elements are TRUE and discard are FALSE. some and every - determine if TRUE for any (some) or all (every) detect and detect_index - detect finds first element where TRUE, and detect_index returns the position head_while() and tail_while() - while TRUE take elements from start (head_while) or end (tail_while) Reduce and accumulate reduce() takes a “binary” function, applies it repeatedly to a list until there is only a single element left. accumulate() keeps all the interim results. "],["meeting-videos-27.html", "28.10 Meeting Videos", " 28.10 Meeting Videos 28.10.1 Cohort 5 Meeting chat log 00:03:23 Becki R. (she/her): I&#39;m having trouble with a buzz again 00:03:37 Njoki Njuki Lucy: I so look forward to the discussion. I have been struggling with understanding this particular chapter! :) 00:26:58 Jon Harmon (jonthegeek): &gt; x &lt;- purrr::set_names(month.name, month.abb) &gt; x 00:27:21 Jon Harmon (jonthegeek): x[[&quot;Jan&quot;]] 00:30:12 Jon Harmon (jonthegeek): results &lt;- purrr::set_names(vector(&quot;list&quot;, length(x)), names(x)) 00:35:10 lucus w: A data frame is simply a list in disguise 00:45:37 Njoki Njuki Lucy: It makes sense now, thanks! 00:48:05 Ryan Metcalf: Sorry team, I have to drop. Sister-in-law is stranded and needs a jump-start. I’ll finish watching the recording and catch any questions. 00:51:19 Jon Harmon (jonthegeek): &gt; paste(month.name, collapse = &quot;&quot;) [1] &quot;JanuaryFebruaryMarchAprilMayJuneJulyAugustSeptemberOctoberNovemberDecember&quot; &gt; paste(month.name, collapse = &quot; &quot;) [1] &quot;January February March April May June July August September October November December&quot; 01:09:10 Njoki Njuki Lucy: that&#39;s so cool! I wondered! Ha!! 01:10:30 Federica Gazzelloni: thanks Jon!! Meeting chat log 00:10:17 Becki R. (she/her): brb! 00:26:00 Njoki Njuki Lucy: does this mean, in this case, we will have 3 regression models? 00:26:21 Federica Gazzelloni: can you specify: mtcars%&gt;%map(.f= 00:27:12 Federica Gazzelloni: mtcars%&gt;%split(.$cyl)%&gt;%map(.f=lm(….)) 00:27:41 Ryan Metcalf: I’m reading it as `mpg` being dependent (y) and `wt` being independent. 00:29:08 Jon Harmon (jonthegeek): # A more realistic example: split a data frame into pieces, fit a # model to each piece, summarise and extract R^2 mtcars %&gt;% split(.$cyl) %&gt;% map(~ lm(mpg ~ wt, data = .x)) %&gt;% map(summary) %&gt;% map_dbl(&quot;r.squared&quot;) 00:29:55 Jon Harmon (jonthegeek): mtcars %&gt;% split(.$cyl) %&gt;% map(.f = ~ lm(mpg ~ wt, data = .x)) 00:30:22 Jon Harmon (jonthegeek): mtcars %&gt;% split(.$cyl) %&gt;% map(.f = lm(mpg ~ wt, data = .x)) 00:45:11 Federica Gazzelloni: coalesce() 01:17:01 Ryan Metcalf: Great Job Becki!!! 01:17:25 Becki R. (she/her): Thanks :) 28.10.2 Cohort 6 Meeting chat log 00:04:39 Marielena Soilemezidi: I&#39;ll be back in 3&#39;! No haste with the setup:) 00:04:52 Adeyemi Olusola: Ok 00:07:22 Adeyemi Olusola: Let me know when you return Meeting chat log 00:11:10 Marielena Soilemezidi: hello! :) 00:20:31 Marielena Soilemezidi: yep, it looks good! 00:46:18 Daniel Adereti: How does it get the list of 3? 00:47:55 Marielena Soilemezidi: sorry, got disconnected for some time, but I&#39;m back! 00:48:05 Daniel Adereti: No worries! 00:58:28 Adeyemi Olusola: olusolaadeyemi.ao@gmail.com ADD LEARNING OBJECTIVES HERE "],["r-markdown.html", "Chapter 29 R Markdown", " Chapter 29 R Markdown Learning objectives: Create R Markdown documents. Format text using Pandoc’s Markdown. Include R code chunks in an R Markdown document. Use chunk options to change what displays in an R Markdown document. Use knitr::kable to display formatted tables in an R Markdown document. Cache data in an R Markdown document. Set global chunk options in an R Markdown document. Embed inline code in an R Markdown document. "],["slide-1-2.html", "29.1 Slide 1", " 29.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-2.html", "29.2 Slide 2", " 29.2 Slide 2 Slide contents. "],["meeting-videos-28.html", "29.3 Meeting Videos", " 29.3 Meeting Videos 29.3.1 Cohort 5 Meeting chat log 00:03:37 Njoki Njuki Lucy: I agree with Ryan. 00:15:27 Ryan Metcalf: https://pandoc.org/ 00:20:48 Ryan Metcalf: Some extra reading material: https://www.w3.org/TR/WD-html40-970708/intro/sgmltut.html 00:28:14 Njoki Njuki Lucy: Qn, does anyone know why putting figure captions move figures to other positions? 00:33:58 Federica Gazzelloni: try with {r ….., fig.align =“center”} 00:35:01 Njoki Njuki Lucy: Thanks Federica, I&#39;ll give it a try :) 00:57:25 Ryan Metcalf: https://daringfireball.net/projects/markdown/ 00:58:59 Ryan Metcalf: The comment I’m making, there are many forms of Markdown, not all created equally. John Gruber originated Markdown syntax to make authoring easier. GitHub versus GitLab, versus RMarkdonw, etc... 01:02:40 Federica Gazzelloni: you can set your path: opts_chunk$set(cache.path = &quot; &quot;) 01:04:42 Federica Gazzelloni: https://bookdown.org/yihui/rmarkdown-cookbook/cache.html 01:06:13 Ryan Metcalf: https://quarto.org/ 01:07:57 Federica Gazzelloni: The most appropriate use case of caching is to save and reload R objects that take too long to compute in a code chunk 01:09:20 Njoki Njuki Lucy: no 01:09:26 Federica Gazzelloni: no 01:12:49 Njoki Njuki Lucy: I&#39;ll have to leave, thanks Becki! I look forward to the other part!! 01:12:53 Federica Gazzelloni: there is some more about the changing r session and the cache: https://www.r-bloggers.com/2021/07/caching-the-results-of-functions-of-your-r-package/ 01:13:02 Becki R. (she/her): Bye Lucy! 29.3.2 Cohort 6 Meeting chat log LOG "],["graphics-for-communication.html", "Chapter 30 Graphics for communication", " Chapter 30 Graphics for communication Learning objectives: Describe the contents of a plot with labels. Call out specific features of your data with annotations. Control how data maps to things you can see with scale_ functions. Control which data displays in a plot. Customize the non-data elements of your plot with themes. Save your plots. "],["tools-you-need-to-create-good-graphics.html", "30.1 Tools you need to create good graphics", " 30.1 Tools you need to create good graphics The Truthful Art, by Albert Cairo The book focuses on what you need to think about in order to create effective graphics. Resources: http://www.thefunctionalart.com/p/instructors-guide.html https://www.dropbox.com/s/gyqyz3hei7lhhmt/R_RESOURCES.txt?dl=0 https://exts.ggplot2.tidyverse.org/gallery/ "],["use-labels-and-annotations.html", "30.2 Use labels and annotations", " 30.2 Use labels and annotations First data set is about the Biochemical Oxygen Demand, found in {datasets} package, it is made of two variables: -Time -Demand BOD ## Time demand ## 1 1 8.3 ## 2 2 10.3 ## 3 3 19.0 ## 4 4 16.0 ## 5 5 15.6 ## 6 7 19.8 ggplot(BOD, aes(Time, demand)) + geom_point(size=2) + geom_smooth() + labs( title = &quot;Biochemical Oxygen Demand&quot;, subtitle = &quot;versus Time in an evaluation of water quality&quot;, caption = &quot;Originally from Marske (1967), \\nBiochemical Oxygen Demand Data Interpretation Using Sum of Squares Surface M.Sc. Thesis, \\nUniversity of Wisconsin – Madison.&quot;, y =&quot;Demand&quot;) + tvthemes::theme_avatar() Second dataset is found in the book and made of some random uniform distributions. Here we see how we can coustomise axis title with maths formula. df &lt;- tibble( x = runif(10), y = runif(10) ) ggplot(df, aes(x, y)) + geom_point(shape=21, stroke=2,size=5,fill=&quot;grey67&quot;,alpha=0.7) + labs( x = quote(sum(x[i] ^ 2, i == 1, n)), y = quote(alpha + beta + frac(delta, theta)) ) + tvthemes::theme_brooklyn99() Third dataset is the Annual Precipitation in US Cities, the set is made of one observation each column, about the average amount of precipitation (rainfall) in inches for each of 70 United States (and Puerto Rico) cities. Here we see how to add text to a plot with geom_text() precip[1:10] ## Mobile Juneau Phoenix Little Rock Los Angeles ## 67.0 54.7 7.0 48.5 14.0 ## Sacramento San Francisco Denver Hartford Wilmington ## 17.2 20.7 13.0 43.4 40.2 length(precip) ## [1] 70 cities &lt;- precip%&gt;%names df &lt;- data.frame(cities,precip) df %&gt;% arrange(precip) %&gt;% ggplot(aes(x=1:70,y=precip)) + geom_point(shape=21,color=&quot;white&quot;) + geom_line(size=0.5,linetype=&quot;dashed&quot;)+ geom_text(aes(label=cities,size=precip), hjust = &quot;right&quot;,nudge_x = -2, check_overlap = T) + labs(title=&quot;Trend of Annual Precipitation in US Cities&quot;, x=&quot;70 United States Cities&quot;, y=&quot;AVG precipitation (rainfall) in inches&quot;)+ tvthemes::theme_spongeBob()+ theme(legend.position = &quot;none&quot;) This is the Edgar Anderson’s Iris Data. It gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica. ggplot(iris,aes(Sepal.Length,Sepal.Width,group=Species))+ geom_point(aes(color=Species)) + geom_text(data=iris%&gt;% group_by(Species)%&gt;% filter(Sepal.Length==max(Sepal.Length))%&gt;% ungroup(), aes(label=Species), size=8, hjust=&quot;right&quot;, check_overlap = T) + hrbrthemes::theme_modern_rc() This is Fuel economy data from 1999 to 2008 for 38 popular models of cars. This dataset contains a subset of the fuel economy data that the EPA makes available on https://fueleconomy.gov/. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car. Here we learn how to set the lable in specific place inside the plot. label &lt;- mpg %&gt;% summarise( displ = max(displ), hwy = max(hwy), label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color=factor(hwy)),size=2) + geom_text(aes(label = label), data = label, color=&quot;grey40&quot;,size=6, vjust = &quot;top&quot;, hjust = &quot;right&quot;)+ ggthemes::theme_fivethirtyeight() + theme(legend.position = &quot;none&quot;) In particular for all the possibility we can refer to this plot for principal adjustments of the text inside the plot. Text adjutment position Other geoms for annotation: geom_hline() and geom_vline() to add reference lines. I often make them thick (size = 2) and white (colour = white), and draw them underneath the primary data layer. That makes them easy to see, without drawing attention away from the data. geom_rect() to draw a rectangle around points of interest. The boundaries of the rectangle are defined by aesthetics xmin, xmax, ymin, ymax. geom_segment() with the arrow argument to draw attention to a point with an arrow. Use aesthetics x and y to define the starting location, and xend and yend to define the end location. "],["scales.html", "30.3 Scales", " 30.3 Scales The scale_&lt;functions&gt; are very useful in many ways, among which is to set a color/fill scale for a particular plot, or to make modification of the x/y text axis. Here the dataset is made of random normal of 10 000 values. df &lt;- tibble( x = rnorm(10000), y = rnorm(10000) ) p1 &lt;- ggplot(df, aes(x, y)) + geom_hex() + coord_fixed() p2 &lt;- ggplot(df, aes(x, y)) + geom_hex() + viridis::scale_fill_viridis() + coord_fixed() library(patchwork) p1+p2 &amp; theme_linedraw() &amp; theme(legend.position = &quot;top&quot;) ## Warning: Computation failed in `stat_binhex()`: ## ## Computation failed in `stat_binhex()`: "],["themes.html", "30.4 Themes", " 30.4 Themes There are interesting packages available for adjusting the them of your plot in addition to the themes that are provided with {ggplot2} package: ggplot2 extensions - gallery {viridis} {hrbrthemes} {ggthemes} {tvthemes} … source: https://exts.ggplot2.tidyverse.org/gallery/ png "],["save-the-plot.html", "30.5 Save the plot", " 30.5 Save the plot ggsave(\"my-plot.pdf\") "],["meeting-videos-29.html", "30.6 Meeting Videos", " 30.6 Meeting Videos 30.6.1 Cohort 5 Meeting chat log 00:08:21 Jon Harmon (jonthegeek): https://twitter.com/skyetetra/status/1501268379386081285 00:13:33 Federica Gazzelloni: http://www.thefunctionalart.com/p/instructors-guide.html https://www.dropbox.com/s/gyqyz3hei7lhhmt/R_RESOURCES.txt?dl=0 https://exts.ggplot2.tidyverse.org/gallery/ 00:36:52 Njoki Njuki Lucy: in the ggplot() 01:09:05 Njoki Njuki Lucy: I am so interested 01:11:48 Becki R. (she/her): See you all next week! Meeting chat log 00:10:30 Ryan Metcalf: https://www.rstudio.com/conference/ 00:33:38 shamsuddeen: Yes 00:33:53 shamsuddeen: ISLR should be first ! 00:37:08 Ryan Metcalf: https://www.manning.com/books/human-in-the-loop-machine-learning?query=Human%20in%20the%20Loop 00:38:23 shamsuddeen: SMLTR 00:39:50 shamsuddeen: Human-in-the-Loop Machine Learning. When is this starting ? 00:40:10 shamsuddeen: ok 00:50:30 shamsuddeen: Any book on Torch coming? 00:54:25 shamsuddeen: Data Science at Command Line 2e: https://datascienceatthecommandline.com/2e/ 00:54:38 shamsuddeen: Wanna start this ! 01:01:01 Federica Gazzelloni: https://r4ds.io/clubdeck 01:12:22 shamsuddeen: Applied Predictive Modelling? 30.6.2 Cohort 6 Meeting chat log LOG "],["r-markdown-formats.html", "Chapter 31 R Markdown formats", " Chapter 31 R Markdown formats Learning objectives: Control R Markdown output with output formats and options. Recognize the available R Markdown document formats. Collaborate using R Markdown notebooks. Recognize the available R Markdown presentation formats. Build dashboards with {flexdashboard}. Add interactivity to R Markdown documents. Generate complete websites with R Markdown. Recognize other R Markdown formats. "],["slide-1-3.html", "31.1 Slide 1", " 31.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-3.html", "31.2 Slide 2", " 31.2 Slide 2 Slide contents. "],["meeting-videos-30.html", "31.3 Meeting Videos", " 31.3 Meeting Videos 31.3.1 Cohort 5 Meeting chat log 00:10:00 Jon Harmon (jonthegeek): bestbook.cool 00:11:26 Jon Harmon (jonthegeek): https://podcast.bestbook.cool/ 00:28:01 Jon Harmon (jonthegeek): happygitwithr.com 00:30:59 Jon Harmon (jonthegeek): Remind @Sandra Muroy to share the dlab GitHub stuff when this posts to our channel. There, I think that will tag you in the post! 00:32:44 Jon Harmon (jonthegeek): xaringan 00:36:45 Jon Harmon (jonthegeek): lol, it&#39;s just called {shinydashboard} 00:48:24 Becki R. (she/her): I definitely need help with that! 00:53:08 Jon Harmon (jonthegeek): It&#39;s been a while since we learned that! 2021-08-21: Chapter 6: Workflow: scripts: Ryan Metcalf 01:01:01 Jon Harmon (jonthegeek): {pak} = updated package tracker 01:01:48 Jon Harmon (jonthegeek): {targets} 01:03:00 Federica Gazzelloni: library(pkgsnap) 01:04:15 Jon Harmon (jonthegeek): devtools::install_version() 01:05:00 Jon Harmon (jonthegeek): ?remotes::install_version() 01:05:15 Jon Harmon (jonthegeek): install_version(&quot;devtools&quot;, &quot;&gt;= 1.12.0, &lt; 1.14&quot;) 01:07:07 Jon Harmon (jonthegeek): https://github.com/MangoTheCat/pkgsnap 01:11:32 Jon Harmon (jonthegeek): https://docs.ropensci.org/targets/ 01:11:46 Jon Harmon (jonthegeek): pkgdown 01:12:41 Jon Harmon (jonthegeek): https://rsample.tidymodels.org/ 01:13:21 Jon Harmon (jonthegeek): https://pkgdown.r-lib.org/ 01:13:32 Sandra Muroy: https://github.com/dlab-berkeley/Bash-Git 31.3.2 Cohort 6 Meeting chat log LOG "],["r-markdown-workflow.html", "Chapter 32 R Markdown workflow", " Chapter 32 R Markdown workflow Learning objectives: Communicate data analysis work with an analysis notebook. "],["slide-1-4.html", "32.1 Slide 1", " 32.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-4.html", "32.2 Slide 2", " 32.2 Slide 2 Slide contents. "],["meeting-videos-31.html", "32.3 Meeting Videos", " 32.3 Meeting Videos 32.3.1 Cohort 5 Meeting chat log 00:10:00 Jon Harmon (jonthegeek): bestbook.cool 00:11:26 Jon Harmon (jonthegeek): https://podcast.bestbook.cool/ 00:28:01 Jon Harmon (jonthegeek): happygitwithr.com 00:30:59 Jon Harmon (jonthegeek): Remind @Sandra Muroy to share the dlab GitHub stuff when this posts to our channel. There, I think that will tag you in the post! 00:32:44 Jon Harmon (jonthegeek): xaringan 00:36:45 Jon Harmon (jonthegeek): lol, it&#39;s just called {shinydashboard} 00:48:24 Becki R. (she/her): I definitely need help with that! 00:53:08 Jon Harmon (jonthegeek): It&#39;s been a while since we learned that! 2021-08-21: Chapter 6: Workflow: scripts: Ryan Metcalf 01:01:01 Jon Harmon (jonthegeek): {pak} = updated package tracker 01:01:48 Jon Harmon (jonthegeek): {targets} 01:03:00 Federica Gazzelloni: library(pkgsnap) 01:04:15 Jon Harmon (jonthegeek): devtools::install_version() 01:05:00 Jon Harmon (jonthegeek): ?remotes::install_version() 01:05:15 Jon Harmon (jonthegeek): install_version(&quot;devtools&quot;, &quot;&gt;= 1.12.0, &lt; 1.14&quot;) 01:07:07 Jon Harmon (jonthegeek): https://github.com/MangoTheCat/pkgsnap 01:11:32 Jon Harmon (jonthegeek): https://docs.ropensci.org/targets/ 01:11:46 Jon Harmon (jonthegeek): pkgdown 01:12:41 Jon Harmon (jonthegeek): https://rsample.tidymodels.org/ 01:13:21 Jon Harmon (jonthegeek): https://pkgdown.r-lib.org/ 01:13:32 Sandra Muroy: https://github.com/dlab-berkeley/Bash-Git 32.3.2 Cohort 6 Meeting chat log LOG "],["model-basics.html", "Model basics", " Model basics Learning objectives: Evaluate a set of simple linear models. Evaluate model fits through visualization. Use R’s formula syntax to specify models. Recognize model families. "],["a-bit-of-mathematics.html", "32.4 A bit of Mathematics:", " 32.4 A bit of Mathematics: Our model is a function of the observed data. This is what we aim to achieve: \\[Y=f(x)\\] The function is made of some coefficients and predictors: \\[f(x)=\\beta_{0}+\\beta_{1}x\\] When we make a model, we attempt to replicate \\(Y=f(x)\\) by applying mathematical models to our observed data. The final objective could be the prediction of an outcome. \\(\\hat{Y}\\) is the result of our model, and this values contain some noise, or residual values which make the model to be slightly different from real values. \\[\\hat{Y}=\\hat{\\beta_{0}}+\\hat{\\beta_{1}}x+\\epsilon\\] The residuals are identified by the difference between \\(Y\\) and \\(\\hat{Y}\\): \\[Y-\\hat{Y}=\\epsilon\\] What we want is to reduce as much as possible this amount of residuals by selecting different type of models and assessing them on different parameter levels. For this purpose we use some metrics to identify the residual level, such as: the r squared (rsq) \\(R^2\\) \\(\\mathrm{adjustedR^2}\\) the residual sum of squares \\(RSS\\) and others To make the formula in Rmarkdown have a look at this resource: markdown-extensions Here is the visualization of simulated data from {modelr} package, we have a look at different slope levels. library(tidyverse) library(manipulate) library(modelr) data(sim1) mod1 &lt;- lm(y~x,sim1) ggplot(sim1,aes(x,y))+ geom_point()+ geom_smooth(method=&quot;lm&quot;)+ theme_bw() We can use the function manipulate() from {manipulate} package, to assess the level of the slope to identify the model line: manipulate(ggplot(sim1,aes(x,y))+ geom_point()+ geom_smooth(method=&quot;lm&quot;)+ geom_abline(intercept=mod1$coefficients[1], slope=r)+ theme_bw(), r=slider(min=1,max=3,step=0.1)) "],["linear-models-and-non-linear-models.html", "32.5 Linear models and non linear models", " 32.5 Linear models and non linear models Linear models assume a relationship of the form: y = a_1 * x1 + a_2 * x2 + ... + a_n * xn and assume that the residuals, the distances between the observed and predicted values, are generally normal distributed or have a normal distribution. Types of Linear models: Linear models - stats::lm() Generalised linear models - stats::glm() Generalised additive models - mgcv::gam() Penalised linear models - glmnet::glmnet() Robust linear models - MASS::rlm() Trees - rpart::rpart() Non linear models are models with a non-linear trend. There are some models that require predictors that have been centered and scaled: neural networks K-nearest neighbors support vector machines SVG while others require a traditional response surface design model expansion (quadratic and two-way interactions). 32.5.1 Transformations We can switch between linear and non-linear models with some transformations: # weighted regression data(sim3) sim3_2&lt;-sim3%&gt;%mutate(x3=case_when(x2==&quot;a&quot;~1, x2==&quot;b&quot;~2, x2==&quot;c&quot;~3, x2==&quot;d&quot;~4)) mod3w &lt;- lm(y~x1, sim3_2, weights = x3) p1&lt;- ggplot(sim3_2, aes(x1, y)) + geom_point()+ geom_smooth()+ labs(title=&quot;Linear model&quot;) # polynomial transformation mod3t &lt;- lm(y~poly(x1,3),sim3_2,weights = x3) p2 &lt;- ggplot(sim3_2, aes(x1, y)) + geom_point()+ geom_smooth(method=&quot;lm&quot;, se=TRUE, fill=NA, formula=y ~ poly(x, 3, raw=TRUE),colour=&quot;red&quot; )+ labs(title=&quot;Polynomial transf.&quot;) # splines library(splines) mod3s &lt;- lm(y ~ bs(x1,3),sim3_2,weights = x3) p3 &lt;- ggplot(sim3_2, aes(x1, y)) + geom_point()+ geom_smooth(method=&quot;lm&quot;, se=TRUE, fill=NA, formula=y~splines::bs(x, 3),colour=&quot;red&quot; )+ labs(title=&quot;Spline transf.&quot;) library(patchwork) p1+p2+p3 When you fit a model, you apply the estimates coefficients of your observed data to the model f \\[y = a_1 + a_2x\\] \\[y = 7 + 3x\\] So, the conversion of the linear model formula \\(y\\sim{x}\\) is \\(y = a_1 + a_2x\\) Behind the scenes, what happens is: model1 &lt;- function(a, data) { a[1] + data$x * a[2] + a[3] } And we can see it with the function model_matrix(): model_matrix(sim3, y ~ x1) ## # A tibble: 120 × 2 ## `(Intercept)` x1 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 1 1 ## 3 1 1 ## 4 1 1 ## 5 1 1 ## 6 1 1 ## 7 1 1 ## 8 1 1 ## 9 1 1 ## 10 1 1 ## # … with 110 more rows "],["prediction.html", "32.6 Prediction", " 32.6 Prediction To make the prediction of our model, sim1_mod &lt;- lm(y ~ x, data = sim1) coef(sim1_mod) ## (Intercept) x ## 4.220822 2.051533 we construct a data_grid() for simulating new data to be predicted: grid &lt;- sim1 %&gt;% data_grid(x) and add the prediction with add_predictions() function: data_pred &lt;- grid %&gt;% add_predictions(sim1_mod) head(data_pred) ## # A tibble: 6 × 2 ## x pred ## &lt;int&gt; &lt;dbl&gt; ## 1 1 6.27 ## 2 2 8.32 ## 3 3 10.4 ## 4 4 12.4 ## 5 5 14.5 ## 6 6 16.5 ggplot(sim1, aes(x,y)) + geom_point() + geom_line(aes(y = pred), data = data_pred, colour = &quot;red&quot;, size = 2)+ geom_smooth(method=&quot;lm&quot;,se=F) ## `geom_smooth()` using formula &#39;y ~ x&#39; as well as before we can add residuals to our data to visualize their trend with add_residuals() function: data_res &lt;- sim1 %&gt;% add_residuals(sim1_mod) head(data_res) ## # A tibble: 6 × 3 ## x y resid ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 4.20 -2.07 ## 2 1 7.51 1.24 ## 3 1 2.13 -4.15 ## 4 2 8.99 0.665 ## 5 2 10.2 1.92 ## 6 2 11.3 2.97 ggplot(data_res, aes(x, resid)) + geom_ref_line(h = 0) + geom_point() 32.6.1 Interaction When we need more investigations: mod1 &lt;- lm(y ~ x1 + x2, data = sim3) mod2 &lt;- lm(y ~ x1 * x2, data = sim3) In this case, as we have two models to compare we gather_predictions: grid2 &lt;- sim3 %&gt;% data_grid(x1, x2) %&gt;% gather_predictions(mod1, mod2) grid2%&gt;%count(model) ## # A tibble: 2 × 2 ## model n ## &lt;chr&gt; &lt;int&gt; ## 1 mod1 40 ## 2 mod2 40 head(grid2) ## # A tibble: 6 × 4 ## model x1 x2 pred ## &lt;chr&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 mod1 1 a 1.67 ## 2 mod1 1 b 4.56 ## 3 mod1 1 c 6.48 ## 4 mod1 1 d 4.03 ## 5 mod1 2 a 1.48 ## 6 mod1 2 b 4.37 ggplot(sim3, aes(x1, y, colour = x2)) + geom_point() + geom_line(data = grid2, aes(y = pred)) + facet_wrap(~ model) as well as gather_residuals(): sim3 %&gt;% gather_residuals(mod1, mod2)%&gt;% ggplot(aes(x1, resid, colour = x2)) + geom_point() + facet_grid(model ~ x2) To conclude we look at the output of different transformations: sim5 &lt;- tibble( x = seq(0, 3.5 * pi, length = 50), y = 4 * sin(x) + rnorm(length(x)) ) ggplot(sim5, aes(x, y)) + geom_point() mod1 &lt;- lm(y ~ ns(x, 1), data = sim5) mod2 &lt;- lm(y ~ ns(x, 2), data = sim5) mod3 &lt;- lm(y ~ ns(x, 3), data = sim5) mod4 &lt;- lm(y ~ ns(x, 4), data = sim5) mod5 &lt;- lm(y ~ ns(x, 5), data = sim5) grid &lt;- sim5 %&gt;% data_grid(x = seq_range(x, n = 50, expand = 0.1)) %&gt;% gather_predictions(mod1, mod2, mod3, mod4, mod5, .pred = &quot;y&quot;) ggplot(sim5, aes(x, y)) + geom_point() + geom_line(data = grid, colour = &quot;red&quot;) + facet_wrap(~ model) "],["resources-1.html", "32.7 Resources:", " 32.7 Resources: tidymodels markdown-extensions-by-bookdown geom_smooth "],["meeting-videos-32.html", "32.8 Meeting Videos", " 32.8 Meeting Videos 32.8.1 Cohort 5 Meeting chat log 00:10:00 Jon Harmon (jonthegeek): https://www.youtube.com/c/TidyX_screencast/playlists?app=desktop 00:10:13 Jon Harmon (jonthegeek): https://twitter.com/kierisi 00:10:42 Jon Harmon (jonthegeek): https://twitter.com/FGazzelloni 00:10:48 Federica Gazzelloni: @fgazzelloni 00:11:10 Jon Harmon (jonthegeek): https://twitter.com/search?q=%23TidyTuesday 00:12:17 Jon Harmon (jonthegeek): https://twitter.com/RLadiesGlobal 00:12:36 Federica Gazzelloni: https://rladies.org/ 00:13:03 Jon Harmon (jonthegeek): https://twitter.com/RLadiesLima 00:38:04 Njoki Njuki Lucy: for the linear regression model, what&#39;s the difference having the interaction effect as * or :? like y~x1*x2/ y~x1:x2 I have seen both being used but I haven&#39;t understood the difference yet 😄 Or for one (*) we must include the main effects? 00:39:50 Njoki Njuki Lucy: aah okay :) 00:48:05 Jon Harmon (jonthegeek): * includes : plus the terms without interaction, so in most cases it makes sense to just use *: y ~ x1*x2 = y ~ x1 + x2 + x1:x2 00:49:50 Njoki Njuki Lucy: thanks! 01:05:06 Ryan Metcalf: Maybe another thought towards differences between `baseR`, `tidyverse`, or `tidy models` is like having a simple toolkit for your home…something small like Hammer, Screwdriver, and wrench set versus having an entire tool box of specific tools. It gives more granular choice for specific jobs. 01:05:28 Ryan Metcalf: Or an entire workshop with power tools too!!! 01:06:59 Becki R. (she/her): That&#39;s a helpful description, Ryan, thanks! 01:07:33 Ryan Metcalf: Both kids live on their own. I hate showing up to hang a picture and realize the tool kits we gave for Xmas doesn’t have a tool to make the job easier. Meeting chat log 00:51:07 Becki R. (she/her): i&#39;m fading fast - catch up with you all next week. 00:52:36 Federica Gazzelloni: https://www.tidymodels.org/start/ 00:55:00 Federica Gazzelloni: https://rpruim.github.io/s341/S19/from-class/MathinRmd.html 00:55:46 Federica Gazzelloni: https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html 00:56:00 Federica Gazzelloni: https://ggplot2.tidyverse.org/reference/geom_smooth.html 00:56:49 Ryan Metcalf: Another LaTeX code editor: https://latex.codecogs.com/eqneditor/editor.php 00:57:14 Federica Gazzelloni: thanks ryan 32.8.2 Cohort 6 Meeting chat log 00:44:13 Adeyemi Olusola: Yeah 00:44:41 Marielena Soilemezidi: great! 00:44:43 Adeyemi Olusola: Thank you Daniel 00:44:55 Marielena Soilemezidi: thanks for the presentation Daniel! 00:45:14 Daniel Adereti: https://personal.math.ubc.ca/~anstee/math104/newtonmethod.pdf "],["model-building.html", "Model building", " Model building Learning objectives: Build a linear model to explain trends in data. Examine the residuals of a model to identify remaining trends in data. Perform feature engineering to explain trends in data. Recognize some resources to learn more about modeling. "],["eda-vs-prediction.html", "32.9 EDA vs Prediction", " 32.9 EDA vs Prediction Reminder: This book focuses on exploratory data analysis, not prediction. "],["build-a-linear-model.html", "32.10 Build a Linear Model", " 32.10 Build a Linear Model diamonds2 &lt;- diamonds %&gt;% filter(carat &lt;= 2.5) %&gt;% mutate(log_price = log2(price), log_carat = log2(carat)) mod_diamond &lt;- lm(log_price ~ log_carat, data = diamonds2) grid &lt;- diamonds2 %&gt;% data_grid(carat = seq_range(carat, 20)) %&gt;% mutate(log_carat = log2(carat)) %&gt;% add_predictions(mod_diamond, &quot;log_price&quot;) %&gt;% mutate(price = 2 ^ log_price) ggplot(diamonds2) + aes(carat, price) + geom_hex(bins = 50) + geom_line(data = grid, color = &quot;red&quot;, size = 1) ## Warning: Computation failed in `stat_binhex()`: "],["examine-residuals.html", "32.11 Examine Residuals", " 32.11 Examine Residuals diamonds2 &lt;- diamonds2 %&gt;% add_residuals(mod_diamond, &quot;log_resid&quot;) ggplot(diamonds2) + aes(log_carat, log_resid) + geom_hex(bins = 50) ## Warning: Computation failed in `stat_binhex()`: base_plot &lt;- ggplot(diamonds2) + aes(y = log_resid) + geom_boxplot() base_plot + aes(cut) base_plot + aes(color) base_plot + aes(clarity) "],["another-diamonds-model.html", "32.12 Another Diamonds Model", " 32.12 Another Diamonds Model mod_diamond2 &lt;- lm( log_price ~ log_carat + color + cut + clarity, data = diamonds2 ) plot_mod2 &lt;- function(parameter) { grid &lt;- diamonds2 %&gt;% data_grid({{parameter}}, .model = mod_diamond2) %&gt;% add_predictions(mod_diamond2) ggplot(grid) + aes(x = {{parameter}}, y = pred) + geom_point() } plot_mod2(cut) plot_mod2(color) plot_mod2(clarity) diamonds2 &lt;- diamonds2 %&gt;% add_residuals(mod_diamond2, &quot;log_resid2&quot;) ggplot(diamonds2) + aes(log_carat, log_resid2) + geom_hex(bins = 50) ## Warning: Computation failed in `stat_binhex()`: "],["feature-engineering.html", "32.13 Feature Engineering", " 32.13 Feature Engineering daily &lt;- flights %&gt;% mutate(date = make_date(year, month, day)) %&gt;% group_by(date) %&gt;% summarise(n = n()) ggplot(daily) + aes(date, n) + geom_line() Feature engineering = using data to create new features to use in models daily &lt;- daily %&gt;% mutate(wday = wday(date, label = TRUE, week_start = 1)) ggplot(daily) + aes(wday, n) + geom_boxplot() mod &lt;- lm(n ~ wday, data = daily) grid &lt;- daily %&gt;% data_grid(wday) %&gt;% add_predictions(mod, &quot;n&quot;) ggplot(daily) + aes(wday, n) + geom_boxplot() + geom_point(data = grid, colour = &quot;red&quot;, size = 4) daily &lt;- daily %&gt;% add_residuals(mod) base_plot &lt;- ggplot(daily) + aes(date, resid) + geom_ref_line(h = 0) + geom_line() base_plot base_plot + aes(color = wday) base_plot + geom_smooth(se = FALSE, span = 0.20) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; daily %&gt;% filter(resid &lt; -100) %&gt;% pull(date, wday) ## Tue Sun Sun Thu Fri Sun ## &quot;2013-01-01&quot; &quot;2013-01-20&quot; &quot;2013-05-26&quot; &quot;2013-07-04&quot; &quot;2013-07-05&quot; &quot;2013-09-01&quot; ## Thu Fri Tue Wed Tue ## &quot;2013-11-28&quot; &quot;2013-11-29&quot; &quot;2013-12-24&quot; &quot;2013-12-25&quot; &quot;2013-12-31&quot; term &lt;- function(date) { cut(date, breaks = ymd(20130101, 20130605, 20130825, 20140101), labels = c(&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;) ) } daily &lt;- daily %&gt;% mutate(term = term(date)) mod2 &lt;- MASS::rlm(n ~ wday * term, data = daily) daily %&gt;% add_residuals(mod2, &quot;resid&quot;) %&gt;% ggplot() + aes(date, resid) + geom_hline(yintercept = 0, size = 2, colour = &quot;white&quot;) + geom_line() "],["learning-more-1.html", "32.14 Learning More", " 32.14 Learning More An Introduction to Statistical Learning (with Applications in R) (statlearning.com / #book_club-islr): Statistical explanations of various machine learning methods, with explanations of how to apply them in R. A good introduction to all of the types of models and why they work (or don’t work) the way they do. Tidy Modeling with R (tmwr.org / #book_club-tmwr): An opinionated introduction to using the tidymodels family of packages to build predictive models. Very hands-on and useful, but I think I might want to read it again after ISLR. Feature Engineering and Selection: A Practical Approach for Predictive Models (feat.engineering / #book_club-feat_eng): Techniques for manipulating data to get better results out of models. Applied Predictive Modeling (github.com/topepo/tidy-apm / #project-tidy_apm): There isn’t a free online version of this book yet, but it’s at least theoretically in the works. This was published about 10 years ago by the leader of the tidymodels team, and he has started to update it to tidymodels code. I’d recommend not reading this one until/unless he takes that project back up (very possibly with the help of the R4DS community). "],["meeting-videos-33.html", "32.15 Meeting Videos", " 32.15 Meeting Videos 32.15.1 Cohort 5 Meeting chat log 00:18:47 Njoki Njuki Lucy: yes 00:56:00 Ryan Metcalf: @Sandra, here is a LARGE section to answer your question. I’m banking that Federica will provide a more specific code snippet….https://ggplot2-book.org/scales-guides.html#scales-guides 00:56:09 Federica Gazzelloni: https://ggplot2.tidyverse.org/reference/guide_colourbar.html 00:57:03 Federica Gazzelloni: ggplot()+geom_…()+guides() 00:58:35 Federica Gazzelloni: guides(color=guide_colourbar()) 32.15.2 Cohort 6 Meeting chat log LOG "],["many-models.html", "Many models", " Many models Learning objectives: Create nested data frames to organize data by groups. Create list-columns to generate new data in an organized structure. Simplify list-columns to manipulate the data they contain. "],["introduction-10.html", "32.16 Introduction", " 32.16 Introduction The main purpose of this section…..is to tidy your data and how model summaries can help us pick out outliers and unusual trends in our data As your experience grows with Exploratory Data Analysis (EDA) you will find your models grow as well This chapter is somewhat aspirational: if this book is your first introduction to R, this chapter is likely to be a struggle. It requires you to have deeply internalised ideas about modelling, data structures, and iteration. So don’t worry if you don’t get it — just put this chapter aside for a few months, and come back when you want to stretch your brain. We are not going to discuss Model Building (even though it is the name of the Chapter) We are going to push through to the end….(but please feel welcome to ask questions!) 32.16.1 Prerequisites We will use both tidyverse and modelr from here. library(modelr) library(tidyverse) "],["gapminder.html", "32.17 gapminder", " 32.17 gapminder Where do I begin to express the awesomness of Hans Rosling (27 July 1948 – 7 February 2017). I HIGHLY encourage you to watch the youtube video! Hans Rosling’s 200 Countries, 200 Years, 4 Minutes - The Joy of Stats - BBC Four Furthermore, we can thank Jenny Bryan for authoring the gapminder package! library(gapminder) To gain some insight to the data, we ask the question: “How does life expectancy (lifeExp) change over time (year) for each country (country)?” gapminder %&gt;% ggplot(aes(year, lifeExp, group = country)) + geom_line(alpha = 1/3) At first glance, it appears life expectancy is increasing…but not for all countries. To make it easier to view, we fit a model with a linear trend. The model captures steady growth over time, and the residuals will show what’s left. nz &lt;- filter(gapminder, country == &quot;New Zealand&quot;) nz %&gt;% ggplot(aes(year, lifeExp)) + geom_line() + ggtitle(&quot;Full data = &quot;) nz_mod &lt;- lm(lifeExp ~ year, data = nz) nz %&gt;% add_predictions(nz_mod) %&gt;% ggplot(aes(year, pred)) + geom_line() + ggtitle(&quot;Linear trend + &quot;) nz %&gt;% add_residuals(nz_mod) %&gt;% ggplot(aes(year, resid)) + geom_hline(yintercept = 0, colour = &quot;white&quot;, size = 3) + geom_line() + ggtitle(&quot;Remaining pattern&quot;) This is good….but how do we do this for every country? 32.17.1 Nested data To make life easier for us (and ensure we are not copying and pasting forever), we use the map function from the purrr package. Here, we are going to make a nested data frame. by_country &lt;- gapminder %&gt;% group_by(country, continent) %&gt;% nest() by_country ## # A tibble: 142 × 3 ## # Groups: country, continent [142] ## country continent data ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; ## 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; ## 2 Albania Europe &lt;tibble [12 × 4]&gt; ## 3 Algeria Africa &lt;tibble [12 × 4]&gt; ## 4 Angola Africa &lt;tibble [12 × 4]&gt; ## 5 Argentina Americas &lt;tibble [12 × 4]&gt; ## 6 Australia Oceania &lt;tibble [12 × 4]&gt; ## 7 Austria Europe &lt;tibble [12 × 4]&gt; ## 8 Bahrain Asia &lt;tibble [12 × 4]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; ## 10 Belgium Europe &lt;tibble [12 × 4]&gt; ## # … with 132 more rows This creates a data frame that has one row per group (per country), and a rather unusual column:data. data is a list of data frames (or tibbles, to be precise). Note: Don’t use the Structure function str() as it will be difficult to view. Instead, just view a single line of your nested dataframe. by_country$data[[1]] ## # A tibble: 12 × 4 ## year lifeExp pop gdpPercap ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1952 28.8 8425333 779. ## 2 1957 30.3 9240934 821. ## 3 1962 32.0 10267083 853. ## 4 1967 34.0 11537966 836. ## 5 1972 36.1 13079460 740. ## 6 1977 38.4 14880372 786. ## 7 1982 39.9 12881816 978. ## 8 1987 40.8 13867957 852. ## 9 1992 41.7 16317921 649. ## 10 1997 41.8 22227415 635. ## 11 2002 42.1 25268405 727. ## 12 2007 43.8 31889923 975. Note the difference between a standard grouped data frame and a nested data frame: in a grouped data frame, each row is an observation; in a nested data frame, each row is a group. 32.17.2 List-columns Now, lets fit some models! country_model &lt;- function(df) { lm(lifeExp ~ year, data = df) } models &lt;- map(by_country$data, country_model) Yet, this may be too costly, so instead, lets modify (be more elegant) with our data. Storing related objects in columns is a key part of the value of data frames. by_country &lt;- by_country %&gt;% mutate(model = map(data, country_model)) by_country ## # A tibble: 142 × 4 ## # Groups: country, continent [142] ## country continent data model ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; ## 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 2 Albania Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 3 Algeria Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 4 Angola Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 5 Argentina Americas &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 6 Australia Oceania &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 7 Austria Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 8 Bahrain Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 10 Belgium Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## # … with 132 more rows This is a huge advantage: because all the related objects are stored together, you don’t need to manually keep them in sync when you filter or arrange. by_country %&gt;% filter(continent == &quot;Europe&quot;) ## # A tibble: 30 × 4 ## # Groups: country, continent [30] ## country continent data model ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; ## 1 Albania Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 2 Austria Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 3 Belgium Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 4 Bosnia and Herzegovina Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 5 Bulgaria Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 6 Croatia Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 7 Czech Republic Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 8 Denmark Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 9 Finland Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 10 France Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## # … with 20 more rows by_country %&gt;% arrange(continent, country) ## # A tibble: 142 × 4 ## # Groups: country, continent [142] ## country continent data model ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; ## 1 Algeria Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 2 Angola Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 3 Benin Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 4 Botswana Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 5 Burkina Faso Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 6 Burundi Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 7 Cameroon Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 8 Central African Republic Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 9 Chad Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## 10 Comoros Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; ## # … with 132 more rows If your list of data frames and list of models were separate objects, you have to remember that whenever you re-order or subset one vector, you need to re-order or subset all the others in order to keep them in sync. If you forget, your code will continue to work, but it will give the wrong answer! 32.17.3 Unnesting Previously, we were working with only one country. Now, lets compute the residuals of ALL countries. by_country &lt;- by_country %&gt;% mutate( resids = map2(data, model, add_residuals) ) by_country ## # A tibble: 142 × 5 ## # Groups: country, continent [142] ## country continent data model resids ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 2 Albania Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 3 Algeria Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 4 Angola Africa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 5 Argentina Americas &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 6 Australia Oceania &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 7 Austria Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 8 Bahrain Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 10 Belgium Europe &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## # … with 132 more rows By now, you should ask yourself: “How can I plot a bunch of dataframes?”. This isn’t required. We have to un-nest. resids &lt;- unnest(by_country, resids) resids ## # A tibble: 1,704 × 9 ## # Groups: country, continent [142] ## country continent data model year lifeExp pop gdpPer…¹ resid ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1952 28.8 8425333 779. -1.11 ## 2 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1957 30.3 9240934 821. -0.952 ## 3 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1962 32.0 10267083 853. -0.664 ## 4 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1967 34.0 11537966 836. -0.0172 ## 5 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1972 36.1 13079460 740. 0.674 ## 6 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1977 38.4 14880372 786. 1.65 ## 7 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1982 39.9 12881816 978. 1.69 ## 8 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1987 40.8 13867957 852. 1.28 ## 9 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1992 41.7 16317921 649. 0.754 ## 10 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; 1997 41.8 22227415 635. -0.534 ## # … with 1,694 more rows, and abbreviated variable name ¹​gdpPercap Now, we can plot ALL the residuals. resids %&gt;% ggplot(aes(year, resid)) + geom_line(aes(group = country), alpha = 1 / 3) + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; We can now plot each country as a facet. resids %&gt;% ggplot(aes(year, resid, group = country)) + geom_line(alpha = 1 / 3) + facet_wrap(~continent) We can note that we still have very large residuals, namely in Africa suggesting our model isn’t fitting very well. 32.17.4 Model quality Instead of looking at the residuals from the model, we could look at some general measurements of model quality. We’ll use broom::glance() to extract some model quality metrics. broom::glance(nz_mod) ## # A tibble: 1 × 12 ## r.squ…¹ adj.r…² sigma stati…³ p.value df logLik AIC BIC devia…⁴ df.re…⁵ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 0.954 0.949 0.804 205. 5.41e-8 1 -13.3 32.6 34.1 6.47 10 ## # … with 1 more variable: nobs &lt;int&gt;, and abbreviated variable names ## # ¹​r.squared, ²​adj.r.squared, ³​statistic, ⁴​deviance, ⁵​df.residual We can use mutate() and unnest() to create a data frame with a row for each country. by_country %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## # A tibble: 142 × 17 ## # Groups: country, continent [142] ## country continent data model resids r.squa…¹ adj.r…² sigma stati…³ ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.948 0.942 1.22 181. ## 2 Albania Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.911 0.902 1.98 102. ## 3 Algeria Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.985 0.984 1.32 662. ## 4 Angola Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.888 0.877 1.41 79.1 ## 5 Argentina Americas &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.996 0.995 0.292 2246. ## 6 Australia Oceania &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.980 0.978 0.621 481. ## 7 Austria Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.992 0.991 0.407 1261. ## 8 Bahrain Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.967 0.963 1.64 291. ## 9 Bangladesh Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.989 0.988 0.977 930. ## 10 Belgium Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.995 0.994 0.293 1822. ## # … with 132 more rows, 8 more variables: p.value &lt;dbl&gt;, df &lt;dbl&gt;, ## # logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;, ## # nobs &lt;int&gt;, and abbreviated variable names ¹​r.squared, ²​adj.r.squared, ## # ³​statistic This isn’t quite the output we want, because it still includes all the list columns. This is default behaviour when unnest() works on single row data frames. To suppress these columns we use .drop = TRUE Note, .drop=TRUE has been depricated. glance &lt;- by_country %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance, .drop = TRUE) ## Warning: The `.drop` argument of `unnest()` is deprecated as of tidyr 1.0.0. ## ℹ All list-columns are now preserved. glance ## # A tibble: 142 × 17 ## # Groups: country, continent [142] ## country continent data model resids r.squa…¹ adj.r…² sigma stati…³ ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.948 0.942 1.22 181. ## 2 Albania Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.911 0.902 1.98 102. ## 3 Algeria Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.985 0.984 1.32 662. ## 4 Angola Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.888 0.877 1.41 79.1 ## 5 Argentina Americas &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.996 0.995 0.292 2246. ## 6 Australia Oceania &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.980 0.978 0.621 481. ## 7 Austria Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.992 0.991 0.407 1261. ## 8 Bahrain Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.967 0.963 1.64 291. ## 9 Bangladesh Asia &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.989 0.988 0.977 930. ## 10 Belgium Europe &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.995 0.994 0.293 1822. ## # … with 132 more rows, 8 more variables: p.value &lt;dbl&gt;, df &lt;dbl&gt;, ## # logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;, ## # nobs &lt;int&gt;, and abbreviated variable names ¹​r.squared, ²​adj.r.squared, ## # ³​statistic Now, we can look for countries that don’t fit our model well. glance %&gt;% arrange(r.squared) ## # A tibble: 142 × 17 ## # Groups: country, continent [142] ## country conti…¹ data model resids r.squ…² adj.r.…³ sigma stati…⁴ ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;lis&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Rwanda Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0172 -0.0811 6.56 0.175 ## 2 Botswana Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0340 -0.0626 6.11 0.352 ## 3 Zimbabwe Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0562 -0.0381 7.21 0.596 ## 4 Zambia Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0598 -0.0342 4.53 0.636 ## 5 Swaziland Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0682 -0.0250 6.64 0.732 ## 6 Lesotho Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.0849 -0.00666 5.93 0.927 ## 7 Cote d&#39;Ivoire Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.283 0.212 3.93 3.95 ## 8 South Africa Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.312 0.244 4.74 4.54 ## 9 Uganda Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.342 0.276 3.19 5.20 ## 10 Congo, Dem. R… Africa &lt;tibble&gt; &lt;lm&gt; &lt;tibble&gt; 0.348 0.283 2.43 5.34 ## # … with 132 more rows, 8 more variables: p.value &lt;dbl&gt;, df &lt;dbl&gt;, ## # logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;, ## # nobs &lt;int&gt;, and abbreviated variable names ¹​continent, ²​r.squared, ## # ³​adj.r.squared, ⁴​statistic The worst fitting models seem to be in Africa. We’ll add geom_jitter() to make it more apparent. We can also plot the particular bad \\[R^2\\] and plot the data. glance %&gt;% ggplot(aes(continent, r.squared)) + geom_jitter(width = 0.5) bad_fit &lt;- filter(glance, r.squared &lt; 0.25) gapminder %&gt;% semi_join(bad_fit, by = &quot;country&quot;) %&gt;% ggplot(aes(year, lifeExp, colour = country)) + geom_line() The relation of this visual is the tragidies of HIV/AIDs epidemic and the Rwanda genocide. "],["list-columns-1.html", "32.18 List-columns", " 32.18 List-columns List-Columns are implicit in the definition of the data frame: a data frame is a named list of equal length vectors. Base-R doesn’t make it easy to create list-columns, and data.frame() treats a list as a list of columns. data.frame(x = list(1:3, 3:5)) ## x.1.3 x.3.5 ## 1 1 3 ## 2 2 4 ## 3 3 5 You can prevent data.frame() from treating a lists of lists by adding I() to the argument. However, this doesn’t print well. I() stands for Inhibit Interpretation/Conversion of Objects: Change the class of an object to indicate that is should be treated as is. data.frame( x = I(list(1:3, 3:5)), y = c(&quot;1, 2&quot;, &quot;3, 4, 5&quot;) ) ## x y ## 1 1, 2, 3 1, 2 ## 2 3, 4, 5 3, 4, 5 Tibble alleviates this problem by being lazier (tibble() doesn’t modify its inputs) and by providing a better print method. Note where the quotes are placed tibble( x = list(1:3, 3:5), y = c(&quot;1, 2&quot;, &quot;3, 4, 5&quot;) ) ## # A tibble: 2 × 2 ## x y ## &lt;list&gt; &lt;chr&gt; ## 1 &lt;int [3]&gt; 1, 2 ## 2 &lt;int [3]&gt; 3, 4, 5 tribble() can automatically work out that you need a list. tribble( ~x, ~y, 1:3, &quot;1, 2&quot;, 3:5, &quot;3, 4, 5&quot; ) ## # A tibble: 2 × 2 ## x y ## &lt;list&gt; &lt;chr&gt; ## 1 &lt;int [3]&gt; 1, 2 ## 2 &lt;int [3]&gt; 3, 4, 5 List-columns are often most useful as intermediate data structure. Advantage of keeping related items together in a data frame is worth a little hassle. There are three parts of an effective list-column pipeline: You create the list-column using one of: nest(), summarise() + list(), or mutate() + a map function You create other intermediate list-columns by transforming existing list columns with map(), map2(), or pmap(). You simplify the list-column back down to a data frame or atomic vector. "],["creating-list-columns.html", "32.19 Creating list-columns", " 32.19 Creating list-columns Typically, you won’t create list-columns with tibble(). Instead, you’ll create them from regular columns, using one of three methods: With tidyr::nest() to convert a grouped data frame into a nested data frame where you have list-column of data frames. With mutate() and vectorised functions that return a list. With summarise() and summary functions that return multiple results. Alternatively, you might create them from a named list, using tibble::enframe() When creating list-columns, make sure they are homogeneous. 32.19.1 With nesting nest() creates a nested data frame, meaning, each row is a meta-observation. When applied to a group data frame, nest() keeps the grouping columns as is. gapminder %&gt;% group_by(country, continent) %&gt;% nest() ## # A tibble: 142 × 3 ## # Groups: country, continent [142] ## country continent data ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; ## 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; ## 2 Albania Europe &lt;tibble [12 × 4]&gt; ## 3 Algeria Africa &lt;tibble [12 × 4]&gt; ## 4 Angola Africa &lt;tibble [12 × 4]&gt; ## 5 Argentina Americas &lt;tibble [12 × 4]&gt; ## 6 Australia Oceania &lt;tibble [12 × 4]&gt; ## 7 Austria Europe &lt;tibble [12 × 4]&gt; ## 8 Bahrain Asia &lt;tibble [12 × 4]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; ## 10 Belgium Europe &lt;tibble [12 × 4]&gt; ## # … with 132 more rows You can also use it on an un-grouped data frame, specifying which columns you want to nest. gapminder %&gt;% nest(data = c(year:gdpPercap)) ## # A tibble: 142 × 3 ## country continent data ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; ## 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; ## 2 Albania Europe &lt;tibble [12 × 4]&gt; ## 3 Algeria Africa &lt;tibble [12 × 4]&gt; ## 4 Angola Africa &lt;tibble [12 × 4]&gt; ## 5 Argentina Americas &lt;tibble [12 × 4]&gt; ## 6 Australia Oceania &lt;tibble [12 × 4]&gt; ## 7 Austria Europe &lt;tibble [12 × 4]&gt; ## 8 Bahrain Asia &lt;tibble [12 × 4]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; ## 10 Belgium Europe &lt;tibble [12 × 4]&gt; ## # … with 132 more rows 32.19.2 From vectorised functions If you use stringr::str_split() + mutate() you get a list-column. Again, note where the quotes are placed. df &lt;- tribble( ~x1, &quot;a,b,c&quot;, &quot;d,e,f,g&quot; ) df %&gt;% mutate(x2 = stringr::str_split(x1, &quot;,&quot;)) ## # A tibble: 2 × 2 ## x1 x2 ## &lt;chr&gt; &lt;list&gt; ## 1 a,b,c &lt;chr [3]&gt; ## 2 d,e,f,g &lt;chr [4]&gt; And now unnest() knows how to handle these list of vectors. df %&gt;% mutate(x2 = stringr::str_split(x1, &quot;,&quot;)) %&gt;% unnest(x2) ## # A tibble: 7 × 2 ## x1 x2 ## &lt;chr&gt; &lt;chr&gt; ## 1 a,b,c a ## 2 a,b,c b ## 3 a,b,c c ## 4 d,e,f,g d ## 5 d,e,f,g e ## 6 d,e,f,g f ## 7 d,e,f,g g If you find yourself using this pattern a lot, make sure to check out tidyr::separate_rows() which is a wrapper around this common pattern. Another example uses map(),map2(), and pmap(). We could re-write Invoking different functions and rewrite it to use mutate(). Previous Example Code: sim &lt;- tribble( ~f, ~params, &quot;runif&quot;, list(min = -1, max = 1), &quot;rnorm&quot;, list(sd = 5), &quot;rpois&quot;, list(lambda = 10) ) sim %&gt;% mutate(sim = invoke_map(f, params, n = 10)) ## # A tibble: 3 × 3 ## f params sim ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 runif &lt;named list [2]&gt; &lt;dbl [10]&gt; ## 2 rnorm &lt;named list [1]&gt; &lt;dbl [10]&gt; ## 3 rpois &lt;named list [1]&gt; &lt;int [10]&gt; Refactored Code using mutate() sim &lt;- tribble( ~f, ~params, &quot;runif&quot;, list(min = -1, max = 1), &quot;rnorm&quot;, list(sd = 5), &quot;rpois&quot;, list(lambda = 10) ) sim %&gt;% mutate(sims = invoke_map(f, params, n = 10)) ## # A tibble: 3 × 3 ## f params sims ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 runif &lt;named list [2]&gt; &lt;dbl [10]&gt; ## 2 rnorm &lt;named list [1]&gt; &lt;dbl [10]&gt; ## 3 rpois &lt;named list [1]&gt; &lt;int [10]&gt; I donm’t understand what is being expressed here…..the two code snippets are identical, except in chapter 25, the name is sims instead. Thoughts? 32.19.3 From multivalued summaries One restriction of summarise() is it only works with summary functions that return a single value. Implying, you can’t use it with functions like quantile() that return a vector of arbitrary length. mtcars %&gt;% group_by(cyl) %&gt;% summarise(q = quantile(mpg)) ## `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` ## argument. ## # A tibble: 15 × 2 ## # Groups: cyl [3] ## cyl q ## &lt;dbl&gt; &lt;dbl&gt; ## 1 16 21.4 ## 2 16 22.8 ## 3 16 26 ## 4 16 30.4 ## 5 16 33.9 ## 6 24 17.8 ## 7 24 18.6 ## 8 24 19.7 ## 9 24 21 ## 10 24 21.4 ## 11 32 10.4 ## 12 32 14.4 ## 13 32 15.2 ## 14 32 16.2 ## 15 32 19.2 You can however, wrap the result in a list! This obeys the contract of summarise(), because each summary is now a list (a vector) of length 1. mtcars %&gt;% group_by(cyl) %&gt;% summarise(q = list(quantile(mpg))) ## # A tibble: 3 × 2 ## cyl q ## &lt;dbl&gt; &lt;list&gt; ## 1 16 &lt;dbl [5]&gt; ## 2 24 &lt;dbl [5]&gt; ## 3 32 &lt;dbl [5]&gt; To make useful results with unnest90, you’ll also ned to capture probabilities. probs &lt;- c(0.01, 0.25, 0.5, 0.75, 0.99) mtcars %&gt;% group_by(cyl) %&gt;% summarise(p = list(probs), q = list(quantile(mpg, probs))) %&gt;% unnest(c(p, q)) ## # A tibble: 15 × 3 ## cyl p q ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 16 0.01 21.4 ## 2 16 0.25 22.8 ## 3 16 0.5 26 ## 4 16 0.75 30.4 ## 5 16 0.99 33.8 ## 6 24 0.01 17.8 ## 7 24 0.25 18.6 ## 8 24 0.5 19.7 ## 9 24 0.75 21 ## 10 24 0.99 21.4 ## 11 32 0.01 10.4 ## 12 32 0.25 14.4 ## 13 32 0.5 15.2 ## 14 32 0.75 16.2 ## 15 32 0.99 19.1 32.19.4 From a named list What do you do if you want to iterate over both the contents of a list and its elements? Make a data frame with one column containing the elements and another column containing the list! You can use tibble::enframe(). x &lt;- list( a = 1:5, b = 3:4, c = 5:6 ) df &lt;- enframe(x) df ## # A tibble: 3 × 2 ## name value ## &lt;chr&gt; &lt;list&gt; ## 1 a &lt;int [5]&gt; ## 2 b &lt;int [2]&gt; ## 3 c &lt;int [2]&gt; Now, if we want to iterate over names and values in parrallel, we can use map2(). df %&gt;% mutate( smry = map2_chr(name, value, ~ stringr::str_c(.x, &quot;: &quot;, .y[1])) ) ## # A tibble: 3 × 3 ## name value smry ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; ## 1 a &lt;int [5]&gt; a: 1 ## 2 b &lt;int [2]&gt; b: 3 ## 3 c &lt;int [2]&gt; c: 5 "],["simplifying-list-columns.html", "32.20 Simplifying list-columns", " 32.20 Simplifying list-columns To simplify the list-column back to a regular column (an atomic vector) or set of columns: If you want a single value, use mutate() with map_lgl(), map_int(), map_dbl(), and map_chr() to create an atomic vector. If you want many values, use unnest() to convert list-columns back to regular columns, repeating the rows as many times as necessary. 32.20.1 List to vector You can always summarise an object with its type and length, so this code will work regardless of what sort of list-column you have. df &lt;- tribble( ~x, letters[1:5], 1:3, runif(5) ) df %&gt;% mutate( type = map_chr(x, typeof), length = map_int(x, length) ) ## # A tibble: 3 × 3 ## x type length ## &lt;list&gt; &lt;chr&gt; &lt;int&gt; ## 1 &lt;chr [5]&gt; character 5 ## 2 &lt;int [3]&gt; integer 3 ## 3 &lt;dbl [5]&gt; double 5 Although being the same basic information you get from the default tbl print method, you can now use if for filtering. Don’t forget about the map_*() shortcuts - you can use map_chr(x, \"apple\") to extract the string stored in apple for each element of x. Use the .null argument to provide a value to use if the element is missing (instead of returning NULL). df &lt;- tribble( ~x, list(a = 1, b = 2), list(a = 2, c = 4) ) df %&gt;% mutate( a = map_dbl(x, &quot;a&quot;), b = map_dbl(x, &quot;b&quot;, .null = NA_real_) ) ## # A tibble: 2 × 3 ## x a b ## &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &lt;named list [2]&gt; 1 2 ## 2 &lt;named list [2]&gt; 2 NA 32.20.2 Unnesting unnest() works by repeating the regular columns once for each element of the list-column. tibble(x = 1:2, y = list(1:4, 1)) %&gt;% unnest(y) ## # A tibble: 5 × 2 ## x y ## &lt;int&gt; &lt;dbl&gt; ## 1 1 1 ## 2 1 2 ## 3 1 3 ## 4 1 4 ## 5 2 1 You cannot simultaneously unnest two columns that contain different number of elements. # Ok, because y and z have the same number of elements in # every row df1 &lt;- tribble( ~x, ~y, ~z, 1, c(&quot;a&quot;, &quot;b&quot;), 1:2, 2, &quot;c&quot;, 3 ) df1 ## # A tibble: 2 × 3 ## x y z ## &lt;dbl&gt; &lt;list&gt; &lt;list&gt; ## 1 1 &lt;chr [2]&gt; &lt;int [2]&gt; ## 2 2 &lt;chr [1]&gt; &lt;dbl [1]&gt; df1 %&gt;% unnest(c(y, z)) ## # A tibble: 3 × 3 ## x y z ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 a 1 ## 2 1 b 2 ## 3 2 c 3 # Doesn&#39;t work because y and z have different number of elements df2 &lt;- tribble( ~x, ~y, ~z, 1, &quot;a&quot;, 1:2, 2, c(&quot;b&quot;, &quot;c&quot;), 3 ) df2 ## # A tibble: 2 × 3 ## x y z ## &lt;dbl&gt; &lt;list&gt; &lt;list&gt; ## 1 1 &lt;chr [1]&gt; &lt;int [2]&gt; ## 2 2 &lt;chr [2]&gt; &lt;dbl [1]&gt; df2 %&gt;% unnest(c(y, z)) ## # A tibble: 4 × 3 ## x y z ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 a 1 ## 2 1 a 2 ## 3 2 b 3 ## 4 2 c 3 "],["making-tidy-data-with-broom.html", "32.21 Making tidy data with broom", " 32.21 Making tidy data with broom The broom package provides three general tools for turning models into tidy data frames: broom::glance(model) returns a row for each model. Each column gives a model summary: either a measure of model quality, or complexity, or a combination of the two. broom::tidy(model) returns a row for each coefficient in the model. Each column gives information about the estimate or its variability. broom::augment(model, data) returns a row for each row in data, adding extra values like residuals, and influence statistics. Any Questions? "],["meeting-videos-34.html", "32.22 Meeting Videos", " 32.22 Meeting Videos 32.22.1 Cohort 5 Meeting chat log 00:09:25 Jon Harmon (jonthegeek): r4ds.io/bookclubber 01:07:14 Jon Harmon (jonthegeek): ggrepel Meeting chat log 00:10:13 Njoki Njuki Lucy: It will be nice to see familiar faces :) 00:36:21 Jon Harmon (jonthegeek): sim &lt;- tribble( ~params, list(min = -1, max = 1), list(min = -1, max = 2), list(min = -1, max = 3) ) set.seed(424242) use_purrr &lt;- sim %&gt;% mutate( sims = map(params, runif) ) set.seed(424242) use_rowwise &lt;- sim %&gt;% rowwise() %&gt;% mutate( sims = list(runif(params)) ) %&gt;% ungroup() identical(use_purrr, use_rowwise) 00:37:40 Jon Harmon (jonthegeek): &gt; use_purrr # A tibble: 3 x 2 params sims &lt;list&gt; &lt;list&gt; 1 &lt;named list [2]&gt; &lt;dbl [2]&gt; 2 &lt;named list [2]&gt; &lt;dbl [2]&gt; 3 &lt;named list [2]&gt; &lt;dbl [2]&gt; 00:52:42 Jon Harmon (jonthegeek): &gt; tibble(x = 1:2, y = list(1:4, 1)) # A tibble: 2 x 2 x y &lt;int&gt; &lt;list&gt; 1 1 &lt;int [4]&gt; 2 2 &lt;dbl [1]&gt; 00:57:04 Jon Harmon (jonthegeek): &gt; df2 %&gt;% unnest(c(y)) # A tibble: 3 x 3 x y z &lt;dbl&gt; &lt;chr&gt; &lt;list&gt; 1 1 a &lt;int [2]&gt; 2 2 b &lt;dbl [1]&gt; 3 2 c &lt;dbl [1]&gt; 00:57:23 Jon Harmon (jonthegeek): &gt; df2 %&gt;% unnest(y) %&gt;% unnest(z) # A tibble: 4 x 3 x y z &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 1 a 1 2 1 a 2 3 2 b 3 4 2 c 3 01:11:05 Njoki Njuki Lucy: that&#39;s what I have been doing - doing the surgery😄 01:11:33 Njoki Njuki Lucy: :) 32.22.2 Cohort 6 Meeting chat log LOG "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
